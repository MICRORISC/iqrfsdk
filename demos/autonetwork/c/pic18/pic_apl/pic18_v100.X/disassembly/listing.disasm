Disassembly Listing for ck_usb_04a
Generated From:
E:/projects/CK-USB-04A/001/pic_apl/ck_usb_04a.X/dist/default/production/ck_usb_04a.X.production.cof
13.9.2013 15:20:01

---  E:/projects/CK-USB-04A/001/pic_apl/user.c  ---------------------------------------------------------
1:             
2:             #include "user.h"
3:             
4:                                                         // s bootloaderem - aplikace si natahne ID z bootloaderu
5:             #if !defined (WITH_BOOTLOADER)				// bez bootloaderu - je nutne ID zadat 
6:             	#pragma romdata DATA1 = ADR_ID1 		
7:             	rom	unsigned char IDF1 = VAL_ID1;
8:             	#pragma romdata
9:             	#pragma romdata DATA2 = ADR_ID2 
10:            	rom	unsigned char IDF2 = VAL_ID2;
11:            	#pragma romdata
12:            	#pragma romdata DATA3 = ADR_ID3
13:            	rom	unsigned char IDF3 = VAL_ID3;
14:            	#pragma romdata
15:            #endif
16:            
17:            #pragma udata my_new_data_section=0x200
18:            unsigned char CK_Reserved;
19:            unsigned char countLED1, countLED2, countSSpin;
20:                           
21:            #pragma udata USB_VARS =0x300
22:            DATA_PACKET INPacket;
23:            DATA_PACKET OUTPacket;
24:            
25:            #pragma udata USB_VARS1 =0x400
26:            USB_HANDLE USBGenericOutHandle = 0;
27:            USB_HANDLE USBGenericInHandle = 0;
28:            
29:            #pragma udata  
30:            BYTE TR_state, counter;
31:            volatile DWORD tick, T10ms_tick, T100ms_tick, TR_ctrl_tick;    	// tick counters
32:            unsigned int TR_timeout;
33:            DWORD_VAL SourceAddr;
34:            unsigned char ID1, ID2, ID3, numBytesRead, GW_Reset_Timer;
35:            FLAGS flag;
36:            unsigned char tmp_buf[IQRF_SPI_BUFFER_SIZE], TR_InfoBuf[8];
37:            
38:            extern unsigned char IQRF_SPI_TxBuf[IQRF_SPI_BUFFER_SIZE], IQRF_SPI_RxBuf[IQRF_SPI_BUFFER_SIZE];
39:            extern unsigned char IQRF_SPI_Busy, iq_DLEN, iq_PTYPE, iq_spistat, IQRF_SPI_Task_Message, iq_pac_len;
40:            
41:            #pragma code
42:            //---------------------------------------------------------------------------
43:            
44:            void UserInit(void)
45:            { 
46:             	InitializeBoard();							// Initialize application specific hardware
0828  D881     RCALL InitializeBoard
47:             	IQRF_SPI_Init();							// Initialize SPI-TR module
082A  ECAB     CALL 0x2756, 0
082C  F013     NOP
48:             	TickInit();
082E  EC96     CALL 0x112C, 0
0830  F008     NOP
49:             	
50:            #if defined(WITH_BOOTLOADER)    //(kvuli prostoru emul.EEPROM)
51:             	if (FlashReadByte(EE_ADR_CONFIG) != EEPROM_HAS_CONFIG)	// Is there a GW settings in the emul. EEPROM?
0832  0E01     MOVLW 0x1
0834  6EE6     MOVWF POSTINC1, ACCESS
0836  0E04     MOVLW 0x4
0838  6EE6     MOVWF POSTINC1, ACCESS
083A  EC54     CALL 0x12A8, 0
083C  F009     NOP
083E  52E5     MOVF POSTDEC1, F, ACCESS
0840  52E5     MOVF POSTDEC1, F, ACCESS
0842  0833     SUBLW 0x33
0844  E002     BZ 0x84A
52:            	{											// no
53:                    DefaultEepromInit();					// default settings to emul. EEPROM (factory settings)
0846  EC3A     CALL 0x1474, 0
0848  F00A     NOP
54:            	}
55:            
56:            	GwConfigFromEeprom();						// GW settings from emul. EEPROM
084A  EC42     CALL 0x1484, 0
084C  F00A     NOP
57:            	
58:            	if (BTN1_IO == 0)                           // stisknute tl. po resetu prepina USB mode
084E  B881     BTFSC PORTB, 4, ACCESS
0850  D011     BRA 0x874
59:            	{ 
60:                    flag.CDC_mode ^= 1;
0852  0103     MOVLB 0x3
0854  759D     BTG 0x9D, 2, BANKED
61:                    FlashWriteByte(EE_ADR_USB_MODE, flag.CDC_mode);
0856  0103     MOVLB 0x3
0858  519D     MOVF 0x9D, W, BANKED
085A  0B04     ANDLW 0x4
085C  E001     BZ 0x860
085E  0E01     MOVLW 0x1
0860  6EE6     MOVWF POSTINC1, ACCESS
0862  0E02     MOVLW 0x2
0864  6EE6     MOVWF POSTINC1, ACCESS
0866  0E04     MOVLW 0x4
0868  6EE6     MOVWF POSTINC1, ACCESS
086A  EC89     CALL 0x1312, 0
086C  F009     NOP
086E  52E5     MOVF POSTDEC1, F, ACCESS
0870  52E5     MOVF POSTDEC1, F, ACCESS
0872  52E5     MOVF POSTDEC1, F, ACCESS
62:                }
63:            #else
64:                flag.CDC_mode = 0;                          // 0 - Custom mode, 1 - CDC mode
65:            #endif        
66:            
67:            	CK_Reserved = FREE_CK;
0874  0102     MOVLB 0x2
0876  6900     SETF i, BANKED
68:            	countLED1 = 0;
0878  0102     MOVLB 0x2
087A  6B01     CLRF p, BANKED
69:            	countLED2 = 0;
087C  0102     MOVLB 0x2
087E  6B02     CLRF pUEP, BANKED
70:            	countSSpin = 0;
0880  0102     MOVLB 0x2
0882  6B03     CLRF temp, BANKED
71:            	memset(TR_InfoBuf, 0, sizeof(TR_InfoBuf));
0884  0E08     MOVLW 0x8
0886  6EE6     MOVWF POSTINC1, ACCESS
0888  6AE6     CLRF POSTINC1, ACCESS
088A  6AE6     CLRF POSTINC1, ACCESS
088C  0EDF     MOVLW 0xDF
088E  6EE6     MOVWF POSTINC1, ACCESS
0890  0E03     MOVLW 0x3
0892  6EE6     MOVWF POSTINC1, ACCESS
0894  EC25     CALL 0x2C4A, 0
0896  F016     NOP
0898  6E14     MOVWF __tmp_0, ACCESS
089A  0E05     MOVLW 0x5
089C  5CE1     SUBWF FSR1L, W, ACCESS
089E  E202     BC 0x8A4
08A0  6AE1     CLRF FSR1L, ACCESS
08A2  52E5     MOVF POSTDEC1, F, ACCESS
08A4  6EE1     MOVWF FSR1L, ACCESS
08A6  5014     MOVF __tmp_0, W, ACCESS
72:            	flag.LED_Flashing = FALSE;
08A8  0103     MOVLB 0x3
08AA  919D     BCF 0x9D, 0, BANKED
73:            	flag.BTN1_pressed = FALSE;
08AC  0103     MOVLB 0x3
08AE  979D     BCF 0x9D, 3, BANKED
74:            	flag.BTN2_pressed = FALSE;
08B0  0103     MOVLB 0x3
08B2  999D     BCF 0x9D, 4, BANKED
75:            	flag.EnableMemWrite = FALSE;
08B4  0103     MOVLB 0x3
08B6  9B9D     BCF 0x9D, 5, BANKED
76:            	flag.SS_pin = FALSE;
08B8  0103     MOVLB 0x3
08BA  9D9D     BCF 0x9D, 6, BANKED
77:            	flag.GW_Reset = FALSE;
08BC  0103     MOVLB 0x3
08BE  919E     BCF 0x9E, 0, BANKED
78:            	
79:            	if (flag.CDC_mode)
08C0  0103     MOVLB 0x3
08C2  A59D     BTFSS 0x9D, 2, BANKED
08C4  D008     BRA 0x8D6
80:            	{
81:                    flag.GetModuleInfo = TRUE;
08C6  0103     MOVLB 0x3
08C8  8F9D     BSF 0x9D, 7, BANKED
82:                    flag.EnterProgMode = TRUE;
08CA  0103     MOVLB 0x3
08CC  839D     BSF 0x9D, 1, BANKED
83:            		TR_state = TR_RESET;                    // v CDC po resetu vycte Module Info
08CE  0103     MOVLB 0x3
08D0  0E01     MOVLW 0x1
08D2  6F80     MOVWF 0x80, BANKED
84:                }
85:                else
08D4  D006     BRA 0x8E2
86:                {
87:                    flag.GetModuleInfo = FALSE;
08D6  0103     MOVLB 0x3
08D8  9F9D     BCF 0x9D, 7, BANKED
88:            	    flag.EnterProgMode = FALSE;
08DA  0103     MOVLB 0x3
08DC  939D     BCF 0x9D, 1, BANKED
89:            	    TR_state = TR_READY;   
08DE  0103     MOVLB 0x3
08E0  6B80     CLRF 0x80, BANKED
90:                }
91:            	
92:            	//                                          // cteni ID z flash
93:                SourceAddr.Val = ADR_ID1;					
08E2  0103     MOVLB 0x3
08E4  0EFD     MOVLW 0xFD
08E6  6F94     MOVWF 0x94, BANKED
08E8  0E0B     MOVLW 0xB
08EA  6F95     MOVWF 0x95, BANKED
08EC  6B96     CLRF 0x96, BANKED
08EE  6B97     CLRF 0x97, BANKED
94:            	TBLPTRU = SourceAddr.byte.UB;	
08F0  C396     MOVFF 0x396, TBLPTRU
08F2  FFF8     NOP
95:               	TBLPTRH = SourceAddr.byte.HB;
08F4  C395     MOVFF 0x395, TBLPTRH
08F6  FFF7     NOP
96:               	TBLPTRL = SourceAddr.byte.LB;
08F8  C394     MOVFF SourceAddr, TBLPTRL
08FA  FFF6     NOP
97:            	 _asm TBLRD _endasm
08FC  0008     TBLRD*
98:            	ID1 = TABLAT;
08FE  CFF5     MOVFF TABLAT, ID1
0900  F398     NOP
99:            	
100:           	TBLPTRL++;
0902  2AF6     INCF TBLPTRL, F, ACCESS
101:           	_asm TBLRD _endasm
0904  0008     TBLRD*
102:           	ID2 = TABLAT;
0906  CFF5     MOVFF TABLAT, ID2
0908  F399     NOP
103:           	
104:           	TBLPTRL++;
090A  2AF6     INCF TBLPTRL, F, ACCESS
105:           	_asm TBLRD _endasm
090C  0008     TBLRD*
106:           	ID3 = TABLAT;
090E  CFF5     MOVFF TABLAT, ID3
0910  F39A     NOP
107:           	
108:           	Delay_ms(250);                      // startup indication
0912  0EFA     MOVLW 0xFA
0914  6EE6     MOVWF POSTINC1, ACCESS
0916  EC88     CALL 0x1110, 0
0918  F008     NOP
091A  52E5     MOVF POSTDEC1, F, ACCESS
109:               Delay_ms(250);
091C  0EFA     MOVLW 0xFA
091E  6EE6     MOVWF POSTINC1, ACCESS
0920  EC88     CALL 0x1110, 0
0922  F008     NOP
0924  52E5     MOVF POSTDEC1, F, ACCESS
110:               LED1_IO = 0;
0926  908B     BCF LATC, 0, ACCESS
111:               LED2_IO = 0;
0928  948A     BCF LATB, 2, ACCESS
112:           }
092A  0012     RETURN 0
113:           //---------------------------------------------------------------------------
114:           
115:           void InitializeBoard(void)
116:           {
117:               INTCON  = 0xC0;			// GIE=1, PEIE=1
092C  0EC0     MOVLW 0xC0
092E  6EF2     MOVWF INTCON, ACCESS
118:               INTCON2 = 0x00;			// RB pullup ON
0930  6AF1     CLRF INTCON2, ACCESS
119:               INTCON3 = 0;
0932  6AF0     CLRF INTCON3, ACCESS
120:           
121:               TRISA = 0b00010001;
0934  0E11     MOVLW 0x11
0936  6E92     MOVWF TRISA, ACCESS
122:               LATA  = 0b00000000;
0938  6A89     CLRF LATA, ACCESS
123:               
124:               TRISB = 0b00110000;
093A  0E30     MOVLW 0x30
093C  6E93     MOVWF TRISB, ACCESS
125:               LATB  = 0b00111100;                 // LED2 ON
093E  0E3C     MOVLW 0x3C
0940  6E8A     MOVWF LATB, ACCESS
126:               
127:               TRISC = 0b01111110;
0942  0E7E     MOVLW 0x7E
0944  6E94     MOVWF TRISC, ACCESS
128:               LATC  = 0b00000001;                 // LED1 ON
0946  0E01     MOVLW 0x1
0948  6E8B     MOVWF LATC, ACCESS
129:           
130:           // PPS settings
131:           // !!! Check SPI setting in HardwareProfile.h upon PPS change!!!	
132:           	
133:           // Inputs
134:               RPINR21 = 17;                       // RP17 = SDI2_TR
094A  010E     MOVLB 0xE
094C  0E11     MOVLW 0x11
094E  6FFB     MOVWF 0xFB, BANKED
135:           	
136:           // Outputs
137:               RPOR18  = 9;                        // RP18 = SDO2_TR
0950  0E09     MOVLW 0x9
0952  6FD8     MOVWF 0xD8, BANKED
138:               RPOR3 	= 10;                   // RP3 = SCK2_TR
0954  0E0A     MOVLW 0xA
0956  6FC9     MOVWF 0xC9, BANKED
139:           
140:               EECON2 = 0x55;                      // lock sequence
0958  0E55     MOVLW 0x55
095A  6EA7     MOVWF EECON2, ACCESS
141:               EECON2 = 0xAA;
095C  0EAA     MOVLW 0xAA
095E  6EA7     MOVWF EECON2, ACCESS
142:               PPSCONbits.IOLOCK = 1;
0960  81FF     BSF 0xFF, 0, BANKED
143:           // end of PPS settings
144:           
145:           // TMR0	- free
146:           // TMR1	- free
147:           // TMR2	- Clock for SPI TR
148:           // TMR3	- free
149:           // TMR4	- Tick counter - Interupt
150:           }
0962  0012     RETURN 0
151:           //---------------------------------------------------------------------------
152:           
153:           void ProcessIO(void)
154:           {
155:           	if (tick - T10ms_tick >= 10)		// zde kazdych 10ms
0964  0E86     MOVLW 0x86
0966  6EE9     MOVWF FSR0L, ACCESS
0968  0E03     MOVLW 0x3
096A  ECD9     CALL 0x15B2, 0
096C  F00A     NOP
096E  0E0A     MOVLW 0xA
0970  EC1A     CALL 0x1634, 0
0972  F00B     NOP
0974  E30C     BNC 0x98E
15B2  6EEA     MOVWF FSR0H, ACCESS
15B4  50EE     MOVF POSTINC0, W, ACCESS
15B6  0103     MOVLB 0x3
15B8  EF41     GOTO 0x1682
15BA  F00B     NOP
1634  5C14     SUBWF __tmp_0, W, ACCESS
1636  0E00     MOVLW 0x0
1638  5815     SUBWFB 0x15, W, ACCESS
163A  0E00     MOVLW 0x0
163C  5816     SUBWFB 0x16, W, ACCESS
163E  0E00     MOVLW 0x0
1640  5817     SUBWFB 0x17, W, ACCESS
1642  0012     RETURN 0
156:           	{
157:           		T10ms_tick = tick;				// reset tick counter
0976  C382     MOVFF tick, T10ms_tick
0978  F386     NOP
097A  C383     MOVFF 0x383, 0x387
097C  F387     NOP
097E  C384     MOVFF 0x384, 0x388
0980  F388     NOP
0982  C385     MOVFF 0x385, 0x389
0984  F389     NOP
158:           
159:           	    if (!TR_state)					// pouze pokud se nekomunikuje pres SPI s TR modulem
0986  5180     MOVF 0x80, W, BANKED
0988  E101     BNZ 0x98C
160:           		{
161:           			Button_1_Task();			// obsluha tlacitka (funkce SS)
098A  DAD7     RCALL Button_1_Task
162:           		}
163:           		
164:           		Button_2_Task();			    // obsluha tlacitka (reset TR modulu)
098C  DAF6     RCALL Button_2_Task
165:           	}
166:           	
167:           	if (tick - T100ms_tick >= 100)		// zde kazdych 100ms
098E  0E8A     MOVLW 0x8A
0990  6EE9     MOVWF FSR0L, ACCESS
0992  0E03     MOVLW 0x3
0994  ECD9     CALL 0x15B2, 0
0996  F00A     NOP
0998  0E64     MOVLW 0x64
099A  EC1A     CALL 0x1634, 0
099C  F00B     NOP
099E  E33B     BNC 0xA16
168:           	{
169:           		T100ms_tick = tick;				// reset tick counter
09A0  C382     MOVFF tick, T100ms_tick
09A2  F38A     NOP
09A4  C383     MOVFF 0x383, 0x38B
09A6  F38B     NOP
09A8  C384     MOVFF 0x384, 0x38C
09AA  F38C     NOP
09AC  C385     MOVFF 0x385, 0x38D
09AE  F38D     NOP
170:           
171:           		if (flag.LED_Flashing)			// LED indikace z IDE
09B0  A19D     BTFSS 0x9D, 0, BANKED
09B2  D00A     BRA 0x9C8
172:           		{
173:           			LED1_IO ^= 1;			
09B4  708B     BTG LATC, 0, ACCESS
174:           			++countLED1;
09B6  0102     MOVLB 0x2
09B8  2B01     INCF p, F, BANKED
175:           			
176:           			if (countLED1 > 6)         // po 600ms
09BA  5101     MOVF p, W, BANKED
09BC  0806     SUBLW 0x6
09BE  E204     BC 0x9C8
177:           			{
178:           				countLED1 = 0;
09C0  6B01     CLRF p, BANKED
179:           				flag.LED_Flashing = FALSE;
09C2  0103     MOVLB 0x3
09C4  919D     BCF 0x9D, 0, BANKED
180:           				LED1_IO = 0;
09C6  908B     BCF LATC, 0, ACCESS
181:           			}
182:           		}
183:           		
184:           		if (flag.SS_pin)			    // low puls na SS pinu
09C8  0103     MOVLB 0x3
09CA  AD9D     BTFSS 0x9D, 6, BANKED
09CC  D00C     BRA 0x9E6
185:           		{
186:           			CS_TR_IO = 0;
09CE  968A     BCF LATB, 3, ACCESS
187:           			LED1_IO = 1;			
09D0  808B     BSF LATC, 0, ACCESS
188:           			++countSSpin;
09D2  0102     MOVLB 0x2
09D4  2B03     INCF temp, F, BANKED
189:           			
190:           			if (countSSpin > 8)        // 800ms
09D6  5103     MOVF temp, W, BANKED
09D8  0808     SUBLW 0x8
09DA  E205     BC 0x9E6
191:           			{
192:           				countSSpin = 0;
09DC  6B03     CLRF temp, BANKED
193:           				flag.SS_pin = FALSE;
09DE  0103     MOVLB 0x3
09E0  9D9D     BCF 0x9D, 6, BANKED
194:           				CS_TR_IO = 1;
09E2  868A     BSF LATB, 3, ACCESS
195:           				LED1_IO = 0;
09E4  908B     BCF LATC, 0, ACCESS
196:           			}
197:           		}
198:           		
199:           		if (flag.CDC_mode && BTN1_IO && (!flag.LED_Flashing))   
09E6  0103     MOVLB 0x3
09E8  519D     MOVF 0x9D, W, BANKED
09EA  0B04     ANDLW 0x4
09EC  E00D     BZ 0xA08
09EE  5081     MOVF PORTB, W, ACCESS
09F0  0B10     ANDLW 0x10
09F2  E00A     BZ 0xA08
09F4  519D     MOVF 0x9D, W, BANKED
09F6  0B01     ANDLW 0x1
09F8  E107     BNZ 0xA08
200:           		{                               // LED indikace CDC rezimu (pri nestisknutem tl. a pokud neprobiha zablikani na CMD)
201:               	    ++countLED1;
09FA  0102     MOVLB 0x2
09FC  2B01     INCF p, F, BANKED
202:               	    
203:               	    if (countLED1 > 6)          // po 600ms
09FE  5101     MOVF p, W, BANKED
0A00  0806     SUBLW 0x6
0A02  E202     BC 0xA08
204:           			{ 
205:               		    countLED1 = 0;
0A04  6B01     CLRF p, BANKED
206:               		    LED1_IO ^= 1;	
0A06  708B     BTG LATC, 0, ACCESS
207:                       } 
208:                   } 
209:                   
210:                   if (flag.GW_Reset)
0A08  0103     MOVLB 0x3
0A0A  A19E     BTFSS 0x9E, 0, BANKED
0A0C  D004     BRA 0xA16
211:           		{
212:               	    GW_Reset_Timer--;			// odecita sekundy do GW resetu
0A0E  079C     DECF 0x9C, F, BANKED
213:               	    
214:               	    if (!GW_Reset_Timer) GW_Reset();
0A10  519C     MOVF 0x9C, W, BANKED
0A12  E101     BNZ 0xA16
0A14  DB31     RCALL GW_Reset
215:               	}     		
216:           	}
217:           		
218:               TR_ModuleControl();
0A16  DACF     RCALL TR_ModuleControl
219:               
220:               if ((USBDeviceState < CONFIGURED_STATE) || (USBSuspendControl == 1))
0A18  0E20     MOVLW 0x20
0A1A  0104     MOVLB 0x4
0A1C  5D30     SUBWF 0x30, W, BANKED
0A1E  E30D     BNC 0xA3A
0A20  5065     MOVF UCON, W, ACCESS
0A22  0B02     ANDLW 0x2
0A24  E001     BZ 0xA28
221:               	return;
0A26  0012     RETURN 0
222:               
223:               if (flag.CDC_mode)
0A28  0103     MOVLB 0x3
0A2A  A59D     BTFSS 0x9D, 2, BANKED
0A2C  D005     BRA 0xA38
224:               {
225:                   ServiceRequests_CDC();
0A2E  D8AC     RCALL ServiceRequests_CDC
226:                   IQRF_SPI_Task();			    // SPI_TR module handle
0A30  EC15     CALL 0x282A, 0
0A32  F014     NOP
227:                   IQRF_Message_Task();            // zpracuje event. hlaseni od IQRF_SPI_Task()
0A34  EF33     GOTO 0xE66
0A36  F007     NOP
228:               }
229:               else
230:                   ServiceRequests(); 
0A38  D801     RCALL ServiceRequests
231:            } 
0A3A  0012     RETURN 0
232:           //---------------------------------------------------------------------------
233:           
234:           void ServiceRequests(void)
235:           {
236:               if (!USBHandleBusy(USBGenericOutHandle))
0A3C  0100     MOVLB 0x0
0A3E  51F6     MOVF USBGenericOutHandle, W, BANKED
0A40  11F7     IORWF 0xF7, W, BANKED
0A42  E102     BNZ 0xA48
0A44  0E00     MOVLW 0x0
0A46  D008     BRA 0xA58
0A48  C0F6     MOVFF USBGenericOutHandle, FSR0L
0A4A  FFE9     NOP
0A4C  C0F7     MOVFF 0xF7, FSR0H
0A4E  FFEA     NOP
0A50  50EF     MOVF INDF0, W, ACCESS
0A52  0B80     ANDLW 0x80
0A54  E001     BZ 0xA58
0A56  0E01     MOVLW 0x1
0A58  0900     IORLW 0x0
0A5A  E001     BZ 0xA5E
0A5C  D094     BRA 0xB86
237:               {        
238:                   counter = 0;
0A5E  0103     MOVLB 0x3
0A60  6B81     CLRF 0x81, BANKED
239:              
240:                   INPacket.CMD = OUTPacket.CMD;
0A62  C340     MOVFF OUTPacket, INPacket
0A64  F300     NOP
241:                   INPacket.len = OUTPacket.len;
0A66  C341     MOVFF 0x341, 0x301
0A68  F301     NOP
242:                   
243:            		switch (OUTPacket.CMD)
0A6A  0103     MOVLB 0x3
0A6C  5140     MOVF 0x40, W, BANKED
0A6E  0AFA     XORLW 0xFA
0A70  E054     BZ 0xB1A
0A72  0AF8     XORLW 0xF8
0A74  E03F     BZ 0xAF4
0A76  0AFA     XORLW 0xFA
0A78  E031     BZ 0xADC
0A7A  0AE8     XORLW 0xE8
0A7C  E02C     BZ 0xAD6
0A7E  0AEB     XORLW 0xEB
0A80  E027     BZ 0xAD0
0A82  0A05     XORLW 0x5
0A84  E020     BZ 0xAC6
0A86  0A03     XORLW 0x3
0A88  E01B     BZ 0xAC0
0A8A  0AFA     XORLW 0xFA
0A8C  E014     BZ 0xAB6
0A8E  0AF7     XORLW 0xF7
0A90  E00C     BZ 0xAAA
0A92  0AF1     XORLW 0xF1
0A94  E143     BNZ 0xB1C
244:                   {
245:           			case CK_CMD_TXRX_DATA:				// data pro TR modul
246:           				if (TR_state)					// pokud nelze posilat data do TR modulu
0A96  0103     MOVLB 0x3
0A98  5180     MOVF 0x80, W, BANKED
0A9A  E12F     BNZ 0xAFA
247:           				{
248:           					SPI_BusyPacket();
249:           					goto SPI_isBusy;
250:           				}
251:           				
252:           				numBytesRead = USBHandleGetLength(USBGenericOutHandle) - 1;	 	
0A9C  EC25     CALL 0x164A, 0
0A9E  F00B     NOP
0AA0  6F9B     MOVWF 0x9B, BANKED
164A  C0F6     MOVFF USBGenericOutHandle, FSR0L
164C  FFE9     NOP
164E  C0F7     MOVFF 0xF7, FSR0H
1650  FFEA     NOP
1652  52EE     MOVF POSTINC0, F, ACCESS
1654  04EF     DECF INDF0, W, ACCESS
1656  0012     RETURN 0
253:           				service_SPI_data();
0AA2  DAFA     RCALL service_SPI_data
254:           				counter = numBytesRead; 
0AA4  C39B     MOVFF numBytesRead, counter
0AA6  F381     NOP
255:           				break;
0AA8  D039     BRA 0xB1C
256:           		//---------------------------
257:                       case CK_CMD_READ_VERSION:			// Read Version of GW
258:                           INPacket._byte[1] = MAJOR_VERSION; 
0AAA  6B01     CLRF p, BANKED
259:                           INPacket._byte[2] = MINOR_VERSION;  
0AAC  0E01     MOVLW 0x1
0AAE  6F02     MOVWF pUEP, BANKED
260:                           counter = 3;
0AB0  0103     MOVLB 0x3
0AB2  0E03     MOVLW 0x3
261:                           break;
0AB4  D01D     BRA 0xAF0
262:           		//-----------------------------
263:           	   		case CK_CMD_UPLOAD_SERVICE:
264:           	   			if (TR_state)					// pokud nelze posilat data do TR modulu
0AB6  0103     MOVLB 0x3
0AB8  5180     MOVF 0x80, W, BANKED
0ABA  E11F     BNZ 0xAFA
265:           				{
266:           					SPI_BusyPacket();
267:           					goto SPI_isBusy;
268:           				}
269:           				
270:           				service_UPLOAD_mode();
0ABC  DB79     RCALL service_UPLOAD_mode
271:           				break;
0ABE  D02E     BRA 0xB1C
272:           		//---------------------------
273:           			case CK_CMD_RAM_WRITE: 				// IDE obsadi CKcko
274:           				CK_Reserved = OUTPacket._byte[1];
0AC0  C341     MOVFF 0x341, CK_Reserved
0AC2  F200     NOP
275:           				break;
0AC4  D02B     BRA 0xB1C
276:           		//---------------------------
277:           			case CK_CMD_RAM_READ: 				// pro zjisteni obsazenosti CKcka
278:           				INPacket._byte[0] = CK_Reserved;
0AC6  C200     MOVFF CK_Reserved, INPacket
0AC8  F300     NOP
279:           				counter = 1;
0ACA  0103     MOVLB 0x3
0ACC  0E01     MOVLW 0x1
280:           				break;
0ACE  D010     BRA 0xAF0
281:           		//---------------------------
282:           			case CK_CMD_BLINK:					// indikace - dobre pri vice instancich
283:            				flag.LED_Flashing = TRUE;
0AD0  0103     MOVLB 0x3
0AD2  819D     BSF 0x9D, 0, BANKED
284:           				break;
0AD4  D023     BRA 0xB1C
285:           		//---------------------------
286:           			case CK_CMD_SS_PIN_PULSE:			// stahne pin SS do nuly
287:            				flag.SS_pin = TRUE;
0AD6  0103     MOVLB 0x3
0AD8  8D9D     BSF 0x9D, 6, BANKED
288:           				break;
0ADA  D020     BRA 0xB1C
289:           		//---------------------------
290:           			case CK_CMD_READ_ID:            // Read ID of GW
291:           				INPacket._byte[1] = DEVICE_ID;
0ADC  0E0E     MOVLW 0xE
0ADE  6F01     MOVWF p, BANKED
292:           				INPacket._byte[2] = ID1;
0AE0  C398     MOVFF ID1, 0x302
0AE2  F302     NOP
293:           				INPacket._byte[3] = ID2;
0AE4  C399     MOVFF ID2, 0x303
0AE6  F303     NOP
294:           				INPacket._byte[4] = ID3;
0AE8  C39A     MOVFF ID3, 0x304
0AEA  F304     NOP
295:           				counter = 5;
0AEC  0103     MOVLB 0x3
0AEE  0E05     MOVLW 0x5
0AF0  6F81     MOVWF 0x81, BANKED
296:           				break;
0AF2  D014     BRA 0xB1C
297:           		//--------------------------- 
298:           			case CK_CMD_PROG_REQUEST:
299:           				if (TR_state)										// pokud nelze posilat data do TR modulu
0AF4  0103     MOVLB 0x3
0AF6  5180     MOVF 0x80, W, BANKED
0AF8  E002     BZ 0xAFE
300:           				{
301:           					SPI_BusyPacket();
0AFA  DA17     RCALL SPI_BusyPacket
302:           					goto SPI_isBusy;
0AFC  D00F     BRA 0xB1C
303:           				}
304:           				
305:                 	   	   	if (OUTPacket._byte[1] == CK_CMD_ENTER_PROG_MODE) 			// Enter Prog. Mode
0AFE  0EE6     MOVLW 0xE6
0B00  0103     MOVLB 0x3
0B02  5D41     SUBWF tmp, W, BANKED
0B04  E103     BNZ 0xB0C
306:                     		{	
307:           					flag.EnterProgMode = TRUE;
0B06  0103     MOVLB 0x3
0B08  839D     BSF 0x9D, 1, BANKED
308:           					TR_state = TR_RESET;
309:            				}	
310:           				else if (OUTPacket._byte[1] == CK_CMD_RESET_TR_MODULE) 	// Reset TR module
0B0A  D004     BRA 0xB14
0B0C  0E8B     MOVLW 0x8B
0B0E  5D41     SUBWF tmp, W, BANKED
0B10  E105     BNZ 0xB1C
311:           	         	{   
312:            		 			TR_state = TR_RESET;
0B12  0103     MOVLB 0x3
0B14  0E01     MOVLW 0x1
0B16  6F80     MOVWF 0x80, BANKED
313:           				}
314:           				break;
0B18  D001     BRA 0xB1C
315:           		//---------------------------	
316:           			case CK_CMD_REQ_BOOT_MODE:								// pozadavek boot modu
317:           			 	set_boot_mode();
0B1A  DB1E     RCALL set_boot_mode
318:           			  	break;
319:           		//---------------------------
320:           			default:
321:                           break;
322:                   } 
323:           
324:           SPI_isBusy:        
325:                   if (counter != 0)
0B1C  0103     MOVLB 0x3
0B1E  5181     MOVF 0x81, W, BANKED
0B20  E023     BZ 0xB68
326:                   { 
327:                       if (!USBHandleBusy(USBGenericInHandle))
0B22  0100     MOVLB 0x0
0B24  51F8     MOVF USBGenericInHandle, W, BANKED
0B26  11F9     IORWF 0xF9, W, BANKED
0B28  E102     BNZ 0xB2E
0B2A  0E00     MOVLW 0x0
0B2C  D008     BRA 0xB3E
0B2E  C0F8     MOVFF USBGenericInHandle, FSR0L
0B30  FFE9     NOP
0B32  C0F9     MOVFF 0xF9, FSR0H
0B34  FFEA     NOP
0B36  50EF     MOVF INDF0, W, ACCESS
0B38  0B80     ANDLW 0x80
0B3A  E001     BZ 0xB3E
0B3C  0E01     MOVLW 0x1
0B3E  0900     IORLW 0x0
0B40  E113     BNZ 0xB68
328:                       {
329:                           USBGenericInHandle = USBGenWrite(1, (BYTE*)&INPacket, counter);
0B42  C381     MOVFF counter, POSTINC1
0B44  FFE6     NOP
0B46  0E00     MOVLW 0x0
0B48  6EE6     MOVWF POSTINC1, ACCESS
0B4A  0E03     MOVLW 0x3
0B4C  6EE6     MOVWF POSTINC1, ACCESS
0B4E  0E01     MOVLW 0x1
0B50  6EE6     MOVWF POSTINC1, ACCESS
0B52  EC2C     CALL 0x1658, 0
0B54  F00B     NOP
0B56  E202     BC 0xB5C
0B58  6AE1     CLRF FSR1L, ACCESS
0B5A  52E5     MOVF POSTDEC1, F, ACCESS
0B5C  6EE1     MOVWF FSR1L, ACCESS
0B5E  5014     MOVF __tmp_0, W, ACCESS
0B60  CFF3     MOVFF PRODL, USBGenericInHandle
0B62  F0F8     NOP
0B64  CFF4     MOVFF PRODH, 0xF9
0B66  F0F9     NOP
1658  6EE6     MOVWF POSTINC1, ACCESS
165A  EC64     CALL 0x24C8, 0
165C  F012     NOP
165E  6E14     MOVWF __tmp_0, ACCESS
1660  0E05     MOVLW 0x5
1662  5CE1     SUBWF FSR1L, W, ACCESS
1664  0012     RETURN 0
330:                       }						 
331:                   }   
332:                   //Re-arm the OUT endpoint for the next packet       
333:                   USBGenericOutHandle = USBGenRead(USBGEN_EP_NUM, (BYTE*)&OUTPacket, USBGEN_EP_SIZE);	 
0B68  EC33     CALL 0x1666, 0
0B6A  F00B     NOP
0B6C  6AE6     CLRF POSTINC1, ACCESS
0B6E  0E01     MOVLW 0x1
0B70  EC2C     CALL 0x1658, 0
0B72  F00B     NOP
0B74  E202     BC 0xB7A
0B76  6AE1     CLRF FSR1L, ACCESS
0B78  52E5     MOVF POSTDEC1, F, ACCESS
0B7A  6EE1     MOVWF FSR1L, ACCESS
0B7C  5014     MOVF __tmp_0, W, ACCESS
0B7E  CFF3     MOVFF PRODL, USBGenericOutHandle
0B80  F0F6     NOP
0B82  CFF4     MOVFF PRODH, 0xF7
0B84  F0F7     NOP
1666  0E40     MOVLW 0x40
1668  6EE6     MOVWF POSTINC1, ACCESS
166A  0E40     MOVLW 0x40
166C  6EE6     MOVWF POSTINC1, ACCESS
166E  0E03     MOVLW 0x3
1670  6EE6     MOVWF POSTINC1, ACCESS
1672  0012     RETURN 0
334:               } 
335:           }	//end ServiceRequests
0B86  0012     RETURN 0
336:           //---------------------------------------------------------------------------
337:           
338:           void ServiceRequests_CDC(void)      // USB CDC services
339:           {  
340:               if (mUSBUSARTIsTxTrfReady())
0B88  010E     MOVLB 0xE
0B8A  5190     MOVF 0x90, W, BANKED
0B8C  E001     BZ 0xB90
0B8E  D15D     BRA 0xE4A
341:               {
342:           		numBytesRead = getsUSBUSART((char*)OUTPacket._byte, 64);
0B90  EC33     CALL 0x1666, 0
0B92  F00B     NOP
0B94  ECD3     CALL 0x17A6, 0
0B96  F00B     NOP
0B98  52E5     MOVF POSTDEC1, F, ACCESS
0B9A  52E5     MOVF POSTDEC1, F, ACCESS
0B9C  52E5     MOVF POSTDEC1, F, ACCESS
0B9E  0103     MOVLB 0x3
0BA0  6F9B     MOVWF 0x9B, BANKED
343:           		
344:           		if ((numBytesRead != 0) && (OUTPacket._byte[numBytesRead - 1] == '\n')) // akceptuje CR LF
0BA2  50E8     MOVF WREG, W, ACCESS
0BA4  E005     BZ 0xBB0
0BA6  EC22     CALL 0x1644, 0
0BA8  F00B     NOP
0BAA  080A     SUBLW 0xA
0BAC  E101     BNZ 0xBB0
1644  059B     DECF 0x9B, W, BANKED
1646  EF50     GOTO 0x16A0
1648  F00B     NOP
345:           		    --numBytesRead;    
0BAE  079B     DECF 0x9B, F, BANKED
346:           		
347:           		if ((numBytesRead != 0) && (OUTPacket._byte[0] == '>') && (OUTPacket._byte[numBytesRead - 1] == '\r'))
0BB0  519B     MOVF 0x9B, W, BANKED
0BB2  E101     BNZ 0xBB6
0BB4  D14A     BRA 0xE4A
0BB6  0E3E     MOVLW 0x3E
0BB8  0103     MOVLB 0x3
0BBA  5D40     SUBWF 0x40, W, BANKED
0BBC  E001     BZ 0xBC0
0BBE  D145     BRA 0xE4A
0BC0  0103     MOVLB 0x3
0BC2  EC22     CALL 0x1644, 0
0BC4  F00B     NOP
0BC6  080D     SUBLW 0xD
0BC8  E001     BZ 0xBCC
0BCA  D13F     BRA 0xE4A
348:           		{
349:           			switch(OUTPacket._byte[1])
0BCC  0103     MOVLB 0x3
0BCE  5141     MOVF tmp, W, BANKED
0BD0  0A42     XORLW 0x42
0BD2  E101     BNZ 0xBD6
0BD4  D121     BRA 0xE18
0BD6  0A06     XORLW 0x6
0BD8  E101     BNZ 0xBDC
0BDA  D0C8     BRA 0xD6C
0BDC  0A0D     XORLW 0xD
0BDE  E040     BZ 0xC60
0BE0  0A1A     XORLW 0x1A
0BE2  E02D     BZ 0xC3E
0BE4  0A01     XORLW 0x1
0BE6  E00F     BZ 0xC06
350:           			{ 
351:           				case 'R':			                    			          
352:           				    tmp_buf[0] = '<';
0C06  EC5B     CALL 0x16B6, 0
0C08  F00B     NOP
353:               			    tmp_buf[1] = 'R';
0C0A  0E52     MOVLW 0x52
0C0C  6FA0     MOVWF IQRF_SPI_RxBuf, BANKED
354:           				    
355:           				    if (OUTPacket._byte[2] == 'T')
0C0E  0E54     MOVLW 0x54
0C10  0103     MOVLB 0x3
0C12  5D42     SUBWF 0x42, W, BANKED
0C14  E10B     BNZ 0xC2C
356:           				    {                                   // ">RT"<CR> - Reset TR Module
357:               				    if (numBytesRead != 4)
0C16  0E04     MOVLW 0x4
0C18  0103     MOVLB 0x3
0C1A  5D9B     SUBWF 0x9B, W, BANKED
0C1C  E001     BZ 0xC20
0C1E  D112     BRA 0xE44
358:                                   {                               // nesedi pocet bajtu v CMD
359:                                       putUSB_AT_ERR();
360:                                       break;
361:                                   }       
362:           				    
363:               			        TR_state = TR_RESET;
0C20  0E01     MOVLW 0x1
0C22  6F80     MOVWF 0x80, BANKED
364:               			        tmp_buf[2] = 'T';
0C24  0E54     MOVLW 0x54
0C26  ECFF     CALL 0x15FE, 0
15FE  6FA1     MOVWF 0xA1, BANKED
365:               			        tmp_buf[3] = ':';
0C28  F00A     NOP
1600  0E3A     MOVLW 0x3A
1602  6FA2     MOVWF 0xA2, BANKED
366:               			        tmp_buf[4] = 'O';
1604  0E4F     MOVLW 0x4F
1606  6FA3     MOVWF 0xA3, BANKED
367:               			        tmp_buf[5] = 'K';
1608  0E4B     MOVLW 0x4B
160A  6FA4     MOVWF 0xA4, BANKED
368:               			        tmp_buf[6] = '\r';
160C  0E0D     MOVLW 0xD
160E  6FA5     MOVWF 0xA5, BANKED
369:               			        putUSBUSART((char *)tmp_buf, 7);    // "<RT:OK"<CR>
1610  0E07     MOVLW 0x7
1612  0012     RETURN 0
370:               			    }
371:               			    else
0C2A  D10A     BRA 0xE40
372:               			    {                                   // ">R"<CR> - Reset GW
373:                   			    if (numBytesRead != 3)
0C2C  0E03     MOVLW 0x3
0C2E  0103     MOVLB 0x3
0C30  5D9B     SUBWF 0x9B, W, BANKED
0C32  E001     BZ 0xC36
0C34  D107     BRA 0xE44
374:                                   {                               // nesedi pocet bajtu v CMD
375:                                       putUSB_AT_ERR();
376:                                       break;
377:                                   }   
378:                   			    
379:                   			    flag.GW_Reset = TRUE;
0C36  819E     BSF 0x9E, 0, BANKED
380:                   			    GW_Reset_Timer = GW_RESET_TIME_DEF;
0C38  0E32     MOVLW 0x32
0C3A  6F9C     MOVWF 0x9C, BANKED
381:               			        tmp_buf[2] = ':';
382:               			        tmp_buf[3] = 'O';
383:               			        tmp_buf[4] = 'K';
384:               			        tmp_buf[5] = '\r';
385:               			        putUSBUSART((char *)tmp_buf, 6);    // "<R:OK"<CR>
386:                   			}
387:           			        break;
0C3C  D0F8     BRA 0xE2E
388:           	        //---------------------------
389:           	            case 'S':						        // ">S"<CR> - Get Status  
390:           	                
391:           	                if (numBytesRead != 3)
0C3E  0E03     MOVLW 0x3
0C40  0103     MOVLB 0x3
0C42  5D9B     SUBWF 0x9B, W, BANKED
0C44  E001     BZ 0xC48
0C46  D0FE     BRA 0xE44
392:                               {                                   // nesedi pocet bajtu v CMD
393:                                   putUSB_AT_ERR();
394:                                   break;
395:                               }
396:           	            
397:           				    tmp_buf[0] = '<';
0C48  0E3C     MOVLW 0x3C
0C4A  6F9F     MOVWF 0x9F, BANKED
398:           			        tmp_buf[1] = 'S';
0C4C  0E53     MOVLW 0x53
0C4E  6FA0     MOVWF IQRF_SPI_RxBuf, BANKED
399:           			        tmp_buf[2] = ':';
0C50  0E3A     MOVLW 0x3A
0C52  6FA1     MOVWF 0xA1, BANKED
400:           			        tmp_buf[3] = iq_spistat;
0C54  C0E3     MOVFF iq_spistat, 0x3A2
0C56  F3A2     NOP
401:           			        tmp_buf[4] = '\r';
0C58  0E0D     MOVLW 0xD
0C5A  6FA3     MOVWF 0xA3, BANKED
402:           			        putUSBUSART((char *)tmp_buf, 5);    // "<S:"<spi_status><CR>
0C5C  0E05     MOVLW 0x5
403:           			        break;
0C5E  D0F0     BRA 0xE40
404:           	        //---------------------------
405:           				case 'I': 						         
406:           				    tmp_buf[0]  = '<';
0C60  EC5B     CALL 0x16B6, 0
0C62  F00B     NOP
407:               			    tmp_buf[1]  = 'I';
0C64  0E49     MOVLW 0x49
0C66  6FA0     MOVWF IQRF_SPI_RxBuf, BANKED
408:           				    
409:           				    
410:           				    if (OUTPacket._byte[2] == 'T')
0C68  0E54     MOVLW 0x54
0C6A  0103     MOVLB 0x3
0C6C  5D42     SUBWF 0x42, W, BANKED
0C6E  E11E     BNZ 0xCAC
411:           				    {                                   // ">IT"<CR> - Get TR Module Info 
412:               				    if (numBytesRead != 4)
0C70  0E04     MOVLW 0x4
0C72  0103     MOVLB 0x3
0C74  5D9B     SUBWF 0x9B, W, BANKED
0C76  E001     BZ 0xC7A
0C78  D0E5     BRA 0xE44
413:                                   {                               // nesedi pocet bajtu v CMD
414:                                       putUSB_AT_ERR();
415:                                       break;
416:                                   }   
417:               				    
418:               			        tmp_buf[2]  = 'T';
0C7A  0E54     MOVLW 0x54
0C7C  6FA1     MOVWF 0xA1, BANKED
419:               			        tmp_buf[3]  = ':';
0C7E  0E3A     MOVLW 0x3A
0C80  6FA2     MOVWF 0xA2, BANKED
420:               			        memcpy(tmp_buf + 4, (void *)TR_InfoBuf, 8);
0C82  0E08     MOVLW 0x8
0C84  6EE6     MOVWF POSTINC1, ACCESS
0C86  6AE6     CLRF POSTINC1, ACCESS
0C88  0EDF     MOVLW 0xDF
0C8A  6EE6     MOVWF POSTINC1, ACCESS
0C8C  0E03     MOVLW 0x3
0C8E  6EE6     MOVWF POSTINC1, ACCESS
0C90  0EA3     MOVLW 0xA3
0C92  6EE6     MOVWF POSTINC1, ACCESS
0C94  0E03     MOVLW 0x3
0C96  ECDE     CALL 0x15BC, 0
0C98  F00A     NOP
0C9A  E202     BC 0xCA0
0C9C  6AE1     CLRF FSR1L, ACCESS
0C9E  52E5     MOVF POSTDEC1, F, ACCESS
0CA0  6EE1     MOVWF FSR1L, ACCESS
0CA2  5014     MOVF __tmp_0, W, ACCESS
421:               			        tmp_buf[12] = '\r';
0CA4  0103     MOVLB 0x3
0CA6  0E0D     MOVLW 0xD
0CA8  6FAB     MOVWF 0xAB, BANKED
422:               			        putUSBUSART((char *)tmp_buf, 13);   // "<IT:"<module_info><CR>
423:               				}
424:               				else
0CAA  D0CA     BRA 0xE40
425:               				{                                   // ">I"<CR> - Get USB Device Info
426:               				    if (numBytesRead != 3)
0CAC  0E03     MOVLW 0x3
0CAE  0103     MOVLB 0x3
0CB0  5D9B     SUBWF 0x9B, W, BANKED
0CB2  E001     BZ 0xCB6
0CB4  D0C7     BRA 0xE44
427:                                   {                               // nesedi pocet bajtu v CMD
428:                                       putUSB_AT_ERR();
429:                                       break;
430:                                   }
431:               				
432:                			        tmp_buf[2]  = ':';
0CB6  0E3A     MOVLW 0x3A
0CB8  6FA1     MOVWF 0xA1, BANKED
433:               			        tmp_buf[3]  = 'C';
0CBA  0E43     MOVLW 0x43
0CBC  6FA2     MOVWF 0xA2, BANKED
434:               			        tmp_buf[4]  = 'K';
0CBE  0E4B     MOVLW 0x4B
0CC0  6FA3     MOVWF 0xA3, BANKED
435:               			        tmp_buf[5]  = '-';
0CC2  0E2D     MOVLW 0x2D
0CC4  6FA4     MOVWF 0xA4, BANKED
436:               			        tmp_buf[6]  = 'U';
0CC6  0E55     MOVLW 0x55
0CC8  6FA5     MOVWF 0xA5, BANKED
437:               			        tmp_buf[7]  = 'S';
0CCA  0E53     MOVLW 0x53
0CCC  6FA6     MOVWF 0xA6, BANKED
438:               			        tmp_buf[8]  = 'B';
0CCE  0E42     MOVLW 0x42
0CD0  6FA7     MOVWF 0xA7, BANKED
439:               			        tmp_buf[9] = '-';
0CD2  0E2D     MOVLW 0x2D
0CD4  6FA8     MOVWF 0xA8, BANKED
440:               			        tmp_buf[10] = '0';
0CD6  0E30     MOVLW 0x30
0CD8  6FA9     MOVWF 0xA9, BANKED
441:               			        tmp_buf[11] = '4';
0CDA  0E34     MOVLW 0x34
0CDC  6FAA     MOVWF 0xAA, BANKED
442:                                           tmp_buf[12] = 'A';
0CDE  0E41     MOVLW 0x41
0CE0  6FAB     MOVWF 0xAB, BANKED
443:               			        tmp_buf[13] = '#';
0CE2  0E23     MOVLW 0x23
0CE4  6FAC     MOVWF 0xAC, BANKED
444:               			        tmp_buf[14] = ByteToHex(MAJOR_VERSION / 16);
0CE6  EC16     CALL 0x162C, 0
0CE8  F00B     NOP
0CEA  0103     MOVLB 0x3
0CEC  6FAD     MOVWF 0xAD, BANKED
445:               			        tmp_buf[15] = ByteToHex(MAJOR_VERSION % 16);
0CEE  EC16     CALL 0x162C, 0
0CF0  F00B     NOP
0CF2  0103     MOVLB 0x3
0CF4  6FAE     MOVWF 0xAE, BANKED
446:               			        tmp_buf[16] = '.';
0CF6  0E2E     MOVLW 0x2E
0CF8  6FAF     MOVWF 0xAF, BANKED
447:               			        tmp_buf[17] = ByteToHex(MINOR_VERSION / 16);
0CFA  EC16     CALL 0x162C, 0
0CFC  F00B     NOP
0CFE  0103     MOVLB 0x3
0D00  6FB0     MOVWF 0xB0, BANKED
448:               			        tmp_buf[18] = ByteToHex(MINOR_VERSION % 16);
0D02  0E01     MOVLW 0x1
0D04  ECD5     CALL 0x15AA, 0
0D06  F00A     NOP
0D08  0103     MOVLB 0x3
0D0A  6FB1     MOVWF 0xB1, BANKED
449:               			        tmp_buf[19] = '#';
0D0C  0E23     MOVLW 0x23
0D0E  6FB2     MOVWF 0xB2, BANKED
450:               			        tmp_buf[20] = ByteToHex(DEVICE_ID / 16);
0D10  EC16     CALL 0x162C, 0
0D12  F00B     NOP
0D14  0103     MOVLB 0x3
0D16  6FB3     MOVWF 0xB3, BANKED
162C  6AE6     CLRF POSTINC1, ACCESS
162E  DF36     RCALL ByteToHex
1630  52E5     MOVF POSTDEC1, F, ACCESS
1632  0012     RETURN 0
451:                                           tmp_buf[21] = ByteToHex(DEVICE_ID % 16);
0D18  0E0E     MOVLW 0xE
0D1A  ECD5     CALL 0x15AA, 0
0D1C  F00A     NOP
0D1E  0103     MOVLB 0x3
0D20  6FB4     MOVWF 0xB4, BANKED
452:                                           tmp_buf[22] = ByteToHex(ID1 / 16);
0D22  5198     MOVF 0x98, W, BANKED
0D24  EC57     CALL 0x16AE, 0
0D26  F00B     NOP
0D28  0103     MOVLB 0x3
0D2A  6FB5     MOVWF 0xB5, BANKED
453:                                           tmp_buf[23] = ByteToHex(ID1 % 16);
0D2C  5198     MOVF 0x98, W, BANKED
0D2E  0B0F     ANDLW 0xF
0D30  ECD5     CALL 0x15AA, 0
0D32  F00A     NOP
0D34  0103     MOVLB 0x3
0D36  6FB6     MOVWF 0xB6, BANKED
454:                                           tmp_buf[24] = ByteToHex(ID2 / 16);
0D38  5199     MOVF 0x99, W, BANKED
0D3A  EC57     CALL 0x16AE, 0
0D3C  F00B     NOP
0D3E  0103     MOVLB 0x3
0D40  6FB7     MOVWF 0xB7, BANKED
455:                                           tmp_buf[25] = ByteToHex(ID2 % 16);
0D42  5199     MOVF 0x99, W, BANKED
0D44  0B0F     ANDLW 0xF
0D46  ECD5     CALL 0x15AA, 0
0D48  F00A     NOP
0D4A  0103     MOVLB 0x3
0D4C  6FB8     MOVWF 0xB8, BANKED
456:                                           tmp_buf[26] = ByteToHex(ID3 / 16); 
0D4E  519A     MOVF 0x9A, W, BANKED
0D50  EC57     CALL 0x16AE, 0
0D52  F00B     NOP
0D54  0103     MOVLB 0x3
0D56  6FB9     MOVWF 0xB9, BANKED
16AE  0BF0     ANDLW 0xF0
16B0  3AE8     SWAPF WREG, F, ACCESS
16B2  EFD5     GOTO 0x15AA
16B4  F00A     NOP
457:                                           tmp_buf[27] = ByteToHex(ID3 % 16);
0D58  519A     MOVF 0x9A, W, BANKED
0D5A  0B0F     ANDLW 0xF
0D5C  ECD5     CALL 0x15AA, 0
0D5E  F00A     NOP
0D60  0103     MOVLB 0x3
0D62  6FBA     MOVWF 0xBA, BANKED
15AA  6EE6     MOVWF POSTINC1, ACCESS
15AC  DF77     RCALL ByteToHex
15AE  52E5     MOVF POSTDEC1, F, ACCESS
15B0  0012     RETURN 0
458:                   		        tmp_buf[28] = '\r';
0D64  0E0D     MOVLW 0xD
0D66  6FBB     MOVWF 0xBB, BANKED
459:               			        putUSBUSART((char *)tmp_buf, 29);   // "<I:"<type>"#"<version>"#"<id><CR>
0D68  0E1D     MOVLW 0x1D
460:           			        }
461:                               break;
0D6A  D06A     BRA 0xE40
462:           			//---------------------------   
463:                           case 'D':                               // ">DS"<dlen>":"<data><CR>
464:                           
465:                               if ((numBytesRead < 6) || (OUTPacket._byte[3] == 0) || (OUTPacket._byte[3] > BUF_COM_MAX))
0D6C  0E06     MOVLW 0x6
0D6E  0103     MOVLB 0x3
0D70  5D9B     SUBWF 0x9B, W, BANKED
0D72  E368     BNC 0xE44
0D74  0103     MOVLB 0x3
0D76  5143     MOVF 0x43, W, BANKED
0D78  E065     BZ 0xE44
0D7A  5143     MOVF 0x43, W, BANKED
0D7C  0840     SUBLW 0x40
0D7E  E362     BNC 0xE44
466:                               {                                   // <dlen> musi byt v rozsahu 1 - 41
467:                                   putUSB_AT_ERR();
468:                                   break;
469:                               }
470:                               
471:                               if ((numBytesRead - 6) != OUTPacket._byte[3])
0D80  0E06     MOVLW 0x6
0D82  0103     MOVLB 0x3
0D84  5D9B     SUBWF 0x9B, W, BANKED
0D86  0103     MOVLB 0x3
0D88  5D43     SUBWF 0x43, W, BANKED
0D8A  E15C     BNZ 0xE44
472:                               {                                   // nesedi pocet bajtu v <data> a <dlen>
473:                                   putUSB_AT_ERR();
474:                                   break;
475:                               }
476:                               
477:                               if ((OUTPacket._byte[2] != 'S') || (OUTPacket._byte[4] != ':'))
0D8C  0E53     MOVLW 0x53
0D8E  5D42     SUBWF 0x42, W, BANKED
0D90  E159     BNZ 0xE44
0D92  0E3A     MOVLW 0x3A
0D94  5D44     SUBWF 0x44, W, BANKED
0D96  E156     BNZ 0xE44
478:                               {
479:                                   putUSB_AT_ERR();
480:                                   break;
481:                               }
482:                           
483:                               if ((!IQRF_SPI_Busy) && (iq_spistat == TR_STAT_COM_MODE))
0D98  0100     MOVLB 0x0
0D9A  51E0     MOVF IQRF_SPI_Busy, W, BANKED
0D9C  E12B     BNZ 0xDF4
0D9E  0E80     MOVLW 0x80
0DA0  0100     MOVLB 0x0
0DA2  5DE3     SUBWF iq_spistat, W, BANKED
0DA4  E127     BNZ 0xDF4
484:                                                                   // only if the IQRF_SPI_Task() is not busy and the TR module is in 
485:                           	{									// Communication Mode => packet preparing
486:                            		Clear_IQRF_SPI_TxBuf();
0DA6  ECE5     CALL 0x15CA, 0
0DA8  F00A     NOP
0DAA  E202     BC 0xDB0
0DAC  6AE1     CLRF FSR1L, ACCESS
0DAE  52E5     MOVF POSTDEC1, F, ACCESS
0DB0  6EE1     MOVWF FSR1L, ACCESS
0DB2  5014     MOVF __tmp_0, W, ACCESS
15CA  0E40     MOVLW 0x40
15CC  6EE6     MOVWF POSTINC1, ACCESS
15CE  6AE6     CLRF POSTINC1, ACCESS
15D0  6AE6     CLRF POSTINC1, ACCESS
15D2  0E60     MOVLW 0x60
15D4  6EE6     MOVWF POSTINC1, ACCESS
15D6  0E00     MOVLW 0x0
15D8  6EE6     MOVWF POSTINC1, ACCESS
15DA  EC25     CALL 0x2C4A, 0
15DC  F016     NOP
15DE  6E14     MOVWF __tmp_0, ACCESS
15E0  0E05     MOVLW 0x5
15E2  5CE1     SUBWF FSR1L, W, ACCESS
15E4  0012     RETURN 0
487:                             		iq_DLEN = OUTPacket._byte[3]; 			
0DB4  C343     MOVFF 0x343, iq_DLEN
0DB6  F0E1     NOP
488:                           		iq_PTYPE = (iq_DLEN | 0x80); 	// PTYTE set bit7 - write to buffer COM of TR module 
0DB8  0E80     MOVLW 0x80
0DBA  0100     MOVLB 0x0
0DBC  11E1     IORWF iq_DLEN, W, BANKED
0DBE  0100     MOVLB 0x0
0DC0  6FE2     MOVWF iq_PTYPE, BANKED
489:                           		IQRF_SPI_TxBuf[0] = TR_CMD_WR_RD; 
0DC2  0100     MOVLB 0x0
0DC4  0EF0     MOVLW 0xF0
0DC6  6F60     MOVWF IQRF_SPI_TxBuf, BANKED
490:                           		IQRF_SPI_TxBuf[1] = iq_PTYPE;
0DC8  C0E2     MOVFF iq_PTYPE, 0x61
0DCA  F061     NOP
491:                            		memcpy(IQRF_SPI_TxBuf + 2, (void *)OUTPacket._byte + 5, iq_DLEN);
0DCC  0100     MOVLB 0x0
0DCE  51E1     MOVF iq_DLEN, W, BANKED
0DD0  6EE6     MOVWF POSTINC1, ACCESS
0DD2  6AE6     CLRF POSTINC1, ACCESS
0DD4  0E45     MOVLW 0x45
0DD6  6EE6     MOVWF POSTINC1, ACCESS
0DD8  0E03     MOVLW 0x3
0DDA  6EE6     MOVWF POSTINC1, ACCESS
0DDC  0E62     MOVLW 0x62
0DDE  6EE6     MOVWF POSTINC1, ACCESS
0DE0  0E00     MOVLW 0x0
0DE2  DBEC     RCALL __pa_8
0DE4  E202     BC 0xDEA
0DE6  6AE1     CLRF FSR1L, ACCESS
0DE8  52E5     MOVF POSTDEC1, F, ACCESS
0DEA  6EE1     MOVWF FSR1L, ACCESS
0DEC  5014     MOVF __tmp_0, W, ACCESS
492:                           		Start_IQRF_SPI();               // activates IQRF_SPI_Task to send packet
0DEE  EC09     CALL 0x2812, 0
0DF0  F014     NOP
493:                           	}
494:                           	else
0DF2  D029     BRA 0xE46
495:                           	{
496:                                   tmp_buf[0] = '<';
0DF4  EC12     CALL 0x1624, 0
0DF6  F00B     NOP
497:                			        tmp_buf[1] = 'D';
498:               			        tmp_buf[2] = 'S';
0DF8  0E53     MOVLW 0x53
0DFA  6FA1     MOVWF 0xA1, BANKED
499:               			        tmp_buf[3] = ':';
0DFC  0E3A     MOVLW 0x3A
0DFE  6FA2     MOVWF 0xA2, BANKED
500:               			        tmp_buf[4] = 'B';
0E00  0E42     MOVLW 0x42
0E02  6FA3     MOVWF 0xA3, BANKED
501:               			        tmp_buf[5] = 'U';
0E04  0E55     MOVLW 0x55
0E06  6FA4     MOVWF 0xA4, BANKED
502:               			        tmp_buf[6] = 'S';
0E08  0E53     MOVLW 0x53
0E0A  6FA5     MOVWF 0xA5, BANKED
503:               			        tmp_buf[7] = 'Y';
0E0C  0E59     MOVLW 0x59
0E0E  6FA6     MOVWF 0xA6, BANKED
504:               			        tmp_buf[8] = '\r';
0E10  0E0D     MOVLW 0xD
0E12  6FA7     MOVWF 0xA7, BANKED
505:               			        putUSBUSART((char *)tmp_buf, 9);    // "<DS:BUSY"<CR>
0E14  0E09     MOVLW 0x9
506:                               }
507:                               break;
0E16  D014     BRA 0xE40
508:                       //---------------------------
509:           		        case 'B':						        // ">B"<CR> - Beep  
510:           		        
511:           		            if (numBytesRead != 3)
0E18  0E03     MOVLW 0x3
0E1A  0103     MOVLB 0x3
0E1C  5D9B     SUBWF 0x9B, W, BANKED
0E1E  E112     BNZ 0xE44
512:                               {                                   // nesedi pocet bajtu v CMD
513:                                   putUSB_AT_ERR();
514:                                   break;
515:                               }
516:                               
517:           				    flag.LED_Flashing = TRUE;     
0E20  819D     BSF 0x9D, 0, BANKED
518:           				    countLED1 = 0;                      // vynuluje se citac indikace CDC modu
0E22  0102     MOVLB 0x2
0E24  6B01     CLRF p, BANKED
519:           				    tmp_buf[0] = '<';
0E26  EC5B     CALL 0x16B6, 0
0E28  F00B     NOP
520:           			        tmp_buf[1] = 'B';
0E2A  0E42     MOVLW 0x42
0E2C  6FA0     MOVWF IQRF_SPI_RxBuf, BANKED
521:           			        tmp_buf[2] = ':';
0E2E  0E3A     MOVLW 0x3A
0E30  6FA1     MOVWF 0xA1, BANKED
522:           			        tmp_buf[3] = 'O';
0E32  0E4F     MOVLW 0x4F
0E34  6FA2     MOVWF 0xA2, BANKED
523:           			        tmp_buf[4] = 'K';
0E36  0E4B     MOVLW 0x4B
0E38  6FA3     MOVWF 0xA3, BANKED
524:           			        tmp_buf[5] = '\r';
0E3A  0E0D     MOVLW 0xD
0E3C  6FA4     MOVWF 0xA4, BANKED
525:           			        putUSBUSART((char *)tmp_buf, 6);    // "<B:OK"<CR>
0E3E  0E06     MOVLW 0x6
0E40  DB9F     RCALL __pa_3
526:           			        break;
0E42  D001     BRA 0xE46
527:           	        //---------------------------
528:           				default:                                     
529:           				    
530:           				    if (numBytesRead == 2)                  // ">"<CR>
0BE8  0E02     MOVLW 0x2
0BEA  0103     MOVLB 0x3
0BEC  5D9B     SUBWF 0x9B, W, BANKED
0BEE  E001     BZ 0xBF2
0BF0  D129     BRA 0xE44
531:           				    {
532:               				    tmp_buf[0] = '<';
0BF2  0E3C     MOVLW 0x3C
0BF4  6F9F     MOVWF 0x9F, BANKED
533:               				    tmp_buf[1] = 'O';
0BF6  0E4F     MOVLW 0x4F
0BF8  6FA0     MOVWF IQRF_SPI_RxBuf, BANKED
534:           			            tmp_buf[2] = 'K';
0BFA  0E4B     MOVLW 0x4B
0BFC  6FA1     MOVWF 0xA1, BANKED
535:           			            tmp_buf[3] = '\r';   
0BFE  0E0D     MOVLW 0xD
0C00  6FA2     MOVWF 0xA2, BANKED
536:           			            putUSBUSART((char *)tmp_buf, 4);    // "<OK"<CR>
0C02  0E04     MOVLW 0x4
537:               				}
538:               				else                                    // ">"<xxx> - nepodporovany CMD
0C04  D11D     BRA 0xE40
539:               				{
540:               				    putUSB_AT_ERR();
0E44  D804     RCALL putUSB_AT_ERR
541:           			        }
542:           
543:           					break; 
544:           			}
545:           			
546:           			OUTPacket._byte[1] = 0;                         // 3. bajt pro event. nasledny switch se musi vynulovat
0E46  0103     MOVLB 0x3
0E48  6B41     CLRF tmp, BANKED
547:           		}
548:           	}
549:                   
550:               CDCTxService();
0E4A  EF91     GOTO 0x1922
0E4C  F00C     NOP
551:           }	
552:           //---------------------------------------------------------------------------
553:           
554:           void putUSB_AT_ERR(void)
555:           {
556:               tmp_buf[0] = '<';
0E4E  EC5B     CALL 0x16B6, 0
0E50  F00B     NOP
557:               tmp_buf[1] = 'E';
0E52  0E45     MOVLW 0x45
0E54  6FA0     MOVWF IQRF_SPI_RxBuf, BANKED
558:               tmp_buf[2] = 'R';
0E56  0E52     MOVLW 0x52
0E58  6FA1     MOVWF 0xA1, BANKED
559:               tmp_buf[3] = 'R';
0E5A  6FA2     MOVWF 0xA2, BANKED
560:               tmp_buf[4] = '\r';
0E5C  0E0D     MOVLW 0xD
0E5E  6FA3     MOVWF 0xA3, BANKED
561:               putUSBUSART((char *)tmp_buf, 5);    // "<ERR"<CR>
0E60  0E05     MOVLW 0x5
0E62  EFC0     GOTO 0x1580
0E64  F00A     NOP
562:           //    putrsUSBUSART((char*)"<ERR\r", 5);  // toto za to prida jeste 0
563:           }
564:           //---------------------------------------------------------------------------
565:           
566:           void IQRF_Message_Task(void)
0E66  DB72     RCALL __pa_1
0E68  52E6     MOVF POSTINC1, F, ACCESS
567:           {
568:           unsigned char i;
569:               
570:               if (IQRF_SPI_Task_Message)				    // pokud je nejake hlaseni od IQRF_SPI_Task
0E6A  0100     MOVLB 0x0
0E6C  51E4     MOVF IQRF_SPI_Task_Message, W, BANKED
0E6E  E05B     BZ 0xF26
571:           	{	
572:           		switch (IQRF_SPI_Task_Message)          // asynchr. pakety do USB
0E70  51E4     MOVF IQRF_SPI_Task_Message, W, BANKED
0E72  0A03     XORLW 0x3
0E74  E020     BZ 0xEB6
0E76  0A01     XORLW 0x1
0E78  E008     BZ 0xE8A
0E7A  0A06     XORLW 0x6
0E7C  E006     BZ 0xE8A
0E7E  0A05     XORLW 0x5
0E80  E150     BNZ 0xF22
573:           		{
574:           			case IQRF_SPI_WRITE_OK:             // zapis dat do TR modulu - ok          
575:           		    	tmp_buf[0] = '<';
0E82  DBD0     RCALL __pa_13
1624  D848     RCALL __pa_25
16B6  0103     MOVLB 0x3
16B8  0E3C     MOVLW 0x3C
16BA  6F9F     MOVWF 0x9F, BANKED
16BC  0012     RETURN 0
576:           		        tmp_buf[1] = 'D';
1626  0E44     MOVLW 0x44
1628  6FA0     MOVWF IQRF_SPI_RxBuf, BANKED
162A  0012     RETURN 0
577:           		        tmp_buf[2] = 'S';
0E84  0E53     MOVLW 0x53
0E86  DBBB     RCALL __pa_11
578:           		        tmp_buf[3] = ':';
579:           		        tmp_buf[4] = 'O';
580:           		        tmp_buf[5] = 'K';
581:           		        tmp_buf[6] = '\r';
582:           		        putUSBUSART((char *)tmp_buf, 7);// "<DS:OK"<CR>
583:           				break;
0E88  D04B     BRA 0xF20
584:           				
585:           			case IQRF_SPI_WRITE_ERR:            // zapis/cteni dat do/z TR modulu - error    
586:           			case IQRF_SPI_READ_ERR:  
587:           /*			
588:           			    for (i = 0; i < IQRF_SPI_BUFFER_SIZE; i++)
589:           			    {
590:           			        TIME_BTW_BYTE               // macro - see user.h
591:                   		    IQRF_SPI_Byte(0x00);        // prozene modulem same nuly
592:                   		}
593:           */        		
594:                    		tmp_buf[0] = '<';
0E8A  DBCC     RCALL __pa_13
595:           		        tmp_buf[1] = 'D';
596:           		        
597:           		        if (IQRF_SPI_Task_Message == IQRF_SPI_WRITE_ERR)
0E8C  0E02     MOVLW 0x2
0E8E  0100     MOVLB 0x0
0E90  5DE4     SUBWF IQRF_SPI_Task_Message, W, BANKED
0E92  E103     BNZ 0xE9A
598:           		            tmp_buf[2] = 'S';
0E94  0103     MOVLB 0x3
0E96  0E53     MOVLW 0x53
599:           		        else
0E98  D002     BRA 0xE9E
600:           		            tmp_buf[2] = 'R';
0E9A  0103     MOVLB 0x3
0E9C  0E52     MOVLW 0x52
0E9E  6FA1     MOVWF 0xA1, BANKED
601:           		        
602:           		        tmp_buf[3] = ':';
0EA0  0E3A     MOVLW 0x3A
0EA2  6FA2     MOVWF 0xA2, BANKED
603:           		        tmp_buf[4] = 'E';
0EA4  0E45     MOVLW 0x45
0EA6  6FA3     MOVWF 0xA3, BANKED
604:           		        tmp_buf[5] = 'R';
0EA8  0E52     MOVLW 0x52
0EAA  6FA4     MOVWF 0xA4, BANKED
605:           		        tmp_buf[6] = 'R';
0EAC  6FA5     MOVWF 0xA5, BANKED
606:           		        tmp_buf[7] = '\r';
0EAE  0E0D     MOVLW 0xD
0EB0  6FA6     MOVWF 0xA6, BANKED
607:           		        putUSBUSART((char *)tmp_buf, 8);// "<DS:ERR"<CR>
0EB2  0E08     MOVLW 0x8
608:           				break;
0EB4  D035     BRA 0xF20
609:           			
610:           			case IQRF_SPI_DATA_READY:           // Rx data z TR modulu   
611:           			
612:           			    if (flag.GetModuleInfo)         // pouze po probuzeni v CDC rezimu
0EB6  0103     MOVLB 0x3
0EB8  AF9D     BTFSS 0x9D, 7, BANKED
0EBA  D010     BRA 0xEDC
613:           			    {
614:               			    flag.GetModuleInfo = FALSE; 
0EBC  9F9D     BCF 0x9D, 7, BANKED
615:                               memcpy(TR_InfoBuf, (void *)IQRF_SPI_RxBuf + 2, 8);
0EBE  0E08     MOVLW 0x8
0EC0  DBD9     RCALL __pa_20
0EC2  0EDF     MOVLW 0xDF
0EC4  6EE6     MOVWF POSTINC1, ACCESS
0EC6  0E03     MOVLW 0x3
0EC8  DB79     RCALL __pa_8
0ECA  E202     BC 0xED0
0ECC  6AE1     CLRF FSR1L, ACCESS
0ECE  52E5     MOVF POSTDEC1, F, ACCESS
0ED0  6EE1     MOVWF FSR1L, ACCESS
0ED2  5014     MOVF __tmp_0, W, ACCESS
1674  6EE6     MOVWF POSTINC1, ACCESS
1676  6AE6     CLRF POSTINC1, ACCESS
1678  0EA2     MOVLW 0xA2
167A  6EE6     MOVWF POSTINC1, ACCESS
167C  0E00     MOVLW 0x0
167E  6EE6     MOVWF POSTINC1, ACCESS
1680  0012     RETURN 0
616:                               TR_state = TR_RESET;
0ED4  0103     MOVLB 0x3
0ED6  0E01     MOVLW 0x1
0ED8  6F80     MOVWF 0x80, BANKED
617:               			} 
618:               			else
0EDA  D023     BRA 0xF22
619:               			{ 
620:               			    tmp_buf[0] = '<';
0EDC  0E3C     MOVLW 0x3C
0EDE  6F9F     MOVWF 0x9F, BANKED
621:               			    tmp_buf[1] = 'D';
0EE0  0E44     MOVLW 0x44
0EE2  6FA0     MOVWF IQRF_SPI_RxBuf, BANKED
622:               			    tmp_buf[2] = 'R';
0EE4  0E52     MOVLW 0x52
0EE6  6FA1     MOVWF 0xA1, BANKED
623:               			    tmp_buf[3] = iq_DLEN;
0EE8  C0E1     MOVFF iq_DLEN, 0x3A2
0EEA  F3A2     NOP
624:               			    tmp_buf[4] = ':';
0EEC  0E3A     MOVLW 0x3A
0EEE  6FA3     MOVWF 0xA3, BANKED
625:               			    memcpy(tmp_buf + 5, (void *)IQRF_SPI_RxBuf + 2, iq_DLEN);
0EF0  0100     MOVLB 0x0
0EF2  51E1     MOVF iq_DLEN, W, BANKED
0EF4  DBBF     RCALL __pa_20
0EF6  0EA4     MOVLW 0xA4
0EF8  6EE6     MOVWF POSTINC1, ACCESS
0EFA  0E03     MOVLW 0x3
0EFC  DB5F     RCALL __pa_8
0EFE  E202     BC 0xF04
0F00  6AE1     CLRF FSR1L, ACCESS
0F02  52E5     MOVF POSTDEC1, F, ACCESS
0F04  6EE1     MOVWF FSR1L, ACCESS
0F06  5014     MOVF __tmp_0, W, ACCESS
15BC  6EE6     MOVWF POSTINC1, ACCESS
15BE  ECFA     CALL 0x2BF4, 0
15C0  F015     NOP
15C2  6E14     MOVWF __tmp_0, ACCESS
15C4  0E06     MOVLW 0x6
15C6  5CE1     SUBWF FSR1L, W, ACCESS
15C8  0012     RETURN 0
626:               			    tmp_buf[iq_DLEN + 5] = '\r';       // <CR> 0x0D
0F08  0E05     MOVLW 0x5
0F0A  0100     MOVLB 0x0
0F0C  25E1     ADDWF iq_DLEN, W, BANKED
0F0E  6AEA     CLRF FSR0H, ACCESS
0F10  0F9F     ADDLW 0x9F
0F12  6EE9     MOVWF FSR0L, ACCESS
0F14  0E03     MOVLW 0x3
0F16  22EA     ADDWFC FSR0H, F, ACCESS
0F18  0E0D     MOVLW 0xD
0F1A  6EEF     MOVWF INDF0, ACCESS
627:               			    putUSBUSART((char *)tmp_buf, iq_DLEN + 6); // "<DR"<dlen>":"<data><CR>
0F1C  0E06     MOVLW 0x6
0F1E  25E1     ADDWF iq_DLEN, W, BANKED
0F20  DB2F     RCALL __pa_3
1580  6EE6     MOVWF POSTINC1, ACCESS
1582  0E9F     MOVLW 0x9F
1584  6EE6     MOVWF POSTINC1, ACCESS
1586  0E03     MOVLW 0x3
1588  6EE6     MOVWF POSTINC1, ACCESS
158A  EC16     CALL 0x182C, 0
158C  F00C     NOP
158E  52E5     MOVF POSTDEC1, F, ACCESS
1590  52E5     MOVF POSTDEC1, F, ACCESS
1592  52E5     MOVF POSTDEC1, F, ACCESS
1594  0012     RETURN 0
628:           			    }
629:           				break;
630:           		}
631:           		
632:           		IQRF_SPI_Task_Message = 0;
0F22  0100     MOVLB 0x0
0F24  6BE4     CLRF IQRF_SPI_Task_Message, BANKED
633:           	}
634:           }
0F26  52E5     MOVF POSTDEC1, F, ACCESS
0F28  D336     BRA __pa_4
635:           //---------------------------------------------------------------------------
636:           
637:           void SPI_BusyPacket(void)	// odesila se pokud je SPI TR modulu obsazena
638:           {
639:           	INPacket._byte[0] = 0;
0F2A  0103     MOVLB 0x3
0F2C  6B00     CLRF i, BANKED
640:           	INPacket._byte[1] = 0x5F;
0F2E  0E5F     MOVLW 0x5F
0F30  6F01     MOVWF p, BANKED
641:           	counter = 2;
0F32  0103     MOVLB 0x3
0F34  0E02     MOVLW 0x2
0F36  6F81     MOVWF 0x81, BANKED
642:           }
0F38  0012     RETURN 0
643:           //---------------------------------------------------------------------------
644:           
645:           void Button_1_Task(void)                        // SS pin button
646:           { 
647:           static unsigned char btn1_cnt;
648:           	
649:           	if (BTN1_IO)
0F3A  A881     BTFSS PORTB, 4, ACCESS
0F3C  D008     BRA 0xF4E
650:           	{                                           // button not pressed 
651:               	btn1_cnt = 0;                           // counter reset
0F3E  0103     MOVLB 0x3
0F40  6BE7     CLRF byte_space, BANKED
652:               	
653:               	if (!flag.BTN1_pressed)                   
0F42  A79D     BTFSS 0x9D, 3, BANKED
654:               	    return;
0F44  0012     RETURN 0
655:               	                                        // (jen 1x)
656:           		flag.BTN1_pressed = FALSE;
0F46  979D     BCF 0x9D, 3, BANKED
657:           		LED1_IO = 0;
0F48  908B     BCF LATC, 0, ACCESS
658:           		CS_TR_IO = 1;
0F4A  868A     BSF LATB, 3, ACCESS
659:           	}
660:           	else
0F4C  0012     RETURN 0
661:           	{                                           // button pressed
662:           		if (btn1_cnt < 255)
0F4E  0103     MOVLB 0x3
0F50  51E7     MOVF byte_space, W, BANKED
0F52  6E14     MOVWF __tmp_0, ACCESS
0F54  6A15     CLRF 0x15, ACCESS
0F56  90D8     BCF STATUS, 0, ACCESS
0F58  5015     MOVF 0x15, W, ACCESS
0F5A  E604     BN 0xF64
0F5C  0EFF     MOVLW 0xFF
0F5E  5C14     SUBWF __tmp_0, W, ACCESS
0F60  0E00     MOVLW 0x0
0F62  5815     SUBWFB 0x15, W, ACCESS
0F64  E201     BC 0xF68
663:           			btn1_cnt++;                         // counts press time
0F66  2BE7     INCF byte_space, F, BANKED
664:           			
665:           		if (flag.BTN1_pressed)                   
0F68  B79D     BTFSC 0x9D, 3, BANKED
666:               	    return;
0F6A  0012     RETURN 0
667:           			
668:           		if (btn1_cnt > BTN_PRESS_MIN)
0F6C  51E7     MOVF byte_space, W, BANKED
0F6E  0805     SUBLW 0x5
0F70  E203     BC 0xF78
669:           		{
670:           			flag.BTN1_pressed = TRUE;
0F72  879D     BSF 0x9D, 3, BANKED
671:           			LED1_IO = 1;
0F74  808B     BSF LATC, 0, ACCESS
672:           			CS_TR_IO = 0;
0F76  968A     BCF LATB, 3, ACCESS
673:           	    }   
674:               }   
675:           }
0F78  0012     RETURN 0
676:           //---------------------------------------------------------------------------
677:           
678:           void Button_2_Task(void)                        // TR module reset button
679:           {
680:           static unsigned char btn2_cnt;
681:           
682:               if (BTN2_IO)                               
0F7A  AA81     BTFSS PORTB, 5, ACCESS
0F7C  D006     BRA 0xF8A
683:           	{                                           // button not pressed 
684:               	btn2_cnt = 0;                           // counter reset
0F7E  0103     MOVLB 0x3
0F80  6BE8     CLRF Check_Status_Time, BANKED
685:               	
686:               	if (!flag.BTN2_pressed)                   
0F82  A99D     BTFSS 0x9D, 4, BANKED
687:               	    return;
0F84  0012     RETURN 0
688:               	                                        // akce na uvolneni jen jednou
689:           		flag.BTN2_pressed = FALSE;
0F86  999D     BCF 0x9D, 4, BANKED
690:           	}
691:           	else
0F88  0012     RETURN 0
692:           	{                                           // button pressed
693:           		if (btn2_cnt < 255)
0F8A  0103     MOVLB 0x3
0F8C  51E8     MOVF Check_Status_Time, W, BANKED
0F8E  6E14     MOVWF __tmp_0, ACCESS
0F90  6A15     CLRF 0x15, ACCESS
0F92  90D8     BCF STATUS, 0, ACCESS
0F94  5015     MOVF 0x15, W, ACCESS
0F96  E604     BN 0xFA0
0F98  0EFF     MOVLW 0xFF
0F9A  5C14     SUBWF __tmp_0, W, ACCESS
0F9C  0E00     MOVLW 0x0
0F9E  5815     SUBWFB 0x15, W, ACCESS
0FA0  E201     BC 0xFA4
694:           			btn2_cnt++;                         // counts press time
0FA2  2BE8     INCF Check_Status_Time, F, BANKED
695:           			
696:           		if (flag.BTN2_pressed)                   
0FA4  B99D     BTFSC 0x9D, 4, BANKED
697:               	    return; 
0FA6  0012     RETURN 0
698:           		
699:           		if (btn2_cnt > BTN_PRESS_MIN)
0FA8  51E8     MOVF Check_Status_Time, W, BANKED
0FAA  0805     SUBLW 0x5
0FAC  E203     BC 0xFB4
700:           		{                                       // akce na stisk jen jednou
701:           			flag.BTN2_pressed = TRUE;
0FAE  899D     BSF 0x9D, 4, BANKED
702:           			TR_state = TR_RESET;
0FB0  0E01     MOVLW 0x1
0FB2  6F80     MOVWF 0x80, BANKED
703:           	    }   
704:               }         
705:           }
0FB4  0012     RETURN 0
706:           //---------------------------------------------------------------------------
707:           
708:           void TR_ModuleControl(void)
709:           {
710:               switch (TR_state)
0FB6  0103     MOVLB 0x3
0FB8  5180     MOVF 0x80, W, BANKED
0FBA  0A04     XORLW 0x4
0FBC  E035     BZ 0x1028
0FBE  0A07     XORLW 0x7
0FC0  E021     BZ 0x1004
0FC2  0A01     XORLW 0x1
0FC4  E00F     BZ 0xFE4
0FC6  0A03     XORLW 0x3
0FC8  E003     BZ 0xFD0
0FCA  0A01     XORLW 0x1
0FCC  E04C     BZ 0x1066
0FCE  0012     RETURN 0
711:               {
712:                   case TR_READY:
713:                       break;
714:                   
715:                   case TR_RESET:
716:           			TR_SPICON1bits.SPIEN = 0;						// SPI TR OFF
0FD0  9A72     BCF SSP2CON1, 5, ACCESS
717:                       TR_SDO_IO = 0;
0FD2  9E8B     BCF LATC, 7, ACCESS
718:                       TR_Module_OFF();
0FD4  D84C     RCALL TR_Module_OFF
719:                       LED2_IO = 1;                                    // start indikace TR module reset
0FD6  848A     BSF LATB, 2, ACCESS
720:                       
721:                       TR_timeout = 300;                               // set timeout in ms
0FD8  0103     MOVLB 0x3
0FDA  0E2C     MOVLW 0x2C
0FDC  DB04     RCALL __pa_10
15E6  6F92     MOVWF 0x92, BANKED
15E8  0E01     MOVLW 0x1
15EA  6F93     MOVWF 0x93, BANKED
722:                       TR_ctrl_tick = tick;                            // reset tick counter
15EC  C382     MOVFF tick, TR_ctrl_tick
15EE  F38E     NOP
15F0  C383     MOVFF 0x383, 0x38F
15F2  F38F     NOP
15F4  C384     MOVFF 0x384, 0x390
15F6  F390     NOP
15F8  C385     MOVFF 0x385, 0x391
15FA  F391     NOP
15FC  0012     RETURN 0
723:                       TR_state = TR_WAIT;
0FDE  0E02     MOVLW 0x2
0FE0  6F80     MOVWF 0x80, BANKED
724:                       break;
0FE2  0012     RETURN 0
725:                       
726:                   case TR_WAIT:
727:                       if (tick - TR_ctrl_tick >= TR_timeout)          // dokud neuplyne timeout
0FE4  DA9E     RCALL __pa_0
0FE6  E33F     BNC 0x1066
1522  0E8E     MOVLW 0x8E
1524  6EE9     MOVWF FSR0L, ACCESS
1526  0E03     MOVLW 0x3
1528  6EEA     MOVWF FSR0H, ACCESS
152A  50EE     MOVF POSTINC0, W, ACCESS
152C  D8AA     RCALL __pa_21
152E  C392     MOVFF TR_timeout, 0x18
1530  F018     NOP
1532  C393     MOVFF 0x393, 0x19
1534  F019     NOP
1536  6A1A     CLRF 0x1A, ACCESS
1538  6A1B     CLRF 0x1B, ACCESS
153A  5018     MOVF 0x18, W, ACCESS
153C  5C14     SUBWF __tmp_0, W, ACCESS
153E  5019     MOVF 0x19, W, ACCESS
1540  5815     SUBWFB 0x15, W, ACCESS
1542  501A     MOVF 0x1A, W, ACCESS
1544  5816     SUBWFB 0x16, W, ACCESS
1546  501B     MOVF 0x1B, W, ACCESS
1548  5817     SUBWFB 0x17, W, ACCESS
154A  0012     RETURN 0
1682  5D82     SUBWF 0x82, W, BANKED
1684  6E14     MOVWF __tmp_0, ACCESS
1686  50EE     MOVF POSTINC0, W, ACCESS
1688  5983     SUBWFB 0x83, W, BANKED
168A  6E15     MOVWF 0x15, ACCESS
168C  50EE     MOVF POSTINC0, W, ACCESS
168E  5984     SUBWFB 0x84, W, BANKED
1690  6E16     MOVWF 0x16, ACCESS
1692  50EE     MOVF POSTINC0, W, ACCESS
1694  5985     SUBWFB 0x85, W, BANKED
1696  6E17     MOVWF 0x17, ACCESS
1698  0012     RETURN 0
728:           	        {
729:               	        if (flag.BTN2_pressed)
0FE8  B99D     BTFSC 0x9D, 4, BANKED
730:                               break;                                  // pokud je drzeno tl. TR module reset
0FEA  0012     RETURN 0
731:                               
732:           				TR_Module_ON();
0FEC  D83D     RCALL TR_Module_ON
733:           				LED2_IO = 0;                                // stop indikace TR module reset
0FEE  948A     BCF LATB, 2, ACCESS
734:                           
735:                           if (flag.EnterProgMode)
0FF0  0103     MOVLB 0x3
0FF2  A39D     BTFSS 0x9D, 1, BANKED
0FF4  D005     BRA 0x1000
736:                           {
737:                               CS_TR_IO = 0; 
0FF6  968A     BCF LATB, 3, ACCESS
738:                               TR_timeout = 400;                       // set timeout in ms
0FF8  0E90     MOVLW 0x90
0FFA  DAF5     RCALL __pa_10
739:                               TR_ctrl_tick = tick;                    // reset tick counter
740:                               TR_state = TR_ENTER_PROG_MODE;   
0FFC  0E03     MOVLW 0x3
741:                           }
742:                           else
0FFE  D010     BRA 0x1020
743:                           {
744:                               TR_SPICON1bits.SPIEN = 1;               // SPI TR ON
1000  8A72     BSF SSP2CON1, 5, ACCESS
745:                               TR_state = TR_READY;   
746:                           }       
747:           	        }
748:                       break;
1002  D010     BRA 0x1024
749:               
750:                   case TR_ENTER_PROG_MODE: 
751:                       TR_SDO_IO = TR_SDI_IO;                          // kopirovani
1004  5082     MOVF PORTC, W, ACCESS
1006  0B40     ANDLW 0x40
1008  E002     BZ 0x100E
100A  8E8B     BSF LATC, 7, ACCESS
100C  D001     BRA 0x1010
100E  9E8B     BCF LATC, 7, ACCESS
752:                       
753:                       if (tick - TR_ctrl_tick >= TR_timeout)          // dokud neuplyne timeout
1010  DA88     RCALL __pa_0
1012  E329     BNC 0x1066
754:           	        {
755:               	    	CS_TR_IO = 1;
1014  868A     BSF LATB, 3, ACCESS
756:           			    TR_SPICON1bits.SPIEN = 1;                   // SPI TR ON
1016  8A72     BSF SSP2CON1, 5, ACCESS
757:           			    flag.EnterProgMode = FALSE;
1018  939D     BCF 0x9D, 1, BANKED
758:           			    
759:           			    if (flag.GetModuleInfo)
101A  AF9D     BTFSS 0x9D, 7, BANKED
101C  D003     BRA 0x1024
760:           			        TR_state = TR_INFO_SEND_REQUEST;
101E  0E04     MOVLW 0x4
1020  6F80     MOVWF 0x80, BANKED
761:           			    else
1022  0012     RETURN 0
762:           			        TR_state = TR_READY;
1024  6B80     CLRF 0x80, BANKED
763:                       }    
764:                       break;
1026  0012     RETURN 0
765:                   
766:                   case TR_INFO_SEND_REQUEST:
767:                       											// only if the IQRF_SPI_Task() is not busy and TR module is in prog mode
768:           	 		if (iq_spistat == TR_STAT_PROG_MODE && IQRF_SPI_Busy == 0)	
1028  0E81     MOVLW 0x81
102A  0100     MOVLB 0x0
102C  5DE3     SUBWF iq_spistat, W, BANKED
102E  E11B     BNZ 0x1066
1030  0100     MOVLB 0x0
1032  51E0     MOVF IQRF_SPI_Busy, W, BANKED
1034  E118     BNZ 0x1066
769:           	 		{											// packet preparing
770:           	 			Clear_IQRF_SPI_TxBuf();
1036  DAC9     RCALL __pa_9
1038  E202     BC 0x103E
103A  6AE1     CLRF FSR1L, ACCESS
103C  52E5     MOVF POSTDEC1, F, ACCESS
103E  6EE1     MOVWF FSR1L, ACCESS
1040  5014     MOVF __tmp_0, W, ACCESS
771:           	 			iq_DLEN = 1; 						
1042  0100     MOVLB 0x0
1044  0E01     MOVLW 0x1
1046  6FE1     MOVWF iq_DLEN, BANKED
772:           				iq_PTYPE = (iq_DLEN | 0x80);		    // PTYTE set bit7 - write to buffer COM of TR module 
1048  0E80     MOVLW 0x80
104A  11E1     IORWF iq_DLEN, W, BANKED
104C  0100     MOVLB 0x0
104E  6FE2     MOVWF iq_PTYPE, BANKED
773:           				IQRF_SPI_TxBuf[0] = TR_CMD_MODULE_INFO;
1050  0100     MOVLB 0x0
1052  0EF5     MOVLW 0xF5
1054  6F60     MOVWF IQRF_SPI_TxBuf, BANKED
774:           				IQRF_SPI_TxBuf[1] = iq_PTYPE;
1056  C0E2     MOVFF iq_PTYPE, 0x61
1058  F061     NOP
775:           				IQRF_SPI_TxBuf[2] = 0;					// DB
105A  6B62     CLRF 0x62, BANKED
776:           				Start_IQRF_SPI();                       // prepare IQRF_SPI_Task to send DLEN + 4 (CMD, PTYPE, CRCM, 0) bytes								
105C  EC09     CALL 0x2812, 0
105E  F014     NOP
777:           				IQRF_SPI_Busy = IQRF_BUSY_NO_MESSAGE;   // prepise IQRF_SPI_Busy nastaveny v Start_IQRF_SPI
1060  0100     MOVLB 0x0
1062  0E03     MOVLW 0x3
1064  6FE0     MOVWF IQRF_SPI_Busy, BANKED
778:           	 		}
779:                       break;
780:               }
781:           }
1066  0012     RETURN 0
782:           //---------------------------------------------------------------------------
783:           
784:           void TR_Module_ON(void)
785:           {
786:           	CS_TR_IO = 1;										// TR CS - idle state
1068  868A     BSF LATB, 3, ACCESS
787:           	PWR_TR_IO = 0;										// power ON
106A  928A     BCF LATB, 1, ACCESS
788:           }
106C  0012     RETURN 0
789:           //--------------------------------------------------------------------------- 
790:           
791:           void TR_Module_OFF(void)
792:           {
793:           	PWR_TR_IO = 1;										// power OFF, RESET
106E  828A     BSF LATB, 1, ACCESS
794:           	CS_TR_IO = 0;										// TR CS - must be low
1070  968A     BCF LATB, 3, ACCESS
795:           	TR_SDO_IO = 0;
1072  9E8B     BCF LATC, 7, ACCESS
796:           	TR_SCK_IO = 0;
1074  908A     BCF LATB, 0, ACCESS
797:           }
1076  0012     RETURN 0
798:           //---------------------------------------------------------------------------
799:           
800:           void GW_Reset(void)
801:           {
802:               TR_Module_OFF();
1078  DFFA     RCALL TR_Module_OFF
803:               USBModuleDisable();					        // USB OFF
107A  6A65     CLRF UCON, ACCESS
107C  010F     MOVLB 0xF
107E  6B36     CLRF 0x36, BANKED
1080  0104     MOVLB 0x4
1082  6B30     CLRF 0x30, BANKED
804:               Delay_ms(250);
1084  0EFA     MOVLW 0xFA
1086  6EE6     MOVWF POSTINC1, ACCESS
1088  D843     RCALL Delay_ms
108A  52E5     MOVF POSTDEC1, F, ACCESS
805:               Delay_ms(250);
108C  0EFA     MOVLW 0xFA
108E  6EE6     MOVWF POSTINC1, ACCESS
1090  D83F     RCALL Delay_ms
1092  52E5     MOVF POSTDEC1, F, ACCESS
806:               Reset();
1094  00FF     RESET
807:           }
1096  0012     RETURN 0
808:           //---------------------------------------------------------------------------
809:           
810:           void service_SPI_data(void)   // obsluha SPI busu
1098  DA59     RCALL __pa_1
109A  52E6     MOVF POSTINC1, F, ACCESS
109C  52E6     MOVF POSTINC1, F, ACCESS
154C  CFD9     MOVFF FSR2L, POSTINC1
154E  FFE6     NOP
1550  CFDA     MOVFF FSR2H, POSTINC1
1552  FFE6     NOP
1554  CFE1     MOVFF FSR1L, FSR2L
1556  FFD9     NOP
1558  CFE2     MOVFF FSR1H, FSR2H
155A  FFDA     NOP
155C  0012     RETURN 0
811:           {
812:           unsigned char i, ide_debug;
813:               
814:               ide_debug = 0;
109E  0E01     MOVLW 0x1
10A0  6ADB     CLRF PLUSW2, ACCESS
815:           	
816:           	if ((OUTPacket._byte[1] == TR_CMD_RAM_READ) || (OUTPacket._byte[1] == TR_CMD_EE_READ))
10A2  0EF1     MOVLW 0xF1
10A4  0103     MOVLB 0x3
10A6  5D41     SUBWF tmp, W, BANKED
10A8  E003     BZ 0x10B0
10AA  0EF2     MOVLW 0xF2
10AC  5D41     SUBWF tmp, W, BANKED
10AE  E103     BNZ 0x10B6
817:           	    ide_debug = 1;
10B0  52DE     MOVF POSTINC2, F, ACCESS
10B2  0E01     MOVLW 0x1
10B4  6EDD     MOVWF POSTDEC2, ACCESS
818:           	
819:           	for (i = 0; i < numBytesRead; i++)
10B6  6ADF     CLRF INDF2, ACCESS
10B8  0103     MOVLB 0x3
10BA  519B     MOVF 0x9B, W, BANKED
10BC  5CDF     SUBWF INDF2, W, ACCESS
10BE  E20C     BC 0x10D8
10D4  2ADF     INCF INDF2, F, ACCESS
10D6  D7F0     BRA 0x10B8
820:           	{	
821:           		INPacket._byte[i] = IQRF_SPI_Byte(OUTPacket._byte[i + 1]);
10C0  DA4E     RCALL __pa_2
155E  28DF     INCF INDF2, W, ACCESS
1560  D89F     RCALL __pa_23
1562  6EE6     MOVWF POSTINC1, ACCESS
1564  ECB9     CALL 0x2772, 0
1566  F013     NOP
1568  52E5     MOVF POSTDEC1, F, ACCESS
156A  6EE6     MOVWF POSTINC1, ACCESS
156C  50DF     MOVF INDF2, W, ACCESS
156E  6AEA     CLRF FSR0H, ACCESS
1570  0F00     ADDLW 0x0
1572  6EE9     MOVWF FSR0L, ACCESS
1574  0E03     MOVLW 0x3
1576  22EA     ADDWFC FSR0H, F, ACCESS
1578  52E5     MOVF POSTDEC1, F, ACCESS
157A  50E7     MOVF INDF1, W, ACCESS
157C  6EEF     MOVWF INDF0, ACCESS
157E  0012     RETURN 0
16A0  6AEA     CLRF FSR0H, ACCESS
16A2  0F40     ADDLW 0x40
16A4  6EE9     MOVWF FSR0L, ACCESS
16A6  0E03     MOVLW 0x3
16A8  22EA     ADDWFC FSR0H, F, ACCESS
16AA  50EF     MOVF INDF0, W, ACCESS
16AC  0012     RETURN 0
822:           		
823:           		if (ide_debug)
10C2  0E01     MOVLW 0x1
10C4  50DB     MOVF PLUSW2, W, ACCESS
10C6  E002     BZ 0x10CC
824:           		{
825:           		    TIME_BTW_BYTE_PGM                           // macro - see user.h
10C8  0E50     MOVLW 0x50
826:           		}
827:           		else
10CA  D003     BRA 0x10D2
828:           		{
829:               	    TIME_BTW_BYTE                               // macro - see user.h	
10CC  DAE6     RCALL __pa_22
10CE  DAE5     RCALL __pa_22
10D0  0EC8     MOVLW 0xC8
10D2  DA67     RCALL __pa_5
830:               	}	
831:           	}
832:           }
10D8  52E5     MOVF POSTDEC1, F, ACCESS
10DA  52E5     MOVF POSTDEC1, F, ACCESS
10DC  D25C     BRA __pa_4
833:           //---------------------------------------------------------------------------
834:           
835:           void Delay_us(unsigned char d) // pri d=2 je to cca 2us, ale pri d=250 je to cca 250us
10DE  CFD9     MOVFF FSR2L, POSTINC1
10E0  FFE6     NOP
10E2  CFDA     MOVFF FSR2H, POSTINC1
10E4  FFE6     NOP
10E6  CFE1     MOVFF FSR1L, FSR2L
10E8  FFD9     NOP
10EA  CFE2     MOVFF FSR1H, FSR2H
10EC  FFDA     NOP
836:           {
837:           	while(--d)
10EE  0EFD     MOVLW 0xFD
10F0  06DB     DECF PLUSW2, F, ACCESS
10F2  E008     BZ 0x1104
1102  D7F5     BRA 0x10EE
838:           	{
839:           		Nop();
10F4  0000     NOP
840:           		Nop();
10F6  0000     NOP
841:           		Nop();
10F8  0000     NOP
842:           		Nop();
10FA  0000     NOP
843:           		Nop();
10FC  0000     NOP
844:           		Nop();
10FE  0000     NOP
845:           		Nop();
1100  0000     NOP
846:           	}
847:           }
1104  52E5     MOVF POSTDEC1, F, ACCESS
1106  CFE5     MOVFF POSTDEC1, FSR2H
1108  FFDA     NOP
110A  CFE7     MOVFF INDF1, FSR2L
110C  FFD9     NOP
110E  0012     RETURN 0
848:           //---------------------------------------------------------------------------
849:           
850:           void Delay_ms(unsigned char d)
1110  DA1D     RCALL __pa_1
851:           {
852:           	while(d--)
1112  0EFD     MOVLW 0xFD
1114  CFDB     MOVFF PLUSW2, PRODL
1116  FFF3     NOP
1118  06DB     DECF PLUSW2, F, ACCESS
111A  50F3     MOVF PRODL, W, ACCESS
111C  0900     IORLW 0x0
111E  E005     BZ 0x112A
1128  D7F4     BRA 0x1112
853:           	{
854:           		Delay_us(250);
1120  DABC     RCALL __pa_22
855:           		Delay_us(250);
1122  DABB     RCALL __pa_22
856:           		Delay_us(250);
1124  DABA     RCALL __pa_22
169A  0EFA     MOVLW 0xFA
169C  EFD1     GOTO 0x15A2
169E  F00A     NOP
857:           		Delay_us(250);
1126  DAB9     RCALL __pa_22
858:           	}
859:           }
112A  D235     BRA __pa_4
860:           //---------------------------------------------------------------------------
861:           
862:           void TickInit(void)                         // set to 1ms
863:           {
864:           	tick = 0;
112C  0103     MOVLB 0x3
112E  6B82     CLRF 0x82, BANKED
1130  6B83     CLRF 0x83, BANKED
1132  6B84     CLRF 0x84, BANKED
1134  6B85     CLRF 0x85, BANKED
865:           	
866:           	T4CON = 0x76;
1136  0E76     MOVLW 0x76
1138  6E76     MOVWF T4CON, ACCESS
867:           	PR4 = 50;
113A  0E32     MOVLW 0x32
113C  6E77     MOVWF PR4, ACCESS
868:           
869:               PIR3bits.TMR4IF = 0; 					// clear flag
113E  96A4     BCF PIR3, 3, ACCESS
870:               PIE3bits.TMR4IE = 1; 					// enable interrupt
1140  86A3     BSF PIE3, 3, ACCESS
871:           }
1142  0012     RETURN 0
872:           //---------------------------------------------------------------------------
873:           
874:           void T4_Intr(void)
875:           {
876:           	if(PIR3bits.TMR4IF)
1144  A6A4     BTFSS PIR3, 3, ACCESS
1146  D007     BRA 0x1156
877:               {
878:           	  	tick++;
1148  0103     MOVLB 0x3
114A  2B82     INCF 0x82, F, BANKED
114C  0E00     MOVLW 0x0
114E  2383     ADDWFC 0x83, F, BANKED
1150  2384     ADDWFC 0x84, F, BANKED
1152  2385     ADDWFC 0x85, F, BANKED
879:           	  	PIR3bits.TMR4IF = 0;  
1154  96A4     BCF PIR3, 3, ACCESS
880:           	}
881:           }
1156  0012     RETURN 0
882:           //---------------------------------------------------------------------------
883:           
884:           void set_boot_mode (void)  	// navoli BOOT mod, tzn pokud je prijaty paket OK, zapise do EE, a resetuje
885:           				            // format paketu: FA.04.F0.AA.00.C4.55.F1.AF
886:           {
887:             	if((OUTPacket._byte[1] == 0x04) && (OUTPacket._byte[2] == 0xF0) && (OUTPacket._byte[3] == 0xAA) )
1158  0E04     MOVLW 0x4
115A  0103     MOVLB 0x3
115C  5D41     SUBWF tmp, W, BANKED
115E  E127     BNZ 0x11AE
1160  0EF0     MOVLW 0xF0
1162  0103     MOVLB 0x3
1164  5D42     SUBWF 0x42, W, BANKED
1166  E123     BNZ 0x11AE
1168  0EAA     MOVLW 0xAA
116A  0103     MOVLB 0x3
116C  5D43     SUBWF 0x43, W, BANKED
116E  E11F     BNZ 0x11AE
888:               {	
889:           			 	USBModuleDisable();					    // USB OFF  
1170  6A65     CLRF UCON, ACCESS
1172  010F     MOVLB 0xF
1174  6B36     CLRF 0x36, BANKED
1176  0104     MOVLB 0x4
1178  6B30     CLRF 0x30, BANKED
890:           			 	FlashWriteByte(EE_ADR_BOOT_SEQ, 0xC4); 	// v EEPROMe musi byt tato sekvence dat: {0xC4}
117A  0EC4     MOVLW 0xC4
117C  6EE6     MOVWF POSTINC1, ACCESS
117E  6AE6     CLRF POSTINC1, ACCESS
1180  0E04     MOVLW 0x4
1182  6EE6     MOVWF POSTINC1, ACCESS
1184  D8C6     RCALL FlashWriteByte
1186  52E5     MOVF POSTDEC1, F, ACCESS
1188  52E5     MOVF POSTDEC1, F, ACCESS
118A  52E5     MOVF POSTDEC1, F, ACCESS
891:           										                // aby se po resetu preslo do bootloaderu	
892:           
893:           				Delay_ms(250);						    // aby se stihlo odhlasit z PC USB s PID aplikace,
118C  0EFA     MOVLW 0xFA
118E  6EE6     MOVWF POSTINC1, ACCESS
1190  DFBF     RCALL Delay_ms
1192  52E5     MOVF POSTDEC1, F, ACCESS
894:           				Delay_ms(250);						    // bude se prihlasovat USB s PID bootloaderu
1194  0EFA     MOVLW 0xFA
1196  6EE6     MOVWF POSTINC1, ACCESS
1198  DFBB     RCALL Delay_ms
119A  52E5     MOVF POSTDEC1, F, ACCESS
895:           				Delay_ms(250);
119C  0EFA     MOVLW 0xFA
119E  6EE6     MOVWF POSTINC1, ACCESS
11A0  DFB7     RCALL Delay_ms
11A2  52E5     MOVF POSTDEC1, F, ACCESS
896:           				Delay_ms(250);
11A4  0EFA     MOVLW 0xFA
11A6  6EE6     MOVWF POSTINC1, ACCESS
11A8  DFB3     RCALL Delay_ms
11AA  52E5     MOVF POSTDEC1, F, ACCESS
897:           			 	Reset();
11AC  00FF     RESET
898:           	}		
899:           }
11AE  0012     RETURN 0
900:           //---------------------------------------------------------------------------
901:           
902:           void service_UPLOAD_mode(void)
11B0  D9CD     RCALL __pa_1
11B2  0E06     MOVLW 0x6
11B4  24E1     ADDWF FSR1L, W, ACCESS
11B6  E302     BNC 0x11BC
11B8  68E1     SETF FSR1L, ACCESS
11BA  52E6     MOVF POSTINC1, F, ACCESS
11BC  6EE1     MOVWF FSR1L, ACCESS
903:           {
904:            unsigned char i, n;
905:            unsigned char ok_cnt, temp;  
906:            unsigned int while_cnt;
907:           
908:           	n = USBHandleGetLength(USBGenericOutHandle)-1;
11BE  DA45     RCALL __pa_17
11C0  6EE7     MOVWF INDF1, ACCESS
11C2  0E01     MOVLW 0x1
11C4  CFE7     MOVFF INDF1, PLUSW2
11C6  FFDB     NOP
909:           		
910:           	for (i = 0; i < n; i++)	 
11C8  6ADF     CLRF INDF2, ACCESS
11CA  50DB     MOVF PLUSW2, W, ACCESS
11CC  5CDF     SUBWF INDF2, W, ACCESS
11CE  E208     BC 0x11E0
11DC  2ADF     INCF INDF2, F, ACCESS
11DE  D7F5     BRA 0x11CA
911:           	{
912:           		INPacket._byte[i] = IQRF_SPI_Byte(OUTPacket._byte[i+1]);
11D0  D9C6     RCALL __pa_2
913:           		TIME_BTW_BYTE_PGM                           // macro - see user.h
11D2  0E50     MOVLW 0x50
11D4  D9E6     RCALL __pa_5
914:           		counter = n;
11D6  0E01     MOVLW 0x1
11D8  CFDB     MOVFF PLUSW2, counter
11DA  F381     NOP
915:           	}
916:           
917:           	INPacket._byte[60] = 0x00;
11E0  0103     MOVLB 0x3
11E2  6B3C     CLRF 0x3C, BANKED
918:           	INPacket._byte[61] = 0x00;
11E4  6B3D     CLRF 0x3D, BANKED
919:           	INPacket._byte[62] = 0x00;
11E6  6B3E     CLRF 0x3E, BANKED
920:           	INPacket._byte[63] = 0x00;
11E8  6B3F     CLRF 0x3F, BANKED
921:           
922:           	ok_cnt = 0;
11EA  0E02     MOVLW 0x2
11EC  6ADB     CLRF PLUSW2, ACCESS
923:           	while_cnt = 5000;
11EE  0E88     MOVLW 0x88
11F0  6EF3     MOVWF PRODL, ACCESS
11F2  0E04     MOVLW 0x4
11F4  CFF3     MOVFF PRODL, PLUSW2
11F6  FFDB     NOP
11F8  0E13     MOVLW 0x13
11FA  6EF3     MOVWF PRODL, ACCESS
11FC  0E05     MOVLW 0x5
11FE  CFF3     MOVFF PRODL, PLUSW2
1200  FFDB     NOP
924:           	 
925:           	while (while_cnt--)
1202  0E04     MOVLW 0x4
1204  CFDB     MOVFF PLUSW2, __tmp_0
1206  F014     NOP
1208  06DB     DECF PLUSW2, F, ACCESS
120A  0E05     MOVLW 0x5
120C  CFDB     MOVFF PLUSW2, 0x15
120E  F015     NOP
1210  E201     BC 0x1214
1212  06DB     DECF PLUSW2, F, ACCESS
1214  5014     MOVF __tmp_0, W, ACCESS
1216  1015     IORWF 0x15, W, ACCESS
1218  E01F     BZ 0x1258
926:           	{	
927:           		temp = IQRF_SPI_Byte(0);	
121A  6AE6     CLRF POSTINC1, ACCESS
121C  ECB9     CALL 0x2772, 0
121E  F013     NOP
1220  52E5     MOVF POSTDEC1, F, ACCESS
1222  6EE7     MOVWF INDF1, ACCESS
1224  0E03     MOVLW 0x3
1226  CFE7     MOVFF INDF1, PLUSW2
1228  FFDB     NOP
928:           		TIME_BTW_BYTE_PGM                           // macro - see user.h
122A  0E50     MOVLW 0x50
122C  D9BA     RCALL __pa_5
15A2  6EE6     MOVWF POSTINC1, ACCESS
15A4  DD9C     RCALL Delay_us
15A6  52E5     MOVF POSTDEC1, F, ACCESS
15A8  0012     RETURN 0
929:           		
930:           		if (temp == 0x81)	
122E  0E03     MOVLW 0x3
1230  50DB     MOVF PLUSW2, W, ACCESS
1232  0881     SUBLW 0x81
1234  E103     BNZ 0x123C
931:           			ok_cnt ++;
1236  0E02     MOVLW 0x2
1238  2ADB     INCF PLUSW2, F, ACCESS
932:           		else
123A  D002     BRA 0x1240
933:           			ok_cnt = 0;	
123C  0E02     MOVLW 0x2
123E  6ADB     CLRF PLUSW2, ACCESS
934:           
935:           		if (ok_cnt > 2)	 
1240  50DB     MOVF PLUSW2, W, ACCESS
1242  0802     SUBLW 0x2
1244  E2DE     BC 0x1202
936:           		{
937:           			INPacket._byte[60] = 0x81;
1246  0103     MOVLB 0x3
1248  0E81     MOVLW 0x81
124A  6F3C     MOVWF 0x3C, BANKED
938:           			INPacket._byte[61] = 0x81;
124C  6F3D     MOVWF 0x3D, BANKED
939:           			INPacket._byte[62] = 0x81;
124E  6F3E     MOVWF 0x3E, BANKED
940:           			INPacket._byte[63] = 0x81;
1250  6F3F     MOVWF 0x3F, BANKED
941:           			counter =  64;					 
1252  0103     MOVLB 0x3
1254  0E40     MOVLW 0x40
1256  6F81     MOVWF 0x81, BANKED
942:           			break;
943:           		}
944:           	}
945:           }
1258  0E06     MOVLW 0x6
125A  5CE1     SUBWF FSR1L, W, ACCESS
125C  E202     BC 0x1262
125E  6AE1     CLRF FSR1L, ACCESS
1260  52E5     MOVF POSTDEC1, F, ACCESS
1262  6EE1     MOVWF FSR1L, ACCESS
1264  D198     BRA __pa_4
946:           //---------------------------------------------------------------------------
947:           
948:           void StartWrite(void)
1266  CFD9     MOVFF FSR2L, POSTINC1
1268  FFE6     NOP
126A  CFDA     MOVFF FSR2H, POSTINC1
126C  FFE6     NOP
126E  CFE1     MOVFF FSR1L, FSR2L
1270  FFD9     NOP
1272  CFE2     MOVFF FSR1H, FSR2H
1274  FFDA     NOP
1276  52E6     MOVF POSTINC1, F, ACCESS
949:           {
950:           unsigned char int_temp;
951:           	  	
952:             	if (flag.EnableMemWrite)
1278  0103     MOVLB 0x3
127A  AB9D     BTFSS 0x9D, 5, BANKED
127C  D00E     BRA 0x129A
953:               {		
954:           		int_temp = INTCON;					//save int register
127E  50F2     MOVF INTCON, W, ACCESS
1280  6EDF     MOVWF INDF2, ACCESS
955:           		INTCON = 0;							//2x pro sychr, u 16rady se nekdy nepovedlo zakazat INTRRUPT
1282  6AF2     CLRF INTCON, ACCESS
956:           		INTCON = 0;
1284  6AF2     CLRF INTCON, ACCESS
957:           	    EECON2 = 0x55;
1286  0E55     MOVLW 0x55
1288  6EA7     MOVWF EECON2, ACCESS
958:           	    EECON2 = 0xAA;
128A  0EAA     MOVLW 0xAA
128C  6EA7     MOVWF EECON2, ACCESS
959:           	    EECON1bits.WR = 1;
128E  82A6     BSF EECON1, 1, ACCESS
960:           	    Nop();
1290  0000     NOP
961:           	    Nop();
1292  0000     NOP
962:           	    Nop();
1294  0000     NOP
963:           	    INTCON = int_temp;					// restore int register 
1296  50DF     MOVF INDF2, W, ACCESS
1298  6EF2     MOVWF INTCON, ACCESS
964:               } 
965:           }
129A  52E5     MOVF POSTDEC1, F, ACCESS
129C  52E5     MOVF POSTDEC1, F, ACCESS
129E  CFE5     MOVFF POSTDEC1, FSR2H
12A0  FFDA     NOP
12A2  CFE7     MOVFF INDF1, FSR2L
12A4  FFD9     NOP
12A6  0012     RETURN 0
966:           //---------------------------------------------------------------------------
967:           
968:           unsigned char FlashReadByte(unsigned int adr)
12A8  CFD9     MOVFF FSR2L, POSTINC1
12AA  FFE6     NOP
12AC  CFDA     MOVFF FSR2H, POSTINC1
12AE  FFE6     NOP
12B0  CFE1     MOVFF FSR1L, FSR2L
12B2  FFD9     NOP
12B4  CFE2     MOVFF FSR1H, FSR2H
12B6  FFDA     NOP
12B8  52E6     MOVF POSTINC1, F, ACCESS
12BA  52E6     MOVF POSTINC1, F, ACCESS
12BC  52E6     MOVF POSTINC1, F, ACCESS
12BE  52E6     MOVF POSTINC1, F, ACCESS
969:           {
970:           DWORD_VAL tmp;
971:           
972:           	tmp.Val = adr;
12C0  0EFC     MOVLW 0xFC
12C2  CFDB     MOVFF PLUSW2, __tmp_0
12C4  F014     NOP
12C6  0EFD     MOVLW 0xFD
12C8  CFDB     MOVFF PLUSW2, 0x15
12CA  F015     NOP
12CC  0E00     MOVLW 0x0
12CE  C014     MOVFF __tmp_0, PLUSW2
12D0  FFDB     NOP
12D2  0E01     MOVLW 0x1
12D4  C015     MOVFF 0x15, PLUSW2
12D6  FFDB     NOP
12D8  0E02     MOVLW 0x2
12DA  6ADB     CLRF PLUSW2, ACCESS
12DC  0E03     MOVLW 0x3
12DE  6ADB     CLRF PLUSW2, ACCESS
973:           	TBLPTRU = tmp.byte.UB;	
12E0  0E02     MOVLW 0x2
12E2  50DB     MOVF PLUSW2, W, ACCESS
12E4  6EF8     MOVWF TBLPTRU, ACCESS
974:              	TBLPTRH = tmp.byte.HB;
12E6  0E01     MOVLW 0x1
12E8  50DB     MOVF PLUSW2, W, ACCESS
12EA  6EF7     MOVWF TBLPTRH, ACCESS
975:              	TBLPTRL = tmp.byte.LB;
12EC  50DF     MOVF INDF2, W, ACCESS
12EE  6EF6     MOVWF TBLPTRL, ACCESS
976:           	 _asm TBLRD _endasm
12F0  0008     TBLRD*
977:           	 return TABLAT;
12F2  50F5     MOVF TABLAT, W, ACCESS
12F4  D000     BRA 0x12F6
978:           }
12F6  6E14     MOVWF __tmp_0, ACCESS
12F8  0E04     MOVLW 0x4
12FA  5CE1     SUBWF FSR1L, W, ACCESS
12FC  E202     BC 0x1302
12FE  6AE1     CLRF FSR1L, ACCESS
1300  52E5     MOVF POSTDEC1, F, ACCESS
1302  6EE1     MOVWF FSR1L, ACCESS
1304  5014     MOVF __tmp_0, W, ACCESS
1306  52E5     MOVF POSTDEC1, F, ACCESS
1308  CFE5     MOVFF POSTDEC1, FSR2H
130A  FFDA     NOP
130C  CFE7     MOVFF INDF1, FSR2L
130E  FFD9     NOP
1310  0012     RETURN 0
979:           //---------------------------------------------------------------------------
980:           
981:           void FlashWriteByte(unsigned int adr, unsigned char value)
1312  CFD9     MOVFF FSR2L, POSTINC1
1314  FFE6     NOP
1316  CFDA     MOVFF FSR2H, POSTINC1
1318  FFE6     NOP
131A  CFE1     MOVFF FSR1L, FSR2L
131C  FFD9     NOP
131E  CFE2     MOVFF FSR1H, FSR2H
1320  FFDA     NOP
1322  0E45     MOVLW 0x45
1324  24E1     ADDWF FSR1L, W, ACCESS
1326  E302     BNC 0x132C
1328  68E1     SETF FSR1L, ACCESS
132A  52E6     MOVF POSTINC1, F, ACCESS
132C  6EE1     MOVWF FSR1L, ACCESS
982:           {
983:            unsigned char i, data[EE_DLEN];
984:            DWORD_VAL tmp;
985:            
986:               for (i = 0; i < EE_DLEN; i++)           // nejdrive se ulozi aktualni obsah EE dat do RAM
132E  6ADF     CLRF INDF2, ACCESS
1330  0E40     MOVLW 0x40
1332  5CDF     SUBWF INDF2, W, ACCESS
1334  E220     BC 0x1376
1372  2ADF     INCF INDF2, F, ACCESS
1374  D7DD     BRA 0x1330
987:                 data[i] = FlashReadByte(EE_START + i); 
1336  50DF     MOVF INDF2, W, ACCESS
1338  6A17     CLRF 0x17, ACCESS
133A  0F00     ADDLW 0x0
133C  6E16     MOVWF 0x16, ACCESS
133E  0E04     MOVLW 0x4
1340  2217     ADDWFC 0x17, F, ACCESS
1342  C016     MOVFF 0x16, POSTINC1
1344  FFE6     NOP
1346  C017     MOVFF 0x17, POSTINC1
1348  FFE6     NOP
134A  DFAE     RCALL FlashReadByte
134C  52E5     MOVF POSTDEC1, F, ACCESS
134E  52E5     MOVF POSTDEC1, F, ACCESS
1350  6EE6     MOVWF POSTINC1, ACCESS
1352  50D9     MOVF FSR2L, W, ACCESS
1354  0F01     ADDLW 0x1
1356  6E14     MOVWF __tmp_0, ACCESS
1358  0E00     MOVLW 0x0
135A  20DA     ADDWFC FSR2H, W, ACCESS
135C  6E15     MOVWF 0x15, ACCESS
135E  50DF     MOVF INDF2, W, ACCESS
1360  010F     MOVLB 0xF
1362  2414     ADDWF __tmp_0, W, ACCESS
1364  6EE9     MOVWF FSR0L, ACCESS
1366  0E00     MOVLW 0x0
1368  2015     ADDWFC 0x15, W, ACCESS
136A  6EEA     MOVWF FSR0H, ACCESS
136C  52E5     MOVF POSTDEC1, F, ACCESS
136E  50E7     MOVF INDF1, W, ACCESS
1370  6EEF     MOVWF INDF0, ACCESS
988:                 
989:               data[adr - EE_START] = value;           // upravim obsah pozadovaneho bajtu
1376  50D9     MOVF FSR2L, W, ACCESS
1378  0F01     ADDLW 0x1
137A  6E14     MOVWF __tmp_0, ACCESS
137C  0E00     MOVLW 0x0
137E  20DA     ADDWFC FSR2H, W, ACCESS
1380  6E15     MOVWF 0x15, ACCESS
1382  0EFC     MOVLW 0xFC
1384  CFDB     MOVFF PLUSW2, 0x16
1386  F016     NOP
1388  0EFD     MOVLW 0xFD
138A  CFDB     MOVFF PLUSW2, 0x17
138C  F017     NOP
138E  0E00     MOVLW 0x0
1390  5E16     SUBWF 0x16, F, ACCESS
1392  0E04     MOVLW 0x4
1394  5A17     SUBWFB 0x17, F, ACCESS
1396  5014     MOVF __tmp_0, W, ACCESS
1398  2416     ADDWF 0x16, W, ACCESS
139A  6EE9     MOVWF FSR0L, ACCESS
139C  5015     MOVF 0x15, W, ACCESS
139E  2017     ADDWFC 0x17, W, ACCESS
13A0  6EEA     MOVWF FSR0H, ACCESS
13A2  0EFB     MOVLW 0xFB
13A4  CFDB     MOVFF PLUSW2, INDF0
13A6  FFEF     NOP
990:                                                       // nyni se musi smazat cely blok 1024B
991:              	tmp.Val = EE_START;
13A8  0E41     MOVLW 0x41
13AA  6ADB     CLRF PLUSW2, ACCESS
13AC  0E04     MOVLW 0x4
13AE  6EF3     MOVWF PRODL, ACCESS
13B0  0E42     MOVLW 0x42
13B2  CFF3     MOVFF PRODL, PLUSW2
13B4  FFDB     NOP
13B6  0E43     MOVLW 0x43
13B8  6ADB     CLRF PLUSW2, ACCESS
13BA  0E44     MOVLW 0x44
13BC  6ADB     CLRF PLUSW2, ACCESS
992:           	TBLPTRU = tmp.byte.UB;	
13BE  0E43     MOVLW 0x43
13C0  50DB     MOVF PLUSW2, W, ACCESS
13C2  6EF8     MOVWF TBLPTRU, ACCESS
993:              	TBLPTRH = tmp.byte.HB;
13C4  0E42     MOVLW 0x42
13C6  50DB     MOVF PLUSW2, W, ACCESS
13C8  6EF7     MOVWF TBLPTRH, ACCESS
994:              	TBLPTRL = tmp.byte.LB;
13CA  0E41     MOVLW 0x41
13CC  50DB     MOVF PLUSW2, W, ACCESS
13CE  6EF6     MOVWF TBLPTRL, ACCESS
995:               
996:               EECON1 = 0b00010100;     		        // Setup writes: FREE=1,WREN=1 (musi byt ve smycce, JINAK smaze jen JEDEN RADEK)
13D0  0E14     MOVLW 0x14
13D2  6EA6     MOVWF EECON1, ACCESS
997:               
998:               flag.EnableMemWrite = TRUE;
13D4  0103     MOVLB 0x3
13D6  8B9D     BSF 0x9D, 5, BANKED
999:               StartWrite();
13D8  DF46     RCALL StartWrite
1000:              flag.EnableMemWrite = FALSE;
13DA  0103     MOVLB 0x3
13DC  9B9D     BCF 0x9D, 5, BANKED
1001:              while (EECON1bits.WR);    		        // wait till WR bit is clear
13DE  B2A6     BTFSC EECON1, 1, ACCESS
13E0  D7FE     BRA 0x13DE
1002:              TBLPTRU = 0;            			    // forces upper byte back to 0x00
13E2  6AF8     CLRF TBLPTRU, ACCESS
1003:                                                      // --- smazano
1004:              tmp.Val = EE_START;                     // nyni zapisu upravena data zpet z RAM do Flash
13E4  0E41     MOVLW 0x41
13E6  6ADB     CLRF PLUSW2, ACCESS
13E8  0E04     MOVLW 0x4
13EA  6EF3     MOVWF PRODL, ACCESS
13EC  0E42     MOVLW 0x42
13EE  CFF3     MOVFF PRODL, PLUSW2
13F0  FFDB     NOP
13F2  0E43     MOVLW 0x43
13F4  6ADB     CLRF PLUSW2, ACCESS
13F6  0E44     MOVLW 0x44
13F8  6ADB     CLRF PLUSW2, ACCESS
1005:              
1006:              for (i = 0; i < 64; i++)	
13FA  6ADF     CLRF INDF2, ACCESS
13FC  0E40     MOVLW 0x40
13FE  5CDF     SUBWF INDF2, W, ACCESS
1400  E226     BC 0x144E
144A  2ADF     INCF INDF2, F, ACCESS
144C  D7D7     BRA 0x13FC
1007:          	{
1008:          		TBLPTRU = tmp.byte.UB;	            // adresa
1402  0E43     MOVLW 0x43
1404  50DB     MOVF PLUSW2, W, ACCESS
1406  6EF8     MOVWF TBLPTRU, ACCESS
1009:             	    TBLPTRH = tmp.byte.HB;
1408  0E42     MOVLW 0x42
140A  50DB     MOVF PLUSW2, W, ACCESS
140C  6EF7     MOVWF TBLPTRH, ACCESS
1010:             	    TBLPTRL = tmp.byte.LB;
140E  0E41     MOVLW 0x41
1410  50DB     MOVF PLUSW2, W, ACCESS
1412  6EF6     MOVWF TBLPTRL, ACCESS
1011:                 	
1012:                 	TABLAT = data[i];			        // hodnota
1414  50D9     MOVF FSR2L, W, ACCESS
1416  0F01     ADDLW 0x1
1418  6E14     MOVWF __tmp_0, ACCESS
141A  0E00     MOVLW 0x0
141C  20DA     ADDWFC FSR2H, W, ACCESS
141E  6E15     MOVWF 0x15, ACCESS
1420  50DF     MOVF INDF2, W, ACCESS
1422  010F     MOVLB 0xF
1424  2414     ADDWF __tmp_0, W, ACCESS
1426  6EE9     MOVWF FSR0L, ACCESS
1428  0E00     MOVLW 0x0
142A  2015     ADDWFC 0x15, W, ACCESS
142C  6EEA     MOVWF FSR0H, ACCESS
142E  50EF     MOVF INDF0, W, ACCESS
1430  6EF5     MOVWF TABLAT, ACCESS
1013:          
1014:          		_asm TBLWT _endasm
1432  000C     TBLWT*
1015:          		
1016:          		tmp.Val++;				            // increment adresy
1434  50D9     MOVF FSR2L, W, ACCESS
1436  0F41     ADDLW 0x41
1438  6EE9     MOVWF FSR0L, ACCESS
143A  0E00     MOVLW 0x0
143C  20DA     ADDWFC FSR2H, W, ACCESS
143E  6EEA     MOVWF FSR0H, ACCESS
1440  2AEE     INCF POSTINC0, F, ACCESS
1442  0E00     MOVLW 0x0
1444  22EE     ADDWFC POSTINC0, F, ACCESS
1446  22EE     ADDWFC POSTINC0, F, ACCESS
1448  22EE     ADDWFC POSTINC0, F, ACCESS
1017:          	}
1018:          	
1019:          	flag.EnableMemWrite = TRUE;
144E  0103     MOVLB 0x3
1450  8B9D     BSF 0x9D, 5, BANKED
1020:              StartWrite();
1452  DF09     RCALL StartWrite
1021:              flag.EnableMemWrite = FALSE;
1454  0103     MOVLB 0x3
1456  9B9D     BCF 0x9D, 5, BANKED
1022:          	while (EECON1bits.WR);    		        // wait till WR bit is clear	    
1458  B2A6     BTFSC EECON1, 1, ACCESS
145A  D7FE     BRA 0x1458
1023:          }
145C  0E45     MOVLW 0x45
145E  5CE1     SUBWF FSR1L, W, ACCESS
1460  E202     BC 0x1466
1462  6AE1     CLRF FSR1L, ACCESS
1464  52E5     MOVF POSTDEC1, F, ACCESS
1466  6EE1     MOVWF FSR1L, ACCESS
1468  52E5     MOVF POSTDEC1, F, ACCESS
146A  CFE5     MOVFF POSTDEC1, FSR2H
146C  FFDA     NOP
146E  CFE7     MOVFF INDF1, FSR2L
1470  FFD9     NOP
1472  0012     RETURN 0
1024:          //---------------------------------------------------------------------------
1025:          
1026:          // factory setting of emul. EEPROM
1027:          void DefaultEepromInit(void)	
1028:          {
1029:          	FlashWriteByte(EE_ADR_USB_MODE, 0);                 // 0 - Custom mode, 1 - CDC mode
1474  6AE6     CLRF POSTINC1, ACCESS
1476  0E02     MOVLW 0x2
1478  D8CD     RCALL __pa_12
1614  6EE6     MOVWF POSTINC1, ACCESS
1616  0E04     MOVLW 0x4
1618  6EE6     MOVWF POSTINC1, ACCESS
161A  DE7B     RCALL FlashWriteByte
161C  52E5     MOVF POSTDEC1, F, ACCESS
161E  52E5     MOVF POSTDEC1, F, ACCESS
1620  52E5     MOVF POSTDEC1, F, ACCESS
1622  0012     RETURN 0
1030:          	
1031:          	FlashWriteByte(EE_ADR_CONFIG, EEPROM_HAS_CONFIG);   // the EEPROM contains GW settings
147A  0E33     MOVLW 0x33
147C  6EE6     MOVWF POSTINC1, ACCESS
147E  0E01     MOVLW 0x1
1480  EF0A     GOTO 0x1614
1482  F00B     NOP
1032:          }
1033:          //---------------------------------------------------------------------------
1034:          
1035:          // GW init. from emul. EEPROM
1036:          void GwConfigFromEeprom(void)	
1037:          {
1038:           	flag.CDC_mode = FlashReadByte(EE_ADR_USB_MODE);     // USB mode
1484  0E02     MOVLW 0x2
1486  6EE6     MOVWF POSTINC1, ACCESS
1488  0E04     MOVLW 0x4
148A  6EE6     MOVWF POSTINC1, ACCESS
148C  DF0D     RCALL FlashReadByte
148E  52E5     MOVF POSTDEC1, F, ACCESS
1490  52E5     MOVF POSTDEC1, F, ACCESS
1492  0103     MOVLB 0x3
1494  959D     BCF 0x9D, 2, BANKED
1496  B0E8     BTFSC WREG, 0, ACCESS
1498  859D     BSF 0x9D, 2, BANKED
1039:          }
149A  0012     RETURN 0
1040:          //---------------------------------------------------------------------------
1041:          
1042:          unsigned char ByteToHex(unsigned char val)
149C  D857     RCALL __pa_1
1043:          {
1044:          	switch(val)
149E  0EFD     MOVLW 0xFD
14A0  50DB     MOVF PLUSW2, W, ACCESS
14A2  0A0F     XORLW 0xF
14A4  E03C     BZ 0x151E
14A6  0A01     XORLW 0x1
14A8  E038     BZ 0x151A
14AA  0A03     XORLW 0x3
14AC  E034     BZ 0x1516
14AE  0A01     XORLW 0x1
14B0  E030     BZ 0x1512
14B2  0A07     XORLW 0x7
14B4  E02C     BZ 0x150E
14B6  0A01     XORLW 0x1
14B8  E028     BZ 0x150A
14BA  0A03     XORLW 0x3
14BC  E024     BZ 0x1506
14BE  0A01     XORLW 0x1
14C0  E020     BZ 0x1502
14C2  0A0F     XORLW 0xF
14C4  E01C     BZ 0x14FE
14C6  0A01     XORLW 0x1
14C8  E018     BZ 0x14FA
14CA  0A03     XORLW 0x3
14CC  E014     BZ 0x14F6
14CE  0A01     XORLW 0x1
14D0  E010     BZ 0x14F2
14D2  0A07     XORLW 0x7
14D4  E00C     BZ 0x14EE
14D6  0A01     XORLW 0x1
14D8  E008     BZ 0x14EA
14DA  0A03     XORLW 0x3
14DC  E004     BZ 0x14E6
14DE  0A01     XORLW 0x1
14E0  E11F     BNZ 0x1520
1045:          	{
1046:          		case 0:  return('0');
14E2  0E30     MOVLW 0x30
14E4  D01D     BRA 0x1520
1047:          		case 1:  return('1');
14E6  0E31     MOVLW 0x31
14E8  D01B     BRA 0x1520
1048:          		case 2:  return('2');
14EA  0E32     MOVLW 0x32
14EC  D019     BRA 0x1520
1049:          		case 3:  return('3');
14EE  0E33     MOVLW 0x33
14F0  D017     BRA 0x1520
1050:          		case 4:  return('4');
14F2  0E34     MOVLW 0x34
14F4  D015     BRA 0x1520
1051:          		case 5:  return('5');
14F6  0E35     MOVLW 0x35
14F8  D013     BRA 0x1520
1052:          		case 6:  return('6');
14FA  0E36     MOVLW 0x36
14FC  D011     BRA 0x1520
1053:          		case 7:  return('7');
14FE  0E37     MOVLW 0x37
1500  D00F     BRA 0x1520
1054:          		case 8:  return('8');
1502  0E38     MOVLW 0x38
1504  D00D     BRA 0x1520
1055:          		case 9:  return('9');
1506  0E39     MOVLW 0x39
1508  D00B     BRA 0x1520
1056:          		case 10: return('A');
150A  0E41     MOVLW 0x41
150C  D009     BRA 0x1520
1057:          		case 11: return('B');
150E  0E42     MOVLW 0x42
1510  D007     BRA 0x1520
1058:          		case 12: return('C');
1512  0E43     MOVLW 0x43
1514  D005     BRA 0x1520
1059:          		case 13: return('D');
1516  0E44     MOVLW 0x44
1518  D003     BRA 0x1520
1060:          		case 14: return('E');
151A  0E45     MOVLW 0x45
151C  D001     BRA 0x1520
1061:          		case 15: return('F');
151E  0E46     MOVLW 0x46
1062:          	}
1063:          }
1520  D03A     BRA __pa_4
1596  52E5     MOVF POSTDEC1, F, ACCESS
1598  CFE5     MOVFF POSTDEC1, FSR2H
159A  FFDA     NOP
159C  CFE7     MOVFF INDF1, FSR2L
159E  FFD9     NOP
15A0  0012     RETURN 0
1064:          //---------------------------------------------------------------------------
---  E:/projects/CK-USB-04A/001/pic_apl/main.c  ---------------------------------------------------------
1:             /********************************************************************
2:              FileName:		main.c
3:              Dependencies:	See INCLUDES section
4:              Processor:		PIC18 or PIC24 USB Microcontrollers
5:              Hardware:		The code is natively intended to be used on the following
6:              				hardware platforms: PICDEM? FS USB Demo Board, 
7:              				PIC18F87J50 FS USB Plug-In Module, or
8:              				Explorer 16 + PIC24 USB PIM.  The firmware may be
9:              				modified for use on other USB platforms by editing the
10:             				HardwareProfile.h file.
11:             Complier:  	Microchip C18 (for PIC18) or C30 (for PIC24)
12:             Company:		Microchip Technology, Inc.
13:            
14:             Software License Agreement:
15:            
16:             The software supplied herewith by Microchip Technology Incorporated
17:             (the ?Company?) for its PIC Microcontroller is intended and
18:             supplied to you, the Company?s customer, for use solely and
19:             exclusively on Microchip PIC Microcontroller products. The
20:             software is owned by the Company and/or its supplier, and is
21:             protected under applicable copyright laws. All rights are reserved.
22:             Any use in violation of the foregoing restrictions may subject the
23:             user to criminal sanctions under applicable laws, as well as to
24:             civil liability for the breach of the terms and conditions of this
25:             license.
26:            
27:             THIS SOFTWARE IS PROVIDED IN AN ?AS IS? CONDITION. NO WARRANTIES,
28:             WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
29:             TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
30:             PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
31:             IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
32:             CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
33:            
34:            ********************************************************************
35:             File Description:
36:            
37:             Change History:
38:              Rev   Date         Description
39:              1.0   11/19/2004   Initial release
40:              2.1   02/26/2007   Updated for simplicity and to use common
41:                                 coding style
42:            ********************************************************************/
43:            
44:            /** INCLUDES *******************************************************/
45:            #include "Compiler.h"
46:            #include "HardwareProfile.h"
47:            #include "GenericTypeDefs.h"
48:            #include "USB/usb_device.h"
49:            #include "USB/usb.h"
50:            #include "USB/usb_function_generic.h"
51:            #include "USB/usb_function_cdc.h"
52:            #include "usb_config.h"
53:            #include "user.h"                           // Modifiable
54:            
55:            /** CONFIGURATION **************************************************/
56:             #pragma config WDTEN = OFF                 //WDT disabled (enabled by SWDTEN bit)
57:             #pragma config PLLDIV = 2                  //Divide by 2 (8 MHz oscillator input)
58:             #pragma config STVREN = ON                 //stack overflow/underflow reset enabled
59:             #pragma config XINST = OFF                 //Extended instruction set disabled
60:             #pragma config CPUDIV = OSC1	            //No CPU system clock divide
61:             #pragma config CP0 = OFF                   //Program memory is not code-protected
62:             #pragma config OSC = INTOSCPLL             //HS oscillator, PLL enabled, HSPLL used by USB
63:             #pragma config FCMEN = OFF                 //Fail-Safe Clock Monitor disabled
64:             #pragma config IESO = OFF                  //Two-Speed Start-up disabled
65:             #pragma config WDTPS = 32768               //1:32768
66:             #pragma config DSWDTOSC = INTOSCREF        //DSWDT uses INTOSC/INTRC as clock
67:             #pragma config RTCOSC = INTOSCREF	        //RTCC uses T1OSC/T1CKI as clock
68:             #pragma config DSBOREN = OFF               //Zero-Power BOR disabled in Deep Sleep
69:             #pragma config DSWDTEN = OFF               //Disabled
70:             #pragma config DSWDTPS = 8192              //1:8,192 (8.5 seconds)
71:             #pragma config IOL1WAY = ON                //The IOLOCK bit (PPSCON<0>) can be set once 
72:             #pragma config MSSP7B_EN = MSK7            //7 Bit address masking
73:             #pragma config WPFP = PAGE_1               //Write Protect Program Flash Page 0
74:             #pragma config WPEND = PAGE_0              //Start protection at page 0
75:             #pragma config WPCFG = OFF                 //Write/Erase last page protect Disabled
76:             #pragma config WPDIS = OFF                 //WPFP[5:0], WPEND, and WPCFG bits ignored 
77:             #pragma config T1DIG = ON                  //Sec Osc clock source may be selected
78:             #pragma config LPT1OSC = OFF               //high power Timer1 mode
79:            
80:            
81:            /** VARIABLES ******************************************************/
82:            #pragma udata
83:            extern USB_HANDLE USBGenericOutHandle;
84:            extern USB_HANDLE USBGenericInHandle;
85:            extern DATA_PACKET INPacket;
86:            extern DATA_PACKET OUTPacket;
87:            
88:            /** PRIVATE PROTOTYPES *********************************************/
89:            static void InitializeSystem(void);
90:            void USBDeviceTasks(void);
91:            void YourHighPriorityISRCode(void);
92:            void YourLowPriorityISRCode(void);
93:            
94:            
95:            /** VECTOR REMAPPING ***********************************************/
96:            #if defined(__18CXX)
97:            	
98:            	#if defined(WITH_BOOTLOADER)
99:            		#define REMAPPED_RESET_VECTOR_ADDRESS		0x81A
100:           		#define REMAPPED_HIGH_INTERRUPT_VECTOR_ADDRESS	0x800
101:           		#define REMAPPED_LOW_INTERRUPT_VECTOR_ADDRESS	0x80A
102:           	#else
103:           		#define REMAPPED_RESET_VECTOR_ADDRESS		0x00
104:           		#define REMAPPED_HIGH_INTERRUPT_VECTOR_ADDRESS	0x08
105:           		#define REMAPPED_LOW_INTERRUPT_VECTOR_ADDRESS	0x18
106:           	#endif
107:           	
108:           	#if defined(WITH_BOOTLOADER)
109:           		extern void _startup (void);        // See c018i.c in your C18 compiler dir
110:           		
111:           		#pragma code REMAPPED_RESET_VECTOR = 0x1C1A
112:           		void _reset (void)
113:           		{
114:           		    _asm goto _startup _endasm
1C1A  EF3F     GOTO 0x2C7E
1C1C  F016     NOP
115:           		}
1C1E  0012     RETURN 0
116:           	#endif
117:           	
118:           	#pragma code REMAPPED_HIGH_INTERRUPT_VECTOR = REMAPPED_HIGH_INTERRUPT_VECTOR_ADDRESS
119:           	void Remapped_High_ISR (void)
120:           	{
121:           	     _asm goto YourHighPriorityISRCode _endasm
0800  EF5B     GOTO 0x1AB6
0802  F00D     NOP
122:           	}
0804  0012     RETURN 0
123:           	#pragma code REMAPPED_LOW_INTERRUPT_VECTOR = REMAPPED_LOW_INTERRUPT_VECTOR_ADDRESS
124:           	void Remapped_Low_ISR (void)
125:           	{
126:           	     _asm goto YourLowPriorityISRCode _endasm
080A  EFA8     GOTO 0x1B50
080C  F00D     NOP
127:           	}
080E  0012     RETURN 0
128:           	
129:           ////	#if defined(WITH_BOOTLOADER)
130:           //	#if defined(PROGRAMMABLE_WITH_USB_HID_BOOTLOADER)||defined(PROGRAMMABLE_WITH_USB_MCHPUSB_BOOTLOADER)
131:           //	//Note: If this project is built while one of the bootloaders has
132:           //	//been defined, but then the output hex file is not programmed with
133:           //	//the bootloader, addresses 0x08 and 0x18 would end up programmed with 0xFFFF.
134:           //	//As a result, if an actual interrupt was enabled and occured, the PC would jump
135:           //	//to 0x08 (or 0x18) and would begin executing "0xFFFF" (unprogrammed space).  This
136:           //	//executes as nop instructions, but the PC would eventually reach the REMAPPED_RESET_VECTOR_ADDRESS
137:           //	//(0x1000 or 0x800, depending upon bootloader), and would execute the "goto _startup".  This
138:           //	//would effective reset the application.
139:           //	
140:           //	//To fix this situation, we should always deliberately place a 
141:           //	//"goto REMAPPED_HIGH_INTERRUPT_VECTOR_ADDRESS" at address 0x08, and a
142:           //	//"goto REMAPPED_LOW_INTERRUPT_VECTOR_ADDRESS" at address 0x18.  When the output
143:           //	//hex file of this project is programmed with the bootloader, these sections do not
144:           //	//get bootloaded (as they overlap the bootloader space).  If the output hex file is not
145:           //	//programmed using the bootloader, then the below goto instructions do get programmed,
146:           //	//and the hex file still works like normal.  The below section is only required to fix this
147:           //	//scenario.
148:           //	#pragma code HIGH_INTERRUPT_VECTOR = 0x08
149:           //	void High_ISR (void)
150:           //	{
151:           //	     _asm goto REMAPPED_HIGH_INTERRUPT_VECTOR_ADDRESS _endasm
152:           //	}
153:           //	#pragma code LOW_INTERRUPT_VECTOR = 0x18
154:           //	void Low_ISR (void)
155:           //	{
156:           //	     _asm goto REMAPPED_LOW_INTERRUPT_VECTOR_ADDRESS _endasm
157:           //	}
158:           //	#endif	//end of "#if defined(PROGRAMMABLE_WITH_USB_HID_BOOTLOADER)||defined(PROGRAMMABLE_WITH_USB_LEGACY_CUSTOM_CLASS_BOOTLOADER)"
159:           
160:           	#pragma code
161:           	
162:           	
163:           	//These are your actual interrupt handling routines.
164:           	#pragma interrupt YourHighPriorityISRCode
165:           	void YourHighPriorityISRCode()
1AB6  CFE9     MOVFF FSR0L, PREINC1
1AB8  FFE4     NOP
1ABA  CFEA     MOVFF FSR0H, PREINC1
1ABC  FFE4     NOP
1ABE  CFF6     MOVFF TBLPTRL, PREINC1
1AC0  FFE4     NOP
1AC2  CFF7     MOVFF TBLPTRH, PREINC1
1AC4  FFE4     NOP
1AC6  CFF8     MOVFF TBLPTRU, PREINC1
1AC8  FFE4     NOP
1ACA  CFF5     MOVFF TABLAT, PREINC1
1ACC  FFE4     NOP
1ACE  CFF3     MOVFF PRODL, PREINC1
1AD0  FFE4     NOP
1AD2  CFF4     MOVFF PRODH, PREINC1
1AD4  FFE4     NOP
1AD6  CFFA     MOVFF PCLATH, PREINC1
1AD8  FFE4     NOP
1ADA  CFFB     MOVFF PCLATU, PREINC1
1ADC  FFE4     NOP
1ADE  EE00     LFSR 0, 0x0
1AE0  F000     NOP
1AE2  0E14     MOVLW 0x14
1AE4  04E8     DECF WREG, W, ACCESS
1AE6  E303     BNC 0x1AEE
1AE8  CFEE     MOVFF POSTINC0, PREINC1
1AEA  FFE4     NOP
1AEC  D7FB     BRA 0x1AE4
1AEE  EE00     LFSR 0, 0x14
1AF0  F014     NOP
1AF2  0E08     MOVLW 0x8
1AF4  04E8     DECF WREG, W, ACCESS
1AF6  E303     BNC 0x1AFE
1AF8  CFEE     MOVFF POSTINC0, PREINC1
1AFA  FFE4     NOP
1AFC  D7FB     BRA 0x1AF4
1AFE  52E6     MOVF POSTINC1, F, ACCESS
166:           	{
167:           		//Check which interrupt flag caused the interrupt.
168:           		//Service the interrupt
169:           		//Clear the interrupt flag
170:           		//Etc.
171:           
172:           		T4_Intr();		// Tick
1B00  ECA2     CALL 0x1144, 0
1B02  F008     NOP
173:           
174:           	}	//This return will be a "retfie fast", since this is in a #pragma interrupt section 
1B04  52E5     MOVF POSTDEC1, F, ACCESS
1B06  EE00     LFSR 0, 0x1B
1B08  F01B     NOP
1B0A  0E08     MOVLW 0x8
1B0C  04E8     DECF WREG, W, ACCESS
1B0E  E303     BNC 0x1B16
1B10  CFE5     MOVFF POSTDEC1, POSTDEC0
1B12  FFED     NOP
1B14  D7FB     BRA 0x1B0C
1B16  EE00     LFSR 0, 0x13
1B18  F013     NOP
1B1A  0E14     MOVLW 0x14
1B1C  04E8     DECF WREG, W, ACCESS
1B1E  E303     BNC 0x1B26
1B20  CFE5     MOVFF POSTDEC1, POSTDEC0
1B22  FFED     NOP
1B24  D7FB     BRA 0x1B1C
1B26  CFE5     MOVFF POSTDEC1, PCLATU
1B28  FFFB     NOP
1B2A  CFE5     MOVFF POSTDEC1, PCLATH
1B2C  FFFA     NOP
1B2E  CFE5     MOVFF POSTDEC1, PRODH
1B30  FFF4     NOP
1B32  CFE5     MOVFF POSTDEC1, PRODL
1B34  FFF3     NOP
1B36  CFE5     MOVFF POSTDEC1, TABLAT
1B38  FFF5     NOP
1B3A  CFE5     MOVFF POSTDEC1, TBLPTRU
1B3C  FFF8     NOP
1B3E  CFE5     MOVFF POSTDEC1, TBLPTRH
1B40  FFF7     NOP
1B42  CFE5     MOVFF POSTDEC1, TBLPTRL
1B44  FFF6     NOP
1B46  CFE5     MOVFF POSTDEC1, FSR0H
1B48  FFEA     NOP
1B4A  CFE5     MOVFF POSTDEC1, FSR0L
1B4C  FFE9     NOP
1B4E  0011     RETFIE 1
175:           	#pragma interruptlow YourLowPriorityISRCode
176:           	void YourLowPriorityISRCode()
1B50  CFD8     MOVFF STATUS, PREINC1
1B52  FFE4     NOP
1B54  CFE0     MOVFF BSR, PREINC1
1B56  FFE4     NOP
1B58  6EE4     MOVWF PREINC1, ACCESS
1B5A  52E6     MOVF POSTINC1, F, ACCESS
177:           	{
178:           		//Check which interrupt flag caused the interrupt.
179:           		//Service the interrupt
180:           		//Clear the interrupt flag
181:           		//Etc.
182:           	
183:           	}	//This return will be a "retfie", since this is in a #pragma interruptlow section 
1B5C  52E5     MOVF POSTDEC1, F, ACCESS
1B5E  50E5     MOVF POSTDEC1, W, ACCESS
1B60  CFE5     MOVFF POSTDEC1, BSR
1B62  FFE0     NOP
1B64  CFE5     MOVFF POSTDEC1, STATUS
1B66  FFD8     NOP
1B68  0010     RETFIE 0
184:           
185:           #endif //of "#if defined(__18CXX)"
186:           
187:           
188:           
189:           
190:           /** DECLARATIONS ***************************************************/
191:           #pragma code
192:           
193:           /******************************************************************************
194:            * Function:        void main(void)
195:            *
196:            * PreCondition:    None
197:            *
198:            * Input:           None
199:            *
200:            * Output:          None
201:            *
202:            * Side Effects:    None
203:            *
204:            * Overview:        Main program entry point.
205:            *
206:            * Note:            None
207:            *******************************************************************/
208:           
209:           #if defined(__18CXX)
210:           void main(void)
211:           #else
212:           int main(void)
213:           #endif
214:           { 
215:               InitializeSystem();
1B6A  D805     RCALL InitializeSystem
216:               
217:               while(1)
1B74  D7FB     BRA 0x1B6C
218:               {
219:           		// Check bus status and service USB interrupts.
220:                   USBDeviceTasks(); // Interrupt or polling method.  If using polling, must call
1B6C  EC4E     CALL 0x1C9C, 0
1B6E  F00E     NOP
221:                   				  // this function periodically.  This function will take care
222:                   				  // of processing and responding to SETUP transactions 
223:                   				  // (such as during the enumeration process when you first
224:                   				  // plug in).  USB hosts require that USB devices should accept
225:                   				  // and process SETUP packets in a timely fashion.  Therefore,
226:                   				  // when using polling, this function should be called 
227:                   				  // frequently (such as once about every 100 microseconds) at any
228:                   				  // time that a SETUP packet might reasonably be expected to
229:                   				  // be sent by the host to your device.  In most cases, the
230:                   				  // USBDeviceTasks() function does not take very long to
231:                   				  // execute (~50 instruction cycles) before it returns.
232:           
233:           		// Application-specific tasks.
234:           		// Application related code may be added here, or in the ProcessIO() function.
235:                   ProcessIO();        
1B70  ECB2     CALL 0x964, 0
1B72  F004     NOP
236:               }//end while
237:           }//end main
238:           
239:           
240:           /********************************************************************
241:            * Function:        static void InitializeSystem(void)
242:            *
243:            * PreCondition:    None
244:            *
245:            * Input:           None
246:            *
247:            * Output:          None
248:            *
249:            * Side Effects:    None
250:            *
251:            * Overview:        InitializeSystem is a centralize initialization
252:            *                  routine. All required USB initialization routines
253:            *                  are called from here.
254:            *
255:            *                  User application initialization routine should
256:            *                  also be called from here.                  
257:            *
258:            * Note:            None
259:            *******************************************************************/
260:           static void InitializeSystem(void)
261:           { 
262:               
263:           #if !defined (WITH_BOOTLOADER)                  // je to jiz v BL    
264:                unsigned int pll_startup_counter = 600;
265:           
266:           	ADCON0 = 0x00;                 
267:           	ADCON1 = 0x00;                 
268:           	ANCON0 = 0xFF;
269:           	ANCON1 = 0x1F;
270:                            
271:                  
272:           	OSCTUNEbits.PLLEN = 1;  //Enable the PLL and wait 2+ms until the PLL locks before enabling USB module
273:               while(pll_startup_counter--);
274:           #endif
275:           
276:           
277:           //	The USB specifications require that USB peripheral devices must never source
278:           //	current onto the Vbus pin.  Additionally, USB peripherals should not source
279:           //	current on D+ or D- when the host/hub is not actively powering the Vbus line.
280:           //	When designing a self powered (as opposed to bus powered) USB peripheral
281:           //	device, the firmware should make sure not to turn on the USB module and D+
282:           //	or D- pull up resistor unless Vbus is actively powered.  Therefore, the
283:           //	firmware needs some means to detect when Vbus is being powered by the host.
284:           //	A 5V tolerant I/O pin can be connected to Vbus (through a resistor), and
285:           // 	can be used to detect when Vbus is high (host actively powering), or low
286:           //	(host is shut down or otherwise not supplying power).  The USB firmware
287:           // 	can then periodically poll this I/O pin to know when it is okay to turn on
288:           //	the USB module/D+/D- pull up resistor.  When designing a purely bus powered
289:           //	peripheral device, it is not possible to source current on D+ or D- when the
290:           //	host is not actively providing power on Vbus. Therefore, implementing this
291:           //	bus sense feature is optional.  This firmware can be made to use this bus
292:           //	sense feature by making sure "USE_USB_BUS_SENSE_IO" has been defined in the
293:           //	HardwareProfile.h file.    
294:               #if defined(USE_USB_BUS_SENSE_IO)
295:               tris_usb_bus_sense = INPUT_PIN; // See HardwareProfile.h
296:               #endif
297:               
298:           //	If the host PC sends a GetStatus (device) request, the firmware must respond
299:           //	and let the host know if the USB peripheral device is currently bus powered
300:           //	or self powered.  See chapter 9 in the official USB specifications for details
301:           //	regarding this request.  If the peripheral device is capable of being both
302:           //	self and bus powered, it should not return a hard coded value for this request.
303:           //	Instead, firmware should check if it is currently self or bus powered, and
304:           //	respond accordingly.  If the hardware has been configured like demonstrated
305:           //	on the PICDEM FS USB Demo Board, an I/O pin can be polled to determine the
306:           //	currently selected power source.  On the PICDEM FS USB Demo Board, "RA2" 
307:           //	is used for	this purpose.  If using this feature, make sure "USE_SELF_POWER_SENSE_IO"
308:           //	has been defined in HardwareProfile.h, and that an appropriate I/O pin has been mapped
309:           //	to it in HardwareProfile.h.
310:               #if defined(USE_SELF_POWER_SENSE_IO)
311:               tris_self_power = INPUT_PIN;	// See HardwareProfile.h
312:               #endif
313:               UserInit();
1B76  EC14     CALL 0x828, 0
1B78  F004     NOP
314:               USBDeviceInit();	//usb_device.c.  Initializes USB module SFRs and firmware
1B7A  EF10     GOTO 0x1C20
1B7C  F00E     NOP
315:               					//variables to known states.
316:               
317:           //PortG.7=0;
318:               
319:           
320:           }//end InitializeSystem
321:           
322:           // ******************************************************************************************************
323:           // ************** USB Callback Functions ****************************************************************
324:           // ******************************************************************************************************
325:           // The USB firmware stack will call the callback functions USBCBxxx() in response to certain USB related
326:           // events.  For example, if the host PC is powering down, it will stop sending out Start of Frame (SOF)
327:           // packets to your device.  In response to this, all USB devices are supposed to decrease their power
328:           // consumption from the USB Vbus to <2.5mA each.  The USB module detects this condition (which according
329:           // to the USB specifications is 3+ms of no bus activity/SOF packets) and then calls the USBCBSuspend()
330:           // function.  You should modify these callback functions to take appropriate actions for each of these
331:           // conditions.  For example, in the USBCBSuspend(), you may wish to add code that will decrease power
332:           // consumption from Vbus to <2.5mA (such as by clock switching, turning off LEDs, putting the
333:           // microcontroller to sleep, etc.).  Then, in the USBCBWakeFromSuspend() function, you may then wish to
334:           // add code that undoes the power saving things done in the USBCBSuspend() function.
335:           
336:           // The USBCBSendResume() function is special, in that the USB stack will not automatically call this
337:           // function.  This function is meant to be called from the application firmware instead.  See the
338:           // additional comments near the function.
339:           
340:           /******************************************************************************
341:            * Function:        void USBCBSuspend(void)
342:            *
343:            * PreCondition:    None
344:            *
345:            * Input:           None
346:            *
347:            * Output:          None
348:            *
349:            * Side Effects:    None
350:            *
351:            * Overview:        Call back that is invoked when a USB suspend is detected
352:            *
353:            * Note:            None
354:            *****************************************************************************/
355:           void USBCBSuspend(void)
356:           {
357:           	//Example power saving code.  Insert appropriate code here for the desired
358:           	//application behavior.  If the microcontroller will be put to sleep, a
359:           	//process similar to that shown below may be used:
360:           	
361:           	//ConfigureIOPinsForLowPower();
362:           	//SaveStateOfAllInterruptEnableBits();
363:           	//DisableAllInterruptEnableBits();
364:           	//EnableOnlyTheInterruptsWhichWillBeUsedToWakeTheMicro();	//should enable at least USBActivityIF as a wake source
365:           	//Sleep();
366:           	//RestoreStateOfAllPreviouslySavedInterruptEnableBits();	//Preferrably, this should be done in the USBCBWakeFromSuspend() function instead.
367:           	//RestoreIOPinsToNormal();									//Preferrably, this should be done in the USBCBWakeFromSuspend() function instead.
368:           
369:           	//IMPORTANT NOTE: Do not clear the USBActivityIF (ACTVIF) bit here.  This bit is 
370:           	//cleared inside the usb_device.c file.  Clearing USBActivityIF here will cause 
371:           	//things to not work as intended.	
372:           	
373:           
374:               #if defined(__C30__)
375:               #if 0
376:                   U1EIR = 0xFFFF;
377:                   U1IR = 0xFFFF;
378:                   U1OTGIR = 0xFFFF;
379:                   IFS5bits.USB1IF = 0;
380:                   IEC5bits.USB1IE = 1;
381:                   U1OTGIEbits.ACTVIE = 1;
382:                   U1OTGIRbits.ACTVIF = 1;
383:                   TRISA &= 0xFF3F;
384:                   LATAbits.LATA6 = 1;
385:                   Sleep();
386:                   LATAbits.LATA6 = 0;
387:               #endif
388:               #endif
389:           }
1B7E  0012     RETURN 0
390:           
391:           
392:           /******************************************************************************
393:            * Function:        void _USB1Interrupt(void)
394:            *
395:            * PreCondition:    None
396:            *
397:            * Input:           None
398:            *
399:            * Output:          None
400:            *
401:            * Side Effects:    None
402:            *
403:            * Overview:        This function is called when the USB interrupt bit is set
404:            *					In this example the interrupt is only used when the device
405:            *					goes to sleep when it receives a USB suspend command
406:            *
407:            * Note:            None
408:            *****************************************************************************/
409:           #if 0
410:           void __attribute__ ((interrupt)) _USB1Interrupt(void)
411:           {
412:               #if !defined(self_powered)
413:                   if(U1OTGIRbits.ACTVIF)
414:                   {
415:                       LATAbits.LATA7 = 1;
416:           
417:                       IEC5bits.USB1IE = 0;
418:                       U1OTGIEbits.ACTVIE = 0;
419:                       IFS5bits.USB1IF = 0;
420:                   
421:                       //USBClearInterruptFlag(USBActivityIFReg,USBActivityIFBitNum);
422:                       USBClearInterruptFlag(USBIdleIFReg,USBIdleIFBitNum);
423:                       //USBSuspendControl = 0;
424:                       LATAbits.LATA7 = 0;
425:                   }
426:               #endif
427:           }
428:           #endif
429:           
430:           /******************************************************************************
431:            * Function:        void USBCBWakeFromSuspend(void)
432:            *
433:            * PreCondition:    None
434:            *
435:            * Input:           None
436:            *
437:            * Output:          None
438:            *
439:            * Side Effects:    None
440:            *
441:            * Overview:        The host may put USB peripheral devices in low power
442:            *					suspend mode (by "sending" 3+ms of idle).  Once in suspend
443:            *					mode, the host may wake the device back up by sending non-
444:            *					idle state signalling.
445:            *					
446:            *					This call back is invoked when a wakeup from USB suspend 
447:            *					is detected.
448:            *
449:            * Note:            None
450:            *****************************************************************************/
451:           void USBCBWakeFromSuspend(void)
452:           {
453:           	// If clock switching or other power savings measures were taken when
454:           	// executing the USBCBSuspend() function, now would be a good time to
455:           	// switch back to normal full power run mode conditions.  The host allows
456:           	// a few milliseconds of wakeup time, after which the device must be 
457:           	// fully back to normal, and capable of receiving and processing USB
458:           	// packets.  In order to do this, the USB module must receive proper
459:           	// clocking (IE: 48MHz clock must be available to SIE for full speed USB
460:           	// operation).
461:           }
1B80  0012     RETURN 0
462:           
463:           /********************************************************************
464:            * Function:        void USBCB_SOF_Handler(void)
465:            *
466:            * PreCondition:    None
467:            *
468:            * Input:           None
469:            *
470:            * Output:          None
471:            *
472:            * Side Effects:    None
473:            *
474:            * Overview:        The USB host sends out a SOF packet to full-speed
475:            *                  devices every 1 ms. This interrupt may be useful
476:            *                  for isochronous pipes. End designers should
477:            *                  implement callback routine as necessary.
478:            *
479:            * Note:            None
480:            *******************************************************************/
481:           void USBCB_SOF_Handler(void)
482:           {
483:               // No need to clear UIRbits.SOFIF to 0 here.
484:               // Callback caller is already doing that.
485:           }
1B82  0012     RETURN 0
486:           
487:           /*******************************************************************
488:            * Function:        void USBCBErrorHandler(void)
489:            *
490:            * PreCondition:    None
491:            *
492:            * Input:           None
493:            *
494:            * Output:          None
495:            *
496:            * Side Effects:    None
497:            *
498:            * Overview:        The purpose of this callback is mainly for
499:            *                  debugging during development. Check UEIR to see
500:            *                  which error causes the interrupt.
501:            *
502:            * Note:            None
503:            *******************************************************************/
504:           void USBCBErrorHandler(void)
505:           {
506:               // No need to clear UEIR to 0 here.
507:               // Callback caller is already doing that.
508:           
509:           	// Typically, user firmware does not need to do anything special
510:           	// if a USB error occurs.  For example, if the host sends an OUT
511:           	// packet to your device, but the packet gets corrupted (ex:
512:           	// because of a bad connection, or the user unplugs the
513:           	// USB cable during the transmission) this will typically set
514:           	// one or more USB error interrupt flags.  Nothing specific
515:           	// needs to be done however, since the SIE will automatically
516:           	// send a "NAK" packet to the host.  In response to this, the
517:           	// host will normally retry to send the packet again, and no
518:           	// data loss occurs.  The system will typically recover
519:           	// automatically, without the need for application firmware
520:           	// intervention.
521:           	
522:           	// Nevertheless, this callback function is provided, such as
523:           	// for debugging purposes.
524:           }
1B84  0012     RETURN 0
525:           
526:           
527:           /*******************************************************************
528:            * Function:        void USBCBCheckOtherReq(void)
529:            *
530:            * PreCondition:    None
531:            *
532:            * Input:           None
533:            *
534:            * Output:          None
535:            *
536:            * Side Effects:    None
537:            *
538:            * Overview:        When SETUP packets arrive from the host, some
539:            * 					firmware must process the request and respond
540:            *					appropriately to fulfill the request.  Some of
541:            *					the SETUP packets will be for standard
542:            *					USB "chapter 9" (as in, fulfilling chapter 9 of
543:            *					the official USB specifications) requests, while
544:            *					others may be specific to the USB device class
545:            *					that is being implemented.  For example, a HID
546:            *					class device needs to be able to respond to
547:            *					"GET REPORT" type of requests.  This
548:            *					is not a standard USB chapter 9 request, and 
549:            *					therefore not handled by usb_device.c.  Instead
550:            *					this request should be handled by class specific 
551:            *					firmware, such as that contained in usb_function_hid.c.
552:            *
553:            * Note:            None
554:            *****************************************************************************/
555:           void USBCBCheckOtherReq(void)
556:           {
557:           // my
558:               if (flag.CDC_mode)  
1B86  0103     MOVLB 0x3
1B88  A59D     BTFSS 0x9D, 2, BANKED
1B8A  D002     BRA 0x1B90
559:                   USBCheckCDCRequest();
1B8C  EC5F     CALL 0x16BE, 0
1B8E  F00B     NOP
560:           // end of my
561:           }//end
1B90  0012     RETURN 0
562:           
563:           
564:           /*******************************************************************
565:            * Function:        void USBCBStdSetDscHandler(void)
566:            *
567:            * PreCondition:    None
568:            *
569:            * Input:           None
570:            *
571:            * Output:          None
572:            *
573:            * Side Effects:    None
574:            *
575:            * Overview:        The USBCBStdSetDscHandler() callback function is
576:            *					called when a SETUP, bRequest: SET_DESCRIPTOR request
577:            *					arrives.  Typically SET_DESCRIPTOR requests are
578:            *					not used in most applications, and it is
579:            *					optional to support this type of request.
580:            *
581:            * Note:            None
582:            *****************************************************************************/
583:           void USBCBStdSetDscHandler(void)
584:           {
585:               // Must claim session ownership if supporting this request
586:           }//end
1B92  0012     RETURN 0
587:           
588:           
589:           /******************************************************************************
590:            * Function:        void USBCBInitEP(void)
591:            *
592:            * PreCondition:    None
593:            *
594:            * Input:           None
595:            *
596:            * Output:          None
597:            *
598:            * Side Effects:    None
599:            *
600:            * Overview:        This function is called when the device becomes
601:            *                  initialized, which occurs after the host sends a
602:            * 					SET_CONFIGURATION (wValue not = 0) request.  This 
603:            *					callback function should initialize the endpoints 
604:            *					for the device's usage according to the current 
605:            *					configuration.
606:            *
607:            * Note:            None
608:            *****************************************************************************/
609:           void USBCBInitEP(void)
610:           {
611:           // my
612:               if (flag.CDC_mode)
1B94  0103     MOVLB 0x3
1B96  A59D     BTFSS 0x9D, 2, BANKED
1B98  D002     BRA 0x1B9E
613:                   CDCInitEP(); 
1B9A  EFAE     GOTO 0x175C
1B9C  F00B     NOP
614:               else
615:               {    
616:                   USBEnableEndpoint(USBGEN_EP_NUM,USB_OUT_ENABLED|USB_IN_ENABLED|USB_HANDSHAKE_ENABLED|USB_DISALLOW_SETUP);
1B9E  0E1E     MOVLW 0x1E
1BA0  6EE6     MOVWF POSTINC1, ACCESS
1BA2  0E01     MOVLW 0x1
1BA4  6EE6     MOVWF POSTINC1, ACCESS
1BA6  EC20     CALL 0x2440, 0
1BA8  F012     NOP
1BAA  52E5     MOVF POSTDEC1, F, ACCESS
1BAC  52E5     MOVF POSTDEC1, F, ACCESS
617:                   USBGenericOutHandle = USBGenRead(USBGEN_EP_NUM,(BYTE*)&OUTPacket,USBGEN_EP_SIZE);
1BAE  0E40     MOVLW 0x40
1BB0  6EE6     MOVWF POSTINC1, ACCESS
1BB2  0E40     MOVLW 0x40
1BB4  6EE6     MOVWF POSTINC1, ACCESS
1BB6  0E03     MOVLW 0x3
1BB8  6EE6     MOVWF POSTINC1, ACCESS
1BBA  6AE6     CLRF POSTINC1, ACCESS
1BBC  0E01     MOVLW 0x1
1BBE  6EE6     MOVWF POSTINC1, ACCESS
1BC0  EC64     CALL 0x24C8, 0
1BC2  F012     NOP
1BC4  6E14     MOVWF __tmp_0, ACCESS
1BC6  0E05     MOVLW 0x5
1BC8  5CE1     SUBWF FSR1L, W, ACCESS
1BCA  E202     BC 0x1BD0
1BCC  6AE1     CLRF FSR1L, ACCESS
1BCE  52E5     MOVF POSTDEC1, F, ACCESS
1BD0  6EE1     MOVWF FSR1L, ACCESS
1BD2  5014     MOVF __tmp_0, W, ACCESS
1BD4  CFF3     MOVFF PRODL, USBGenericOutHandle
1BD6  F0F6     NOP
1BD8  CFF4     MOVFF PRODH, 0xF7
1BDA  F0F7     NOP
618:               }
619:           // end of my
620:           }
1BDC  0012     RETURN 0
621:           
622:           /********************************************************************
623:            * Function:        void USBCBSendResume(void)
624:            *
625:            * PreCondition:    None
626:            *
627:            * Input:           None
628:            *
629:            * Output:          None
630:            *
631:            * Side Effects:    None
632:            *
633:            * Overview:        The USB specifications allow some types of USB
634:            * 					peripheral devices to wake up a host PC (such
635:            *					as if it is in a low power suspend to RAM state).
636:            *					This can be a very useful feature in some
637:            *					USB applications, such as an Infrared remote
638:            *					control	receiver.  If a user presses the "power"
639:            *					button on a remote control, it is nice that the
640:            *					IR receiver can detect this signalling, and then
641:            *					send a USB "command" to the PC to wake up.
642:            *					
643:            *					The USBCBSendResume() "callback" function is used
644:            *					to send this special USB signalling which wakes 
645:            *					up the PC.  This function may be called by
646:            *					application firmware to wake up the PC.  This
647:            *					function should only be called when:
648:            *					
649:            *					1.  The USB driver used on the host PC supports
650:            *						the remote wakeup capability.
651:            *					2.  The USB configuration descriptor indicates
652:            *						the device is remote wakeup capable in the
653:            *						bmAttributes field.
654:            *					3.  The USB host PC is currently sleeping,
655:            *						and has previously sent your device a SET 
656:            *						FEATURE setup packet which "armed" the
657:            *						remote wakeup capability.   
658:            *
659:            *					This callback should send a RESUME signal that
660:            *                  has the period of 1-15ms.
661:            *
662:            * Note:            Interrupt vs. Polling
663:            *                  -Primary clock
664:            *                  -Secondary clock ***** MAKE NOTES ABOUT THIS *******
665:            *                   > Can switch to primary first by calling USBCBWakeFromSuspend()
666:            
667:            *                  The modifiable section in this routine should be changed
668:            *                  to meet the application needs. Current implementation
669:            *                  temporary blocks other functions from executing for a
670:            *                  period of 1-13 ms depending on the core frequency.
671:            *
672:            *                  According to USB 2.0 specification section 7.1.7.7,
673:            *                  "The remote wakeup device must hold the resume signaling
674:            *                  for at lest 1 ms but for no more than 15 ms."
675:            *                  The idea here is to use a delay counter loop, using a
676:            *                  common value that would work over a wide range of core
677:            *                  frequencies.
678:            *                  That value selected is 1800. See table below:
679:            *                  ==========================================================
680:            *                  Core Freq(MHz)      MIP         RESUME Signal Period (ms)
681:            *                  ==========================================================
682:            *                      48              12          1.05
683:            *                       4              1           12.6
684:            *                  ==========================================================
685:            *                  * These timing could be incorrect when using code
686:            *                    optimization or extended instruction mode,
687:            *                    or when having other interrupts enabled.
688:            *                    Make sure to verify using the MPLAB SIM's Stopwatch
689:            *                    and verify the actual signal on an oscilloscope.
690:            *******************************************************************/
691:           void USBCBSendResume(void)
692:           {
693:               static WORD delay_count;
694:               
695:               USBResumeControl = 1;                // Start RESUME signaling
1BDE  8465     BSF UCON, 2, ACCESS
696:               
697:               delay_count = 1800U;                // Set RESUME line for 1-13 ms
1BE0  0100     MOVLB 0x0
1BE2  0E08     MOVLW 0x8
1BE4  6FFA     MOVWF delay_count, BANKED
1BE6  0E07     MOVLW 0x7
1BE8  6FFB     MOVWF 0xFB, BANKED
698:               do
699:               {
700:                   delay_count--;
1BEA  07FA     DECF delay_count, F, BANKED
1BEC  0E00     MOVLW 0x0
1BEE  5BFB     SUBWFB 0xFB, F, BANKED
701:               }while(delay_count);
1BF0  51FA     MOVF delay_count, W, BANKED
1BF2  11FB     IORWF 0xFB, W, BANKED
1BF4  E1FA     BNZ 0x1BEA
702:               USBResumeControl = 0;
1BF6  9465     BCF UCON, 2, ACCESS
703:           }
1BF8  0012     RETURN 0
704:           
705:           // my
706:           /*******************************************************************
707:            * Function:        void USBCBEP0DataReceived(void)
708:            *
709:            * PreCondition:    ENABLE_EP0_DATA_RECEIVED_CALLBACK must be
710:            *                  defined already (in usb_config.h)
711:            *
712:            * Input:           None
713:            *
714:            * Output:          None
715:            *
716:            * Side Effects:    None
717:            *
718:            * Overview:        This function is called whenever a EP0 data
719:            *                  packet is received.  This gives the user (and
720:            *                  thus the various class examples a way to get
721:            *                  data that is received via the control endpoint.
722:            *                  This function needs to be used in conjunction
723:            *                  with the USBCBCheckOtherReq() function since 
724:            *                  the USBCBCheckOtherReq() function is the apps
725:            *                  method for getting the initial control transfer
726:            *                  before the data arrives.
727:            *
728:            * Note:            None
729:            *******************************************************************/
730:           #if defined(ENABLE_EP0_DATA_RECEIVED_CALLBACK)
731:           void USBCBEP0DataReceived(void)
732:           {
733:           }
734:           #endif
735:           // end of my
736:           
737:           /** EOF main.c ***************************************************************/
---  E:/projects/CK-USB-04A/001/pic_apl/IQRF_SPI.c  -----------------------------------------------------
1:             /*********************************************************************
2:              *
3:              *                  IQRF TR module SPI Routines
4:              *
5:              *********************************************************************
6:              * FileName:        IQRF_SPI.c
7:              * Company:         MICRORISC s.r.o.
8:              * Web:             www.iqrf.org
9:              * 
10:             * Tested:
11:             *      Processor:  PIC18
12:             *      Compiler:   Microchip C30 v3.35
13:             *
14:             * Software License Agreement
15:             *
16:             * Copyright (C) 2010 MICRORISC s.r.o.  All rights reserved.
17:             *
18:             * You should refer to the license agreement accompanying this 
19:             * Software for additional information regarding your rights and 
20:             * obligations.
21:             *
22:             * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
23:             * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
24:             * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
25:             * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
26:             * MICRORISC BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
27:             * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
28:             * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
29:             * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
30:             * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
31:             * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
32:             * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE.
33:             *
34:             *
35:             * Author               Date        Comment
36:             *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
37:             * Jaromir Mastik		26/07/2010  Original for PIC18 (Rev. 1.0)
38:             * Jaromir Mastik		19/10/2010  IQRF_SPI_Init and IQRF_SPI_Byte 
39:             *                                  modificated for CK-USB-04
40:            ********************************************************************/
41:            #define __IQRF_SPI_C
42:            
43:            #include "IQRF_SPI.h"
44:            
45:            unsigned char IQRF_SPI_TxBuf[IQRF_SPI_BUFFER_SIZE];
46:            unsigned char IQRF_SPI_RxBuf[IQRF_SPI_BUFFER_SIZE];
47:            unsigned char IQRF_SPI_Busy, iq_DLEN, iq_PTYPE, iq_spistat, IQRF_SPI_Task_Message;
48:            unsigned char iq_tmp_cnt, iq_pac_len, byte_space;
49:            DWORD Check_Status_Time;
50:            
51:            extern volatile DWORD tick;
52:            
53:            /*********************************************************************
54:             * Function:        void IQRF_SPI_Init(void)
55:             *
56:             * PreCondition:    None
57:             *
58:             * Input:           None
59:             *
60:             * Output:          None
61:             *
62:             * Side Effects:    None
63:             *
64:             * Overview:        Initializes the SPI module to communicate to
65:             *                  IQRF TR module.
66:             *
67:             * Note:            This function is called only one during lifetime
68:             *                  of the application.  
69:             ********************************************************************/
70:             
71:            void IQRF_SPI_Init(void)
72:            {
73:            	// SDO, SDI, SCK are defined in InitializeBoard(void)
74:            	// These pins must be defined even if the PPS is used. When the SPICON is redefined the SPI is disabled.
75:            	// When TR module enter programming mode is executed these pins are used directly.
76:            //	TR_SDO_TRIS = 0;					
77:            //	TR_SCK_TRIS = 0;				
78:            // 	TR_SDI_TRIS = 1;			
79:               	
80:            	CS_TR_IO = 1;										// slave select for TR module, the idle state is high
2756  868A     BSF LATB, 3, ACCESS
81:            //	CS_TR_TRIS = 0;                                     // defined in InitializeBoard(void)
82:            	
83:            	T2CON = 0b00000100;									// TMR ON, 		
2758  0E04     MOVLW 0x4
275A  6ECA     MOVWF T2CON, ACCESS
84:                PR2 = 23;        									// fclk SPI 250kHz
275C  0E17     MOVLW 0x17
275E  6ECB     MOVWF PR2, ACCESS
85:                TR_SPISTAT = 0b01000000;							// CKE=1
2760  0E40     MOVLW 0x40
2762  6E73     MOVWF SSP2STAT, ACCESS
86:                TR_SPICON1 = 0b00100011;         					// SPI ON, CKP=0, master CLK=TMR2/2
2764  0E23     MOVLW 0x23
2766  6E72     MOVWF SSP2CON1, ACCESS
87:            //	TR_SPICON1bits.SSPEN = 1;
88:                IQRF_SPI_Task_Message = 0;                          // no message from TR module
2768  0100     MOVLB 0x0
276A  6BE4     CLRF IQRF_SPI_Task_Message, BANKED
89:                IQRF_SPI_Busy = 0;
276C  6BE0     CLRF IQRF_SPI_Busy, BANKED
90:                byte_space = 0;
276E  6BE7     CLRF byte_space, BANKED
91:            }
2770  0012     RETURN 0
92:            
93:            /*********************************************************************
94:             * Function:        unsigned char IQRF_SPI_Byte(unsigned char Tx_Byte)
95:             *
96:             * PreCondition:    IQRF_SPI_Init() is already called.
97:             *
98:             * Input:           Tx_Byte - byte to be sent
99:             *
100:            * Output:          Received byte
101:            *
102:            * Side Effects:    None
103:            *
104:            * Overview:        Sends/receives 1 byte via SPI
105:            *
106:            * Note:            It uses Delay10us() which must be defined 
107:            *                  according used MCU clock.  
108:            ********************************************************************/
109:           unsigned char IQRF_SPI_Byte(unsigned char Tx_Byte)
2772  D8EE     RCALL __pa_0
110:           {
111:               TR_SPI_IF = 0;
2774  9EA4     BCF PIR3, 7, ACCESS
112:           	CS_TR_IO = 0;										// CS - active
2776  968A     BCF LATB, 3, ACCESS
113:           	Delay_us(10);
2778  0E0A     MOVLW 0xA
277A  6EE6     MOVWF POSTINC1, ACCESS
277C  EC6F     CALL 0x10DE, 0
277E  F008     NOP
2780  52E5     MOVF POSTDEC1, F, ACCESS
114:           	
115:           	if(SSP1CON1bits.WCOL) 
2782  BEC6     BTFSC SSP1CON1, 7, ACCESS
116:                   SSP1CON1bits.WCOL = 0;
2784  9EC6     BCF SSP1CON1, 7, ACCESS
117:           		
118:           	TR_SSPBUF = Tx_Byte;
2786  0EFD     MOVLW 0xFD
2788  50DB     MOVF PLUSW2, W, ACCESS
278A  6E75     MOVWF SSP2BUF, ACCESS
119:           	while (!TR_SPI_IF);     	 						// wait until data is received
278C  AEA4     BTFSS PIR3, 7, ACCESS
278E  D7FE     BRA 0x278C
120:           		
121:           	Delay_us(10);
2790  0E0A     MOVLW 0xA
2792  6EE6     MOVWF POSTINC1, ACCESS
2794  EC6F     CALL 0x10DE, 0
2796  F008     NOP
2798  52E5     MOVF POSTDEC1, F, ACCESS
122:           	CS_TR_IO = 1;										// CS - deactive
279A  868A     BSF LATB, 3, ACCESS
123:           	TR_SPI_IF = 0;										// must be for sharing with SPI EEPROM routines
279C  9EA4     BCF PIR3, 7, ACCESS
124:               return TR_SSPBUF;	
279E  5075     MOVF SSP2BUF, W, ACCESS
125:           }
27A0  D0EA     BRA __pa_2
126:           
127:           /*********************************************************************
128:            * Function:        unsigned char IQRF_SPI_GetCRCM(void)
129:            *
130:            * PreCondition:    Data must be prepared in IQRF_SPI_TxBuf and 
131:            *                  iq_DLEN must be valid.
132:            *
133:            * Input:           None
134:            *
135:            * Output:          CRCM result
136:            *
137:            * Side Effects:    None
138:            *
139:            * Overview:        Returns CRCM according IQRF SPI specification.
140:            *
141:            * Note:            None
142:            ********************************************************************/
143:           unsigned char IQRF_SPI_GetCRCM(void)
27A2  D8D6     RCALL __pa_0
27A4  52E6     MOVF POSTINC1, F, ACCESS
27A6  52E6     MOVF POSTINC1, F, ACCESS
144:           {
145:            unsigned char i, crc_val;
146:           
147:           	crc_val = 0x5F;
27A8  52DE     MOVF POSTINC2, F, ACCESS
27AA  0E5F     MOVLW 0x5F
27AC  6EDD     MOVWF POSTDEC2, ACCESS
148:           
149:           	for(i = 0; i < (iq_DLEN + 2); i++) 	
27AE  6ADF     CLRF INDF2, ACCESS
27B0  0E02     MOVLW 0x2
27B2  0100     MOVLB 0x0
27B4  25E1     ADDWF iq_DLEN, W, BANKED
27B6  5CDF     SUBWF INDF2, W, ACCESS
27B8  E204     BC 0x27C2
27C0  D7F7     BRA 0x27B0
299E  2ADF     INCF INDF2, F, ACCESS
29A0  0012     RETURN 0
150:           		crc_val ^= IQRF_SPI_TxBuf[i];
27BA  50DF     MOVF INDF2, W, ACCESS
27BC  D8F2     RCALL __pa_5
27BE  D8E7     RCALL __pa_4
298E  0E01     MOVLW 0x1
2990  CFDB     MOVFF PLUSW2, INDF1
2992  FFE7     NOP
2994  50EF     MOVF INDF0, W, ACCESS
2996  1AE7     XORWF INDF1, F, ACCESS
2998  0E01     MOVLW 0x1
299A  CFE7     MOVFF INDF1, PLUSW2
299C  FFDB     NOP
151:           		
152:           	return crc_val;
27C2  0E01     MOVLW 0x1
27C4  50DB     MOVF PLUSW2, W, ACCESS
153:           }
27C6  52E5     MOVF POSTDEC1, F, ACCESS
27C8  52E5     MOVF POSTDEC1, F, ACCESS
27CA  D0D5     BRA __pa_2
154:           
155:           /*********************************************************************
156:            * Function:        unsigned char IQRF_SPI_CheckCRCS(void)
157:            *
158:            * PreCondition:    Data must be prepared in IQRF_SPI_RxBuf. 
159:            *                  iq_DLEN and iq_PTYPE must be valid.
160:            *
161:            * Input:           None
162:            *
163:            * Output:          CRCS result (0 - error, 1 - OK)
164:            *
165:            * Side Effects:    None
166:            *
167:            * Overview:        Returns CRCS result according IQRF SPI specification.
168:            *
169:            * Note:            None
170:            ********************************************************************/
171:           unsigned char IQRF_SPI_CheckCRCS(void)
27CC  D8C1     RCALL __pa_0
27CE  52E6     MOVF POSTINC1, F, ACCESS
27D0  52E6     MOVF POSTINC1, F, ACCESS
172:           {
173:            unsigned char i, crc_val;
174:           
175:           	crc_val = 0x5F ^ iq_PTYPE;
27D2  0E5F     MOVLW 0x5F
27D4  0100     MOVLB 0x0
27D6  19E2     XORWF iq_PTYPE, W, BANKED
27D8  6EE7     MOVWF INDF1, ACCESS
27DA  0E01     MOVLW 0x1
27DC  CFE7     MOVFF INDF1, PLUSW2
27DE  FFDB     NOP
176:           	
177:           	for (i = 2; i < (iq_DLEN + 2); i++)
27E0  0E02     MOVLW 0x2
27E2  6EDF     MOVWF INDF2, ACCESS
27E4  0E02     MOVLW 0x2
27E6  25E1     ADDWF iq_DLEN, W, BANKED
27E8  5CDF     SUBWF INDF2, W, ACCESS
27EA  E204     BC 0x27F4
27F2  D7F8     BRA 0x27E4
178:           		crc_val ^= IQRF_SPI_RxBuf[i];
27EC  50DF     MOVF INDF2, W, ACCESS
27EE  D8C9     RCALL __pa_3
27F0  D8CE     RCALL __pa_4
179:           		
180:           	if (IQRF_SPI_RxBuf[iq_DLEN + 2] == crc_val)
27F4  0E02     MOVLW 0x2
27F6  25E1     ADDWF iq_DLEN, W, BANKED
27F8  D8C4     RCALL __pa_3
27FA  CFEF     MOVFF INDF0, __tmp_0
27FC  F014     NOP
27FE  0E01     MOVLW 0x1
2800  50DB     MOVF PLUSW2, W, ACCESS
2802  5C14     SUBWF __tmp_0, W, ACCESS
2804  E102     BNZ 0x280A
181:           	    return 1;	                            // CRCS ok
2806  0E01     MOVLW 0x1
2808  D001     BRA 0x280C
182:           	else                                     
183:           	    return 0;                               // CRCS error
280A  0E00     MOVLW 0x0
184:           }
280C  52E5     MOVF POSTDEC1, F, ACCESS
280E  52E5     MOVF POSTDEC1, F, ACCESS
2810  D0B2     BRA __pa_2
185:           
186:           /*********************************************************************
187:            * Function:        void Start_IQRF_SPI(void)
188:            *
189:            * PreCondition:    Data must be prepared in IQRF_SPI_TxBuf. 
190:            *                  iq_DLEN and iq_PTYPE must be valid.
191:            *
192:            * Input:           None
193:            *
194:            * Output:          None
195:            *
196:            * Side Effects:    None
197:            *
198:            * Overview:        Prepares SPI packet to be sent and activates
199:            *                  IQRF_SPI_Task.
200:            *
201:            * Note:            None
202:            ********************************************************************/
203:           void Start_IQRF_SPI(void)
204:           {
205:               IQRF_SPI_TxBuf[iq_DLEN + 2] = IQRF_SPI_GetCRCM();
2812  D8A7     RCALL __pa_1
2962  DF1F     RCALL IQRF_SPI_GetCRCM
2964  6EE6     MOVWF POSTINC1, ACCESS
2966  0E02     MOVLW 0x2
2968  0100     MOVLB 0x0
296A  25E1     ADDWF iq_DLEN, W, BANKED
296C  D81A     RCALL __pa_5
296E  52E5     MOVF POSTDEC1, F, ACCESS
2970  50E7     MOVF INDF1, W, ACCESS
2972  6EEF     MOVWF INDF0, ACCESS
2974  0012     RETURN 0
29A2  6AEA     CLRF FSR0H, ACCESS
29A4  0F60     ADDLW 0x60
29A6  6EE9     MOVWF FSR0L, ACCESS
29A8  0E00     MOVLW 0x0
29AA  22EA     ADDWFC FSR0H, F, ACCESS
29AC  0012     RETURN 0
206:               
207:               iq_pac_len = iq_DLEN + 4;			        // length of whole packet (user data + CMD + PTYPE + CRCM + SPI_CHECK)     
2814  0E04     MOVLW 0x4
2816  25E1     ADDWF iq_DLEN, W, BANKED
2818  6FE6     MOVWF iq_pac_len, BANKED
208:           	iq_tmp_cnt = 0;					            // counter of sent SPI bytes
281A  6BE5     CLRF iq_tmp_cnt, BANKED
209:           	
210:           	if (iq_PTYPE & 0x80)		                // PTYPE bit7 test
281C  AFE2     BTFSS iq_PTYPE, 7, BANKED
281E  D002     BRA 0x2824
211:               	IQRF_SPI_Busy = IQRF_BUSY_WRITING;		  
2820  0E01     MOVLW 0x1
212:               else
2822  D001     BRA 0x2826
213:                   IQRF_SPI_Busy = IQRF_BUSY_READING;      // IQRF SPI je obsazeno	- zapisuje se
2824  0E02     MOVLW 0x2
2826  6FE0     MOVWF IQRF_SPI_Busy, BANKED
214:           												// tento flag zachyti IQRF_SPI_Task v hlavni smycce,
215:           												// zajisti odeslani, pak tento flag shodi 
216:           }
2828  0012     RETURN 0
217:           
218:           /*********************************************************************
219:            * Function:        void IQRF_SPI_Task(void)
220:            *
221:            * PreCondition:    IQRF_SPI_Init(), Start_IQRF_SPI() is already called. 
222:            *
223:            * Input:           None
224:            *
225:            * Output:          None
226:            *
227:            * Side Effects:    None
228:            *
229:            * Overview:        If IQRF_SPI_Busy is > 0 one byte from IQRF_SPI_TxBuf 
230:            *                  is sent/received. After whole packet is sent the 
231:            *                  IQRF_SPI_Task_Message is set.
232:            *                  
233:            *                  If IQRF_SPI_Busy is 0 the SPI_CHECK is sent and 
234:            *                  SPISTAT is received. If there is data in bufferCOM 
235:            *                  of TR module it is automatically read. Received data
236:            *                  is in IQRF_SPI_RxBuf.
237:            *
238:            * Note:            This function must be called from main loop every
239:            *                  500us if the TR-21A or TR-3xB is used. 
240:            *                  If the TR-52B is used this function can be called
241:            *                  every 200us. Calling of this function makes delay
242:            *                  between SPI bytes. 
243:            ********************************************************************/
244:           void IQRF_SPI_Task(void)
282A  D892     RCALL __pa_0
282C  52E6     MOVF POSTINC1, F, ACCESS
2950  CFD9     MOVFF FSR2L, POSTINC1
2952  FFE6     NOP
2954  CFDA     MOVFF FSR2H, POSTINC1
2956  FFE6     NOP
2958  CFE1     MOVFF FSR1L, FSR2L
295A  FFD9     NOP
295C  CFE2     MOVFF FSR1H, FSR2H
295E  FFDA     NOP
2960  0012     RETURN 0
245:           {
246:           unsigned char last_spistat;
247:           
248:               if (TR_SPICON1bits.SPIEN == 0)			    // SPI periphery of MCU must be enabled
282E  AA72     BTFSS SSP2CON1, 5, ACCESS
2830  D08D     BRA 0x294C
249:                   return;                                 // jinak se to tam zakousne (ceka na IF)
250:           
251:           	if (IQRF_SPI_Busy)						    // any SPI packet to read/write?
2832  0100     MOVLB 0x0
2834  51E0     MOVF IQRF_SPI_Busy, W, BANKED
2836  E03B     BZ 0x28AE
252:           	{                                           // yes - read/write 1 SPI byte
253:               	if (byte_space < 14)                    // bude odesilat po: 14 ~ 500us, 6 ~ 270
2838  0E0E     MOVLW 0xE
283A  5DE7     SUBWF byte_space, W, BANKED
283C  E202     BC 0x2842
254:               	{                                      
255:               	    ++byte_space;
283E  2BE7     INCF byte_space, F, BANKED
256:               	    return;
2840  D085     BRA 0x294C
257:               	}
258:               	   
259:               	byte_space = 0;
2842  6BE7     CLRF byte_space, BANKED
260:               	
261:           		IQRF_SPI_RxBuf[iq_tmp_cnt] = IQRF_SPI_Byte(IQRF_SPI_TxBuf[iq_tmp_cnt]);
2844  51E5     MOVF iq_tmp_cnt, W, BANKED
2846  D8AD     RCALL __pa_5
2848  50EF     MOVF INDF0, W, ACCESS
284A  6EE6     MOVWF POSTINC1, ACCESS
284C  DF92     RCALL IQRF_SPI_Byte
284E  52E5     MOVF POSTDEC1, F, ACCESS
2850  6EE6     MOVWF POSTINC1, ACCESS
2852  0100     MOVLB 0x0
2854  51E5     MOVF iq_tmp_cnt, W, BANKED
2856  D895     RCALL __pa_3
2858  52E5     MOVF POSTDEC1, F, ACCESS
285A  50E7     MOVF INDF1, W, ACCESS
285C  6EEF     MOVWF INDF0, ACCESS
262:           		
263:           		iq_tmp_cnt++;							// tmp_cnt cleared in Start_IQRF_SPI()
285E  2BE5     INCF iq_tmp_cnt, F, BANKED
264:           												
265:           		if (iq_tmp_cnt == iq_pac_len || iq_tmp_cnt == IQRF_SPI_BUFFER_SIZE)					
2860  51E6     MOVF iq_pac_len, W, BANKED
2862  5DE5     SUBWF iq_tmp_cnt, W, BANKED
2864  E003     BZ 0x286C
2866  0E40     MOVLW 0x40
2868  5DE5     SUBWF iq_tmp_cnt, W, BANKED
286A  E170     BNZ 0x294C
266:           		{										// packet sent or buffer overflow
267:               		
268:           		    if ((IQRF_SPI_RxBuf[iq_DLEN + 3] == TR_STAT_CRCM_OK) && IQRF_SPI_CheckCRCS())
286C  0E03     MOVLW 0x3
286E  25E1     ADDWF iq_DLEN, W, BANKED
2870  D888     RCALL __pa_3
2872  50EF     MOVF INDF0, W, ACCESS
2874  083F     SUBLW 0x3F
2876  E10E     BNZ 0x2894
2878  DFA9     RCALL IQRF_SPI_CheckCRCS
287A  0900     IORLW 0x0
287C  E00B     BZ 0x2894
2982  6AEA     CLRF FSR0H, ACCESS
2984  0FA0     ADDLW 0xA0
2986  6EE9     MOVWF FSR0L, ACCESS
2988  0E00     MOVLW 0x0
298A  22EA     ADDWFC FSR0H, F, ACCESS
298C  0012     RETURN 0
269:           			{									// CRC ok
270:           				switch (IQRF_SPI_Busy)
287E  0100     MOVLB 0x0
2880  51E0     MOVF IQRF_SPI_Busy, W, BANKED
2882  0A02     XORLW 0x2
2884  E004     BZ 0x288E
2886  0A03     XORLW 0x3
2888  E10F     BNZ 0x28A8
271:           				{
272:           					case IQRF_BUSY_WRITING:		
273:           						IQRF_SPI_Task_Message = IQRF_SPI_WRITE_OK;	
288A  0E01     MOVLW 0x1
274:           						break;
288C  D001     BRA 0x2890
275:           					
276:           					case IQRF_BUSY_READING:		
277:           						IQRF_SPI_Task_Message = IQRF_SPI_DATA_READY;	
288E  0E03     MOVLW 0x3
2890  6FE4     MOVWF IQRF_SPI_Task_Message, BANKED
278:           						break;
279:           				}
280:           			}
281:           			else
2892  D00A     BRA 0x28A8
282:           			{		                            // CRC error
283:               			switch (IQRF_SPI_Busy)
2894  0100     MOVLB 0x0
2896  51E0     MOVF IQRF_SPI_Busy, W, BANKED
2898  0A02     XORLW 0x2
289A  E004     BZ 0x28A4
289C  0A03     XORLW 0x3
289E  E104     BNZ 0x28A8
284:           				{
285:           					case IQRF_BUSY_WRITING:		
286:           						IQRF_SPI_Task_Message = IQRF_SPI_WRITE_ERR;	
28A0  0E02     MOVLW 0x2
287:           						break;
28A2  D001     BRA 0x28A6
288:           					
289:           					case IQRF_BUSY_READING:		
290:           						IQRF_SPI_Task_Message = IQRF_SPI_READ_ERR;	
28A4  0E04     MOVLW 0x4
28A6  6FE4     MOVWF IQRF_SPI_Task_Message, BANKED
291:           						break;
292:           				}
293:           			}
294:           			
295:           			IQRF_SPI_Busy = 0;
28A8  6BE0     CLRF IQRF_SPI_Busy, BANKED
296:           			iq_spistat = 0;						// to recovery SPI status after packet communication
28AA  6BE3     CLRF iq_spistat, BANKED
297:           		}
298:           	}
299:           	else										// no SPI packet to read/write
28AC  D04F     BRA 0x294C
300:           	{											
301:           		if(tick - Check_Status_Time > 9)	
28AE  0EE8     MOVLW 0xE8
28B0  6EE9     MOVWF FSR0L, ACCESS
28B2  0E00     MOVLW 0x0
28B4  6EEA     MOVWF FSR0H, ACCESS
28B6  50EE     MOVF POSTINC0, W, ACCESS
28B8  0103     MOVLB 0x3
28BA  5D82     SUBWF 0x82, W, BANKED
28BC  6E14     MOVWF __tmp_0, ACCESS
28BE  50EE     MOVF POSTINC0, W, ACCESS
28C0  5983     SUBWFB 0x83, W, BANKED
28C2  6E15     MOVWF 0x15, ACCESS
28C4  50EE     MOVF POSTINC0, W, ACCESS
28C6  5984     SUBWFB 0x84, W, BANKED
28C8  6E16     MOVWF 0x16, ACCESS
28CA  50EE     MOVF POSTINC0, W, ACCESS
28CC  5985     SUBWFB 0x85, W, BANKED
28CE  6E17     MOVWF 0x17, ACCESS
28D0  80D8     BSF STATUS, 0, ACCESS
28D2  0E09     MOVLW 0x9
28D4  5414     SUBFWB __tmp_0, W, ACCESS
28D6  0E00     MOVLW 0x0
28D8  5415     SUBFWB 0x15, W, ACCESS
28DA  0E00     MOVLW 0x0
28DC  5416     SUBFWB 0x16, W, ACCESS
28DE  0E00     MOVLW 0x0
28E0  5417     SUBFWB 0x17, W, ACCESS
28E2  E234     BC 0x294C
302:             		{									    // every 10ms - sends SPI_CHECK to get TR module status					
303:             	     	Check_Status_Time = tick;
28E4  C382     MOVFF tick, Check_Status_Time
28E6  F0E8     NOP
28E8  C383     MOVFF 0x383, 0xE9
28EA  F0E9     NOP
28EC  C384     MOVFF 0x384, 0xEA
28EE  F0EA     NOP
28F0  C385     MOVFF 0x385, 0xEB
28F2  F0EB     NOP
304:             	     	
305:             	     	last_spistat = IQRF_SPI_Byte(TR_CMD_SPI_CHECK);
28F4  6AE6     CLRF POSTINC1, ACCESS
28F6  DF3D     RCALL IQRF_SPI_Byte
28F8  52E5     MOVF POSTDEC1, F, ACCESS
28FA  6EDF     MOVWF INDF2, ACCESS
306:              	     	
307:             	     	if (iq_spistat != last_spistat)		// the TR module status must be 2x the same
28FC  50DF     MOVF INDF2, W, ACCESS
28FE  0100     MOVLB 0x0
2900  5DE3     SUBWF iq_spistat, W, BANKED
2902  E003     BZ 0x290A
308:             	     	{
309:           		  	    iq_spistat = last_spistat;
2904  CFDF     MOVFF INDF2, iq_spistat
2906  F0E3     NOP
310:           	  	    	return;
2908  D021     BRA 0x294C
311:           	  	    }
312:             	     	
313:             	     	if ((iq_spistat & 0xC0) == 0x40)   	
290A  0EC0     MOVLW 0xC0
290C  15E3     ANDWF iq_spistat, W, BANKED
290E  0840     SUBLW 0x40
2910  E11D     BNZ 0x294C
314:                      	{                                   // data ready in bufferCOM of TR module
315:           	           	Clear_IQRF_SPI_TxBuf();
2912  0E40     MOVLW 0x40
2914  6EE6     MOVWF POSTINC1, ACCESS
2916  6AE6     CLRF POSTINC1, ACCESS
2918  6AE6     CLRF POSTINC1, ACCESS
291A  0E60     MOVLW 0x60
291C  6EE6     MOVWF POSTINC1, ACCESS
291E  0E00     MOVLW 0x0
2920  6EE6     MOVWF POSTINC1, ACCESS
2922  EC25     CALL 0x2C4A, 0
2924  F016     NOP
2926  6E14     MOVWF __tmp_0, ACCESS
2928  0E05     MOVLW 0x5
292A  5CE1     SUBWF FSR1L, W, ACCESS
292C  E202     BC 0x2932
292E  6AE1     CLRF FSR1L, ACCESS
2930  52E5     MOVF POSTDEC1, F, ACCESS
2932  6EE1     MOVWF FSR1L, ACCESS
2934  5014     MOVF __tmp_0, W, ACCESS
316:           	           	iq_DLEN = iq_spistat & 0x3F; 	// clear bit 7,6 - rest is length
2936  0E3F     MOVLW 0x3F
2938  0100     MOVLB 0x0
293A  15E3     ANDWF iq_spistat, W, BANKED
293C  6FE1     MOVWF iq_DLEN, BANKED
317:           	           	iq_PTYPE = iq_DLEN;
293E  6FE2     MOVWF iq_PTYPE, BANKED
318:           	           	IQRF_SPI_TxBuf[0] = TR_CMD_WR_RD;
2940  0EF0     MOVLW 0xF0
2942  6F60     MOVWF IQRF_SPI_TxBuf, BANKED
319:           	           	IQRF_SPI_TxBuf[1] = iq_PTYPE;
2944  C0E2     MOVFF iq_PTYPE, 0x61
2946  F061     NOP
320:           	           	IQRF_SPI_TxBuf[iq_DLEN + 2] = IQRF_SPI_GetCRCM();
2948  D80C     RCALL __pa_1
321:           	           	Start_IQRF_SPI();               // prepare IQRF_SPI_Task to send packet
294A  DF63     RCALL Start_IQRF_SPI
322:           			}
323:             	  	}	
324:               }
325:           }
294C  52E5     MOVF POSTDEC1, F, ACCESS
294E  D013     BRA __pa_2
2976  52E5     MOVF POSTDEC1, F, ACCESS
2978  CFE5     MOVFF POSTDEC1, FSR2H
297A  FFDA     NOP
297C  CFE7     MOVFF INDF1, FSR2L
297E  FFD9     NOP
2980  0012     RETURN 0
326:           //---------------------------------------------------------------------------
---  E:/projects/CK-USB-04A/001/Microchip/USB/usb_function_cdc.c  ---------------------------------------
1:             /********************************************************************************
2:               File Information:
3:                 FileName:       usb_function_cdc.c
4:                 Dependencies:   See INCLUDES section
5:                 Processor:      PIC18 or PIC24 USB Microcontrollers
6:                 Hardware:       The code is natively intended to be used on the following
7:                                 hardware platforms: PICDEM? FS USB Demo Board,
8:                                 PIC18F87J50 FS USB Plug-In Module, or
9:                                 Explorer 16 + PIC24 USB PIM.  The firmware may be
10:                                modified for use on other USB platforms by editing the
11:                                HardwareProfile.h file.
12:                Complier:   Microchip C18 (for PIC18) or C30 (for PIC24)
13:                Company:        Microchip Technology, Inc.
14:            
15:                Software License Agreement:
16:            
17:                The software supplied herewith by Microchip Technology Incorporated
18:                (the ?Company?) for its PIC Microcontroller is intended and
19:                supplied to you, the Company?s customer, for use solely and
20:                exclusively on Microchip PIC Microcontroller products. The
21:                software is owned by the Company and/or its supplier, and is
22:                protected under applicable copyright laws. All rights are reserved.
23:                Any use in violation of the foregoing restrictions may subject the
24:                user to criminal sanctions under applicable laws, as well as to
25:                civil liability for the breach of the terms and conditions of this
26:                license.
27:            
28:                THIS SOFTWARE IS PROVIDED IN AN ?AS IS? CONDITION. NO WARRANTIES,
29:                WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
30:                TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
31:                PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
32:                IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
33:                CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
34:                
35:              Summary:
36:                This file contains all of functions, macros, definitions, variables,
37:                datatypes, etc. that are required for usage with the CDC function
38:                driver. This file should be included in projects that use the CDC
39:                \function driver.
40:                
41:                
42:                
43:                This file is located in the "\<Install Directory\>\\Microchip\\USB\\CDC
44:                Device Driver" directory.
45:              Description:
46:                USB CDC Function Driver File
47:                
48:                This file contains all of functions, macros, definitions, variables,
49:                datatypes, etc. that are required for usage with the CDC function
50:                driver. This file should be included in projects that use the CDC
51:                \function driver.
52:                
53:                This file is located in the "\<Install Directory\>\\Microchip\\USB\\CDC
54:                Device Driver" directory.
55:                
56:                When including this file in a new project, this file can either be
57:                referenced from the directory in which it was installed or copied
58:                directly into the user application folder. If the first method is
59:                chosen to keep the file located in the folder in which it is installed
60:                then include paths need to be added so that the library and the
61:                application both know where to reference each others files. If the
62:                application folder is located in the same folder as the Microchip
63:                folder (like the current demo folders), then the following include
64:                paths need to be added to the application's project:
65:                
66:                ..\\Include
67:                
68:                ..\\..\\Include
69:                
70:                ..\\..\\Microchip\\Include
71:                
72:                ..\\..\\\<Application Folder\>
73:                
74:                ..\\..\\..\\\<Application Folder\>
75:                
76:                If a different directory structure is used, modify the paths as
77:                required. An example using absolute paths instead of relative paths
78:                would be the following:
79:                
80:                C:\\Microchip Solutions\\Microchip\\Include
81:                
82:                C:\\Microchip Solutions\\My Demo Application                                 
83:              ********************************************************************************/
84:            
85:            /** I N C L U D E S **********************************************************/
86:            #include "GenericTypeDefs.h"
87:            #include "Compiler.h"
88:            #include "usb_config.h"
89:            #include "USB\usb_device.h"
90:            #include "USB\usb_function_cdc.h"
91:            #include "HardwareProfile.h"
92:            
93:            #ifdef USB_USE_CDC
94:            
95:            /** V A R I A B L E S ********************************************************/
96:            #if defined(__18F14K50) || defined(__18F13K50) || defined(__18LF14K50) || defined(__18LF13K50) 
97:                #pragma udata usbram2
98:            #elif defined(__18F2455) || defined(__18F2550) || defined(__18F4455) || defined(__18F4550)\
99:                || defined(__18F4450) || defined(__18F2450)\
100:               || defined(__18F2458) || defined(__18F2453) || defined(__18F4558) || defined(__18F4553)
101:               #pragma udata USB_VARIABLES=0x500
102:           #else
103:               #pragma udata
104:           #endif
105:           
106:           volatile FAR CDC_NOTICE cdc_notice;
107:           volatile FAR unsigned char cdc_data_rx[CDC_DATA_OUT_EP_SIZE];
108:           volatile FAR unsigned char cdc_data_tx[CDC_DATA_IN_EP_SIZE];
109:           LINE_CODING line_coding;    // Buffer to store line coding information
110:           
111:           #pragma udata
112:           BYTE cdc_rx_len;            // total rx length
113:           
114:           BYTE cdc_trf_state;         // States are defined cdc.h
115:           POINTER pCDCSrc;            // Dedicated source pointer
116:           POINTER pCDCDst;            // Dedicated destination pointer
117:           BYTE cdc_tx_len;            // total tx length
118:           BYTE cdc_mem_type;          // _ROM, _RAM
119:           
120:           USB_HANDLE CDCDataOutHandle;
121:           USB_HANDLE CDCDataInHandle;
122:           
123:           
124:           CONTROL_SIGNAL_BITMAP control_signal_bitmap;
125:           DWORD BaudRateGen;			// BRG value calculated from baudrate
126:           extern BYTE  i;
127:           extern BYTE_VAL *pDst;
128:           
129:           /**************************************************************************
130:             SEND_ENCAPSULATED_COMMAND and GET_ENCAPSULATED_RESPONSE are required
131:             requests according to the CDC specification.
132:             However, it is not really being used here, therefore a dummy buffer is
133:             used for conformance.
134:            **************************************************************************/
135:           #define dummy_length    0x08
136:           BYTE_VAL dummy_encapsulated_cmd_response[dummy_length];
137:           
138:           #if defined(USB_CDC_SET_LINE_CODING_HANDLER)
139:           CTRL_TRF_RETURN USB_CDC_SET_LINE_CODING_HANDLER(CTRL_TRF_PARAMS);
140:           #endif
141:           
142:           /** P R I V A T E  P R O T O T Y P E S ***************************************/
143:           void USBCDCSetLineCoding(void);
144:           
145:           /** D E C L A R A T I O N S **************************************************/
146:           //#pragma code
147:           
148:           /** C L A S S  S P E C I F I C  R E Q ****************************************/
149:           /******************************************************************************
150:            	Function:
151:            		void USBCheckCDCRequest(void)
152:            
153:            	Description:
154:            		This routine checks the setup data packet to see if it
155:            		knows how to handle it
156:            		
157:            	PreCondition:
158:            		None
159:           
160:           	Parameters:
161:           		None
162:           		
163:           	Return Values:
164:           		None
165:           		
166:           	Remarks:
167:           		None
168:           		 
169:             *****************************************************************************/
170:           void USBCheckCDCRequest(void)
171:           {
172:               /*
173:                * If request recipient is not an interface then return
174:                */
175:               if(SetupPkt.Recipient != RCPT_INTF) return;
16BE  0104     MOVLB 0x4
16C0  5120     MOVF 0x20, W, BANKED
16C2  0B1F     ANDLW 0x1F
16C4  0801     SUBLW 0x1
16C6  E001     BZ 0x16CA
16C8  0012     RETURN 0
176:           
177:               /*
178:                * If request type is not class-specific then return
179:                */
180:               if(SetupPkt.RequestType != CLASS) return;
16CA  5120     MOVF 0x20, W, BANKED
16CC  0B60     ANDLW 0x60
16CE  42E8     RRNCF WREG, F, ACCESS
16D0  42E8     RRNCF WREG, F, ACCESS
16D2  42E8     RRNCF WREG, F, ACCESS
16D4  42E8     RRNCF WREG, F, ACCESS
16D6  42E8     RRNCF WREG, F, ACCESS
16D8  0801     SUBLW 0x1
16DA  E001     BZ 0x16DE
16DC  0012     RETURN 0
181:           
182:               /*
183:                * Interface ID must match interface numbers associated with
184:                * CDC class, else return
185:                */
186:               if((SetupPkt.bIntfID != CDC_COMM_INTF_ID)&&
16DE  5124     MOVF 0x24, W, BANKED
187:                  (SetupPkt.bIntfID != CDC_DATA_INTF_ID)) return;
16E0  E003     BZ 0x16E8
16E2  0524     DECF 0x24, W, BANKED
16E4  E001     BZ 0x16E8
16E6  0012     RETURN 0
188:               
189:               switch(SetupPkt.bRequest)
16E8  5121     MOVF 0x21, W, BANKED
16EA  0A22     XORLW 0x22
16EC  E032     BZ 0x1752
16EE  0A03     XORLW 0x3
16F0  E025     BZ 0x173C
16F2  0A01     XORLW 0x1
16F4  E015     BZ 0x1720
16F6  0A21     XORLW 0x21
16F8  E00D     BZ 0x1714
16FA  0A01     XORLW 0x1
16FC  E001     BZ 0x1700
16FE  0012     RETURN 0
190:               {
191:                   //****** These commands are required ******//
192:                   case SEND_ENCAPSULATED_COMMAND:
193:                    //send the packet
194:                       inPipes[0].pSrc.bRam = (BYTE*)&dummy_encapsulated_cmd_response;
1700  0104     MOVLB 0x4
1702  0EA2     MOVLW 0xA2
1704  6F49     MOVWF 0x49, BANKED
1706  0E0E     MOVLW 0xE
1708  6F4A     MOVWF 0x4A, BANKED
195:                       inPipes[0].wCount.Val = dummy_length;
170A  0E08     MOVLW 0x8
170C  6F4D     MOVWF 0x4D, BANKED
170E  6B4E     CLRF 0x4E, BANKED
196:                       inPipes[0].info.bits.ctrl_trf_mem = USB_INPIPES_RAM;
1710  814C     BSF 0x4C, 0, BANKED
197:                       inPipes[0].info.bits.busy = 1;
198:                       break;
1712  D022     BRA 0x1758
199:                   case GET_ENCAPSULATED_RESPONSE:
200:                       // Populate dummy_encapsulated_cmd_response first.
201:                       inPipes[0].pSrc.bRam = (BYTE*)&dummy_encapsulated_cmd_response;
1714  0104     MOVLB 0x4
1716  0EA2     MOVLW 0xA2
1718  6F49     MOVWF 0x49, BANKED
171A  0E0E     MOVLW 0xE
171C  6F4A     MOVWF 0x4A, BANKED
202:                       inPipes[0].info.bits.busy = 1;
203:                       break;
171E  D01C     BRA 0x1758
204:                   //****** End of required commands ******//
205:           
206:                   #if defined(USB_CDC_SUPPORT_ABSTRACT_CONTROL_MANAGEMENT_CAPABILITIES_D1)
207:                   case SET_LINE_CODING:
208:                       outPipes[0].wCount.Val = SetupPkt.wLength;
1720  C426     MOVFF 0x426, 0x452
1722  F452     NOP
1724  C427     MOVFF 0x427, 0x453
1726  F453     NOP
209:                       outPipes[0].pDst.bRam = (BYTE*)LINE_CODING_TARGET;
1728  0104     MOVLB 0x4
172A  0E88     MOVLW 0x88
172C  6F4F     MOVWF 0x4F, BANKED
172E  0E0E     MOVLW 0xE
1730  6F50     MOVWF 0x50, BANKED
210:                       outPipes[0].pFunc = LINE_CODING_PFUNC;
1732  6B54     CLRF 0x54, BANKED
1734  6B55     CLRF 0x55, BANKED
1736  6B56     CLRF 0x56, BANKED
211:                       outPipes[0].info.bits.busy = 1;
1738  8F51     BSF 0x51, 7, BANKED
212:                       break;
173A  0012     RETURN 0
213:                       
214:                   case GET_LINE_CODING:
215:                       USBEP0SendRAMPtr(
173C  0104     MOVLB 0x4
173E  0E88     MOVLW 0x88
1740  6F49     MOVWF 0x49, BANKED
1742  0E0E     MOVLW 0xE
1744  6F4A     MOVWF 0x4A, BANKED
1746  0E07     MOVLW 0x7
1748  6F4D     MOVWF 0x4D, BANKED
174A  6B4E     CLRF 0x4E, BANKED
174C  0EC1     MOVLW 0xC1
174E  6F4C     MOVWF 0x4C, BANKED
216:                           (BYTE*)&line_coding,
1750  0012     RETURN 0
217:                           LINE_CODING_LENGTH,
218:                           USB_EP0_INCLUDE_ZERO);
219:                       break;
1752  C422     MOVFF 0x422, control_signal_bitmap
1754  FE9D     NOP
220:           
221:                   case SET_CONTROL_LINE_STATE:
222:                       control_signal_bitmap._byte = (BYTE)SetupPkt.W_Value.v[0];
1756  0104     MOVLB 0x4
1758  8F4C     BSF 0x4C, 7, BANKED
223:                       CONFIGURE_RTS(control_signal_bitmap.CARRIER_CONTROL);
175A  0012     RETURN 0
224:                       CONFIGURE_DTR(control_signal_bitmap.DTE_PRESENT);
225:                       inPipes[0].info.bits.busy = 1;
226:                       break;
227:                   #endif
228:           
229:                   #if defined(USB_CDC_SUPPORT_ABSTRACT_CONTROL_MANAGEMENT_CAPABILITIES_D2)
230:                   case SEND_BREAK:                        // Optional
231:                       inPipes[0].info.bits.busy = 1;
232:           			if (SetupPkt.wValue == 0xFFFF)
233:           			{
234:           				UART_ENABLE = 0;  // turn off USART
235:           				UART_TRISTx = 0;   // Make TX pin an output
236:           				UART_Tx = 0;   // make it low
237:           			}
238:           			else if (SetupPkt.wValue == 0x0000)
239:           			{
240:           				UART_ENABLE = 1;  // turn on USART
241:           				UART_TRISTx = 1;   // Make TX pin an input
242:           			}
243:           			else
244:           			{
245:                           UART_SEND_BREAK();
246:           			}
247:                       break;
248:                   #endif
249:                   default:
250:                       break;
251:               }//end switch(SetupPkt.bRequest)
252:           
253:           }//end USBCheckCDCRequest
254:           
255:           /** U S E R  A P I ***********************************************************/
256:           
257:           /**************************************************************************
258:             Function:
259:                   void CDCInitEP(void)
260:               
261:             Summary:
262:               This function initializes the CDC function driver. This function should
263:               be called after the SET_CONFIGURATION command.
264:             Description:
265:               This function initializes the CDC function driver. This function sets
266:               the default line coding (baud rate, bit parity, number of data bits,
267:               and format). This function also enables the endpoints and prepares for
268:               the first transfer from the host.
269:               
270:               This function should be called after the SET_CONFIGURATION command.
271:               This is most simply done by calling this function from the
272:               USBCBInitEP() function.
273:               
274:               Typical Usage:
275:               <code>
276:                   void USBCBInitEP(void)
277:                   {
278:                       CDCInitEP();
279:                   }
280:               </code>
281:             Conditions:
282:               None
283:             Remarks:
284:               None                                                                   
285:             **************************************************************************/
286:           void CDCInitEP(void)
287:           {
288:              	//Abstract line coding information
289:              	line_coding.dwDTERate.Val = 19200;      // baud rate
175C  010E     MOVLB 0xE
175E  6B88     CLRF 0x88, BANKED
1760  0E4B     MOVLW 0x4B
1762  6F89     MOVWF 0x89, BANKED
1764  6B8A     CLRF 0x8A, BANKED
1766  6B8B     CLRF 0x8B, BANKED
290:              	line_coding.bCharFormat = 0x00;             // 1 stop bit
1768  6B8C     CLRF 0x8C, BANKED
291:              	line_coding.bParityType = 0x00;             // None
176A  6B8D     CLRF 0x8D, BANKED
292:              	line_coding.bDataBits = 0x08;               // 5,6,7,8, or 16
176C  0E08     MOVLW 0x8
176E  6F8E     MOVWF 0x8E, BANKED
293:           
294:               cdc_trf_state = CDC_TX_READY;
1770  6B90     CLRF 0x90, BANKED
295:               cdc_rx_len = 0;
1772  6B8F     CLRF 0x8F, BANKED
296:               
297:               /*
298:                * Do not have to init Cnt of IN pipes here.
299:                * Reason:  Number of BYTEs to send to the host
300:                *          varies from one transaction to
301:                *          another. Cnt should equal the exact
302:                *          number of BYTEs to transmit for
303:                *          a given IN transaction.
304:                *          This number of BYTEs will only
305:                *          be known right before the data is
306:                *          sent.
307:                */
308:               USBEnableEndpoint(CDC_COMM_EP,USB_IN_ENABLED|USB_HANDSHAKE_ENABLED|USB_DISALLOW_SETUP);
1774  0E1A     MOVLW 0x1A
1776  6EE6     MOVWF POSTINC1, ACCESS
1778  0E02     MOVLW 0x2
177A  6EE6     MOVWF POSTINC1, ACCESS
177C  EC20     CALL 0x2440, 0
177E  F012     NOP
1780  52E5     MOVF POSTDEC1, F, ACCESS
1782  52E5     MOVF POSTDEC1, F, ACCESS
309:               USBEnableEndpoint(CDC_DATA_EP,USB_IN_ENABLED|USB_OUT_ENABLED|USB_HANDSHAKE_ENABLED|USB_DISALLOW_SETUP);
1784  0E1E     MOVLW 0x1E
1786  6EE6     MOVWF POSTINC1, ACCESS
1788  0E03     MOVLW 0x3
178A  6EE6     MOVWF POSTINC1, ACCESS
178C  EC20     CALL 0x2440, 0
178E  F012     NOP
1790  52E5     MOVF POSTDEC1, F, ACCESS
1792  52E5     MOVF POSTDEC1, F, ACCESS
310:           
311:               CDCDataOutHandle = USBRxOnePacket(CDC_DATA_EP,(BYTE*)&cdc_data_rx,sizeof(cdc_data_rx));
1794  D983     RCALL __pa_9
1796  E202     BC 0x179C
1798  6AE1     CLRF FSR1L, ACCESS
179A  52E5     MOVF POSTDEC1, F, ACCESS
179C  D95E     RCALL __pa_4
1A5A  6EE1     MOVWF FSR1L, ACCESS
1A5C  5014     MOVF __tmp_0, W, ACCESS
1A5E  CFF3     MOVFF PRODL, CDCDataOutHandle
1A60  FE99     NOP
1A62  CFF4     MOVFF PRODH, 0xE9A
1A64  FE9A     NOP
1A66  0012     RETURN 0
1A9C  0E40     MOVLW 0x40
1A9E  6EE6     MOVWF POSTINC1, ACCESS
1AA0  0E08     MOVLW 0x8
1AA2  6EE6     MOVWF POSTINC1, ACCESS
1AA4  0E0E     MOVLW 0xE
1AA6  6EE6     MOVWF POSTINC1, ACCESS
1AA8  6AE6     CLRF POSTINC1, ACCESS
1AAA  EF1A     GOTO 0x1A34
1AAC  F00D     NOP
312:               CDCDataInHandle = NULL;
179E  010E     MOVLB 0xE
17A0  6B9B     CLRF 0x9B, BANKED
17A2  6B9C     CLRF 0x9C, BANKED
313:           }//end CDCInitEP
17A4  0012     RETURN 0
314:           
315:           /**********************************************************************************
316:             Function:
317:                   BYTE getsUSBUSART(char *buffer, BYTE len)
318:               
319:             Summary:
320:               getsUSBUSART copies a string of BYTEs received through USB CDC Bulk OUT
321:               endpoint to a user's specified location. It is a non-blocking function.
322:               It does not wait for data if there is no data available. Instead it
323:               returns '0' to notify the caller that there is no data available.
324:           
325:             Description:
326:               getsUSBUSART copies a string of BYTEs received through USB CDC Bulk OUT
327:               endpoint to a user's specified location. It is a non-blocking function.
328:               It does not wait for data if there is no data available. Instead it
329:               returns '0' to notify the caller that there is no data available.
330:               
331:               Typical Usage:
332:               <code>
333:                   BYTE numBytes;
334:                   BYTE buffer[64]
335:               
336:                   numBytes = getsUSBUSART(buffer,sizeof(buffer)); //until the buffer is free.
337:                   if(numBytes \> 0)
338:                   {
339:                       //we received numBytes bytes of data and they are copied into
340:                       //  the "buffer" variable.  We can do something with the data
341:                       //  here.
342:                   }
343:               </code>
344:             Conditions:
345:               Value of input argument 'len' should be smaller than the maximum
346:               endpoint size responsible for receiving bulk data from USB host for CDC
347:               class. Input argument 'buffer' should point to a buffer area that is
348:               bigger or equal to the size specified by 'len'.
349:             Input:
350:               buffer -  Pointer to where received BYTEs are to be stored
351:               len -     The number of BYTEs expected.
352:                                                                                              
353:             **********************************************************************************/
354:           BYTE getsUSBUSART(char *buffer, BYTE len)
17A6  D937     RCALL __pa_0
355:           {
356:               cdc_rx_len = 0;
17A8  010E     MOVLB 0xE
17AA  6B8F     CLRF 0x8F, BANKED
357:               
358:               if(!USBHandleBusy(CDCDataOutHandle))
17AC  5199     MOVF 0x99, W, BANKED
17AE  119A     IORWF 0x9A, W, BANKED
17B0  E102     BNZ 0x17B6
17B2  0E00     MOVLW 0x0
17B4  D005     BRA 0x17C0
17B6  D96D     RCALL __pa_8
17B8  50EF     MOVF INDF0, W, ACCESS
17BA  0B80     ANDLW 0x80
17BC  E001     BZ 0x17C0
17BE  0E01     MOVLW 0x1
17C0  0900     IORLW 0x0
17C2  E131     BNZ 0x1826
359:               {
360:                   /*
361:                    * Adjust the expected number of BYTEs to equal
362:                    * the actual number of BYTEs received.
363:                    */
364:                   if(len > USBHandleGetLength(CDCDataOutHandle))
17C4  0EFB     MOVLW 0xFB
17C6  CFDB     MOVFF PLUSW2, __tmp_0
17C8  F014     NOP
17CA  D963     RCALL __pa_8
17CC  52EE     MOVF POSTINC0, F, ACCESS
17CE  50EF     MOVF INDF0, W, ACCESS
17D0  80D8     BSF STATUS, 0, ACCESS
17D2  5414     SUBFWB __tmp_0, W, ACCESS
17D4  E205     BC 0x17E0
365:                       len = USBHandleGetLength(CDCDataOutHandle);
17D6  D95D     RCALL __pa_8
17D8  52EE     MOVF POSTINC0, F, ACCESS
17DA  0EFB     MOVLW 0xFB
17DC  CFEF     MOVFF INDF0, PLUSW2
17DE  FFDB     NOP
1A92  CE99     MOVFF CDCDataOutHandle, FSR0L
1A94  FFE9     NOP
1A96  CE9A     MOVFF 0xE9A, FSR0H
1A98  FFEA     NOP
1A9A  0012     RETURN 0
366:                   
367:                   /*
368:                    * Copy data from dual-ram buffer to user's buffer
369:                    */
370:                   for(cdc_rx_len = 0; cdc_rx_len < len; cdc_rx_len++)
17E0  6B8F     CLRF 0x8F, BANKED
17E2  0EFB     MOVLW 0xFB
17E4  50DB     MOVF PLUSW2, W, ACCESS
17E6  5D8F     SUBWF 0x8F, W, BANKED
17E8  E219     BC 0x181C
1818  2B8F     INCF 0x8F, F, BANKED
181A  D7E3     BRA 0x17E2
371:                       buffer[cdc_rx_len] = cdc_data_rx[cdc_rx_len];
17EA  518F     MOVF 0x8F, W, BANKED
17EC  6AEA     CLRF FSR0H, ACCESS
17EE  0F08     ADDLW 0x8
17F0  6EE9     MOVWF FSR0L, ACCESS
17F2  0E0E     MOVLW 0xE
17F4  22EA     ADDWFC FSR0H, F, ACCESS
17F6  50EF     MOVF INDF0, W, ACCESS
17F8  6EE6     MOVWF POSTINC1, ACCESS
17FA  518F     MOVF 0x8F, W, BANKED
17FC  6EE7     MOVWF INDF1, ACCESS
17FE  0EFC     MOVLW 0xFC
1800  CFDB     MOVFF PLUSW2, FSR0L
1802  FFE9     NOP
1804  0EFD     MOVLW 0xFD
1806  CFDB     MOVFF PLUSW2, FSR0H
1808  FFEA     NOP
180A  50E7     MOVF INDF1, W, ACCESS
180C  26E9     ADDWF FSR0L, F, ACCESS
180E  0E00     MOVLW 0x0
1810  22EA     ADDWFC FSR0H, F, ACCESS
1812  52E5     MOVF POSTDEC1, F, ACCESS
1814  50E7     MOVF INDF1, W, ACCESS
1816  6EEF     MOVWF INDF0, ACCESS
372:           
373:                   /*
374:                    * Prepare dual-ram buffer for next OUT transaction
375:                    */
376:           
377:                   CDCDataOutHandle = USBRxOnePacket(CDC_DATA_EP,(BYTE*)&cdc_data_rx,sizeof(cdc_data_rx));
181C  D93F     RCALL __pa_9
181E  E202     BC 0x1824
1820  6AE1     CLRF FSR1L, ACCESS
1822  52E5     MOVF POSTDEC1, F, ACCESS
1824  D91A     RCALL __pa_4
378:           
379:               }//end if
380:               
381:               return cdc_rx_len;
1826  010E     MOVLB 0xE
1828  518F     MOVF 0x8F, W, BANKED
382:               
383:           }//end getsUSBUSART
182A  D0FE     BRA __pa_1
384:           
385:           /******************************************************************************
386:             Function:
387:           	void putUSBUSART(char *data, BYTE length)
388:           		
389:             Summary:
390:               putUSBUSART writes an array of data to the USB. Use this version, is
391:               capable of transfering 0x00 (what is typically a NULL character in any of
392:               the string transfer functions).
393:           
394:             Description:
395:               putUSBUSART writes an array of data to the USB. Use this version, is
396:               capable of transfering 0x00 (what is typically a NULL character in any of
397:               the string transfer functions).
398:               
399:               Typical Usage:
400:               <code>
401:                   if(USBUSARTIsTxTrfReady())
402:                   {
403:                       char data[] = {0x00, 0x01, 0x02, 0x03, 0x04};
404:                       putUSBUSART(data,5);
405:                   }
406:               </code>
407:               
408:               The transfer mechanism for device-to-host(put) is more flexible than
409:               host-to-device(get). It can handle a string of data larger than the
410:               maximum size of bulk IN endpoint. A state machine is used to transfer a
411:               \long string of data over multiple USB transactions. CDCTxService()
412:               must be called periodically to keep sending blocks of data to the host.
413:           
414:             Conditions:
415:               USBUSARTIsTxTrfReady() must return TRUE. This indicates that the last
416:               transfer is complete and is ready to receive a new block of data. The
417:               string of characters pointed to by 'data' must equal to or smaller than
418:               255 BYTEs.
419:           
420:             Input:
421:               char *data - pointer to a RAM array of data to be transfered to the host
422:               BYTE length - the number of bytes to be transfered (must be less than 255).
423:           		
424:            *****************************************************************************/
425:           void putUSBUSART(char *data, BYTE  length)
182C  D8F4     RCALL __pa_0
426:           {
427:               /*
428:                * User should have checked that cdc_trf_state is in CDC_TX_READY state
429:                * before calling this function.
430:                * As a safety precaution, this fuction checks the state one more time
431:                * to make sure it does not override any pending transactions.
432:                *
433:                * Currently it just quits the routine without reporting any errors back
434:                * to the user.
435:                *
436:                * Bottomline: User MUST make sure that USBUSARTIsTxTrfReady()==1
437:                *             before calling this function!
438:                * Example:
439:                * if(USBUSARTIsTxTrfReady())
440:                *     putUSBUSART(pData, Length);
441:                *
442:                * IMPORTANT: Never use the following blocking while loop to wait:
443:                * while(!USBUSARTIsTxTrfReady())
444:                *     putUSBUSART(pData, Length);
445:                *
446:                * The whole firmware framework is written based on cooperative
447:                * multi-tasking and a blocking code is not acceptable.
448:                * Use a state machine instead.
449:                */
450:               if(cdc_trf_state == CDC_TX_READY)
182E  010E     MOVLB 0xE
1830  5190     MOVF 0x90, W, BANKED
1832  E107     BNZ 0x1842
451:               {
452:                   mUSBUSARTTxRam((BYTE*)data, length);     // See cdc.h
1834  D919     RCALL __pa_5
1836  0EFB     MOVLW 0xFB
1838  CFDB     MOVFF PLUSW2, cdc_tx_len
183A  FE97     NOP
183C  0E01     MOVLW 0x1
183E  6F98     MOVWF 0x98, BANKED
1840  6F90     MOVWF 0x90, BANKED
1A68  0EFC     MOVLW 0xFC
1A6A  CFDB     MOVFF PLUSW2, pCDCSrc
1A6C  FE91     NOP
1A6E  0EFD     MOVLW 0xFD
1A70  CFDB     MOVFF PLUSW2, 0xE92
1A72  FE92     NOP
1A74  0012     RETURN 0
453:               }
454:           }//end putUSBUSART
1842  D0F2     BRA __pa_1
455:           
456:           /******************************************************************************
457:           	Function:
458:           		void putsUSBUSART(char *data)
459:           		
460:             Summary:
461:               putsUSBUSART writes a string of data to the USB including the null
462:               character. Use this version, 'puts', to transfer data from a RAM buffer.
463:           
464:             Description:
465:               putsUSBUSART writes a string of data to the USB including the null
466:               character. Use this version, 'puts', to transfer data from a RAM buffer.
467:               
468:               Typical Usage:
469:               <code>
470:                   if(USBUSARTIsTxTrfReady())
471:                   {
472:                       char data[] = "Hello World";
473:                       putsUSBUSART(data);
474:                   }
475:               </code>
476:               
477:               The transfer mechanism for device-to-host(put) is more flexible than
478:               host-to-device(get). It can handle a string of data larger than the
479:               maximum size of bulk IN endpoint. A state machine is used to transfer a
480:               \long string of data over multiple USB transactions. CDCTxService()
481:               must be called periodically to keep sending blocks of data to the host.
482:           
483:             Conditions:
484:               USBUSARTIsTxTrfReady() must return TRUE. This indicates that the last
485:               transfer is complete and is ready to receive a new block of data. The
486:               string of characters pointed to by 'data' must equal to or smaller than
487:               255 BYTEs.
488:           
489:             Input:
490:               char *data -  null\-terminated string of constant data. If a
491:                                       null character is not found, 255 BYTEs of data
492:                                       will be transferred to the host.
493:           		
494:            *****************************************************************************/
495:            
496:           void putsUSBUSART(char *data)
1844  D934     RCALL __pa_10
1846  52E6     MOVF POSTINC1, F, ACCESS
497:           {
498:               BYTE len;
499:               char *pData;
500:           
501:               /*
502:                * User should have checked that cdc_trf_state is in CDC_TX_READY state
503:                * before calling this function.
504:                * As a safety precaution, this fuction checks the state one more time
505:                * to make sure it does not override any pending transactions.
506:                *
507:                * Currently it just quits the routine without reporting any errors back
508:                * to the user.
509:                *
510:                * Bottomline: User MUST make sure that USBUSARTIsTxTrfReady()==1
511:                *             before calling this function!
512:                * Example:
513:                * if(USBUSARTIsTxTrfReady())
514:                *     putsUSBUSART(pData, Length);
515:                *
516:                * IMPORTANT: Never use the following blocking while loop to wait:
517:                * while(!USBUSARTIsTxTrfReady())
518:                *     putsUSBUSART(pData);
519:                *
520:                * The whole firmware framework is written based on cooperative
521:                * multi-tasking and a blocking code is not acceptable.
522:                * Use a state machine instead.
523:                */
524:               if(cdc_trf_state != CDC_TX_READY) return;
1848  010E     MOVLB 0xE
184A  5190     MOVF 0x90, W, BANKED
184C  E123     BNZ 0x1894
525:               
526:               /*
527:                * While loop counts the number of BYTEs to send including the
528:                * null character.
529:                */
530:               len = 0;
184E  6ADF     CLRF INDF2, ACCESS
531:               pData = data;
1850  0EFC     MOVLW 0xFC
1852  CFDB     MOVFF PLUSW2, 0x8
1854  F008     NOP
1856  0EFD     MOVLW 0xFD
1858  CFDB     MOVFF PLUSW2, 0x9
185A  F009     NOP
185C  52DE     MOVF POSTINC2, F, ACCESS
185E  C008     MOVFF 0x8, POSTINC2
1860  FFDE     NOP
1862  C009     MOVFF 0x9, POSTDEC2
1864  FFDD     NOP
1866  52DD     MOVF POSTDEC2, F, ACCESS
532:               do
533:               {
534:                   len++;
1868  D906     RCALL __pa_6
1A76  2ADF     INCF INDF2, F, ACCESS
535:                   if(len == 255) break;       // Break loop once max len is reached.
186A  E102     BNZ 0x1870
186C  5015     MOVF 0x15, W, ACCESS
186E  E00B     BZ 0x1886
1A78  50DF     MOVF INDF2, W, ACCESS
1A7A  6E14     MOVWF __tmp_0, ACCESS
1A7C  6A15     CLRF 0x15, ACCESS
1A7E  0EFF     MOVLW 0xFF
1A80  1814     XORWF __tmp_0, W, ACCESS
1A82  0012     RETURN 0
536:               }while(*pData++);
1870  0E01     MOVLW 0x1
1872  CFDB     MOVFF PLUSW2, FSR0L
1874  FFE9     NOP
1876  2ADB     INCF PLUSW2, F, ACCESS
1878  0E02     MOVLW 0x2
187A  CFDB     MOVFF PLUSW2, FSR0H
187C  FFEA     NOP
187E  E301     BNC 0x1882
1880  2ADB     INCF PLUSW2, F, ACCESS
1882  50EF     MOVF INDF0, W, ACCESS
1884  E1F1     BNZ 0x1868
537:               
538:               /*
539:                * Second piece of information (length of data to send) is ready.
540:                * Call mUSBUSARTTxRam to setup the transfer.
541:                * The actual transfer process will be handled by CDCTxService(),
542:                * which should be called once per Main Program loop.
543:                */
544:               mUSBUSARTTxRam((BYTE*)data, len);     // See cdc.h
1886  D8F0     RCALL __pa_5
1888  CFDF     MOVFF INDF2, cdc_tx_len
188A  FE97     NOP
188C  010E     MOVLB 0xE
188E  0E01     MOVLW 0x1
1890  6F98     MOVWF 0x98, BANKED
1892  6F90     MOVWF 0x90, BANKED
545:           }//end putsUSBUSART
1894  52E5     MOVF POSTDEC1, F, ACCESS
1896  52E5     MOVF POSTDEC1, F, ACCESS
1898  52E5     MOVF POSTDEC1, F, ACCESS
189A  D0C6     BRA __pa_1
546:           
547:           /**************************************************************************
548:             Function:
549:                   void putrsUSBUSART(const ROM char *data)
550:               
551:             Summary:
552:               putrsUSBUSART writes a string of data to the USB including the null
553:               character. Use this version, 'putrs', to transfer data literals and
554:               data located in program memory.
555:           
556:             Description:
557:               putrsUSBUSART writes a string of data to the USB including the null
558:               character. Use this version, 'putrs', to transfer data literals and
559:               data located in program memory.
560:               
561:               Typical Usage:
562:               <code>
563:                   if(USBUSARTIsTxTrfReady())
564:                   {
565:                       putrsUSBUSART("Hello World");
566:                   }
567:               </code>
568:               
569:               The transfer mechanism for device-to-host(put) is more flexible than
570:               host-to-device(get). It can handle a string of data larger than the
571:               maximum size of bulk IN endpoint. A state machine is used to transfer a
572:               \long string of data over multiple USB transactions. CDCTxService()
573:               must be called periodically to keep sending blocks of data to the host.
574:           
575:             Conditions:
576:               USBUSARTIsTxTrfReady() must return TRUE. This indicates that the last
577:               transfer is complete and is ready to receive a new block of data. The
578:               string of characters pointed to by 'data' must equal to or smaller than
579:               255 BYTEs.
580:           
581:             Input:
582:               const ROM char *data -  null\-terminated string of constant data. If a
583:                                       null character is not found, 255 BYTEs of data
584:                                       will be transferred to the host.
585:                                                                                      
586:             **************************************************************************/
587:           void putrsUSBUSART(const ROM char *data)
189C  D908     RCALL __pa_10
189E  52E6     MOVF POSTINC1, F, ACCESS
18A0  52E6     MOVF POSTINC1, F, ACCESS
1AAE  DFB3     RCALL __pa_0
1AB0  52E6     MOVF POSTINC1, F, ACCESS
1AB2  52E6     MOVF POSTINC1, F, ACCESS
1AB4  0012     RETURN 0
588:           {
589:               BYTE len;
590:               const ROM char *pData;
591:           
592:               /*
593:                * User should have checked that cdc_trf_state is in CDC_TX_READY state
594:                * before calling this function.
595:                * As a safety precaution, this fuction checks the state one more time
596:                * to make sure it does not override any pending transactions.
597:                *
598:                * Currently it just quits the routine without reporting any errors back
599:                * to the user.
600:                *
601:                * Bottomline: User MUST make sure that USBUSARTIsTxTrfReady()
602:                *             before calling this function!
603:                * Example:
604:                * if(USBUSARTIsTxTrfReady())
605:                *     putsUSBUSART(pData);
606:                *
607:                * IMPORTANT: Never use the following blocking while loop to wait:
608:                * while(cdc_trf_state != CDC_TX_READY)
609:                *     putsUSBUSART(pData);
610:                *
611:                * The whole firmware framework is written based on cooperative
612:                * multi-tasking and a blocking code is not acceptable.
613:                * Use a state machine instead.
614:                */
615:               if(cdc_trf_state != CDC_TX_READY) return;
18A2  010E     MOVLB 0xE
18A4  5190     MOVF 0x90, W, BANKED
18A6  E136     BNZ 0x1914
616:               
617:               /*
618:                * While loop counts the number of BYTEs to send including the
619:                * null character.
620:                */
621:               len = 0;
18A8  6ADF     CLRF INDF2, ACCESS
622:               pData = data;
18AA  50D9     MOVF FSR2L, W, ACCESS
18AC  0FFB     ADDLW 0xFB
18AE  6EE9     MOVWF FSR0L, ACCESS
18B0  0EFF     MOVLW 0xFF
18B2  20DA     ADDWFC FSR2H, W, ACCESS
18B4  6EEA     MOVWF FSR0H, ACCESS
18B6  0E01     MOVLW 0x1
18B8  CFEE     MOVFF POSTINC0, PLUSW2
18BA  FFDB     NOP
18BC  0E02     MOVLW 0x2
18BE  CFEE     MOVFF POSTINC0, PLUSW2
18C0  FFDB     NOP
18C2  0E03     MOVLW 0x3
18C4  CFEE     MOVFF POSTINC0, PLUSW2
18C6  FFDB     NOP
623:               do
624:               {
625:                   len++;
18C8  D8D6     RCALL __pa_6
626:                   if(len == 255) break;       // Break loop once max len is reached.
18CA  E102     BNZ 0x18D0
18CC  5015     MOVF 0x15, W, ACCESS
18CE  E013     BZ 0x18F6
627:               }while(*pData++);
18D0  50D9     MOVF FSR2L, W, ACCESS
18D2  0F01     ADDLW 0x1
18D4  6EE9     MOVWF FSR0L, ACCESS
18D6  0E00     MOVLW 0x0
18D8  20DA     ADDWFC FSR2H, W, ACCESS
18DA  6EEA     MOVWF FSR0H, ACCESS
18DC  CFEF     MOVFF INDF0, TBLPTRL
18DE  FFF6     NOP
18E0  2AEE     INCF POSTINC0, F, ACCESS
18E2  CFEF     MOVFF INDF0, TBLPTRH
18E4  FFF7     NOP
18E6  0E00     MOVLW 0x0
18E8  22EE     ADDWFC POSTINC0, F, ACCESS
18EA  CFEF     MOVFF INDF0, TBLPTRU
18EC  FFF8     NOP
18EE  22EE     ADDWFC POSTINC0, F, ACCESS
18F0  0008     TBLRD*
18F2  50F5     MOVF TABLAT, W, ACCESS
18F4  E1E9     BNZ 0x18C8
628:               
629:               /*
630:                * Second piece of information (length of data to send) is ready.
631:                * Call mUSBUSARTTxRom to setup the transfer.
632:                * The actual transfer process will be handled by CDCTxService(),
633:                * which should be called once per Main Program loop.
634:                */
635:           
636:               mUSBUSARTTxRom((ROM BYTE*)data,len); // See cdc.h
18F6  0EFB     MOVLW 0xFB
18F8  CFDB     MOVFF PLUSW2, pCDCSrc
18FA  FE91     NOP
18FC  0EFC     MOVLW 0xFC
18FE  CFDB     MOVFF PLUSW2, 0xE92
1900  FE92     NOP
1902  0EFD     MOVLW 0xFD
1904  CFDB     MOVFF PLUSW2, 0xE93
1906  FE93     NOP
1908  CFDF     MOVFF INDF2, cdc_tx_len
190A  FE97     NOP
190C  010E     MOVLB 0xE
190E  6B98     CLRF 0x98, BANKED
1910  0E01     MOVLW 0x1
1912  6F90     MOVWF 0x90, BANKED
637:           
638:           }//end putrsUSBUSART
1914  0E04     MOVLW 0x4
1916  5CE1     SUBWF FSR1L, W, ACCESS
1918  E202     BC 0x191E
191A  6AE1     CLRF FSR1L, ACCESS
191C  52E5     MOVF POSTDEC1, F, ACCESS
191E  6EE1     MOVWF FSR1L, ACCESS
1920  D083     BRA __pa_1
639:           
640:           /************************************************************************
641:             Function:
642:                   void CDCTxService(void)
643:               
644:             Summary:
645:               CDCTxService handles device-to-host transaction(s). This function
646:               should be called once per Main Program loop after the device reaches
647:               the configured state.
648:             Description:
649:               CDCTxService handles device-to-host transaction(s). This function
650:               should be called once per Main Program loop after the device reaches
651:               the configured state.
652:               
653:               Typical Usage:
654:               <code>
655:               void main(void)
656:               {
657:                   USBDeviceInit();
658:                   while(1)
659:                   {
660:                       USBDeviceTasks();
661:                       if((USBGetDeviceState() \< CONFIGURED_STATE) ||
662:                          (USBIsDeviceSuspended() == TRUE))
663:                       {
664:                           //Either the device is not configured or we are suspended
665:                           //  so we don't want to do execute any application code
666:                           continue;   //go back to the top of the while loop
667:                       }
668:                       else
669:                       {
670:                           //Keep trying to send data to the PC as required
671:                           CDCTxService();
672:               
673:                           //Run application code.
674:                           UserApplication();
675:                       }
676:                   }
677:               }
678:               </code>
679:             Conditions:
680:               None
681:             Remarks:
682:               None                                                                 
683:             ************************************************************************/
684:            
685:           void CDCTxService(void)
1922  D8C5     RCALL __pa_10
1A16  CFD9     MOVFF FSR2L, POSTINC1
1A18  FFE6     NOP
1A1A  CFDA     MOVFF FSR2H, POSTINC1
1A1C  FFE6     NOP
1A1E  CFE1     MOVFF FSR1L, FSR2L
1A20  FFD9     NOP
1A22  CFE2     MOVFF FSR1H, FSR2H
1A24  FFDA     NOP
1A26  0012     RETURN 0
686:           {
687:               BYTE byte_to_send;
688:               BYTE i;
689:               
690:               if(USBHandleBusy(CDCDataInHandle)) return;
1924  010E     MOVLB 0xE
1926  519B     MOVF 0x9B, W, BANKED
1928  119C     IORWF 0x9C, W, BANKED
192A  E102     BNZ 0x1930
192C  0E00     MOVLW 0x0
192E  D008     BRA 0x1940
1930  CE9B     MOVFF CDCDataInHandle, FSR0L
1932  FFE9     NOP
1934  CE9C     MOVFF 0xE9C, FSR0H
1936  FFEA     NOP
1938  50EF     MOVF INDF0, W, ACCESS
193A  0B80     ANDLW 0x80
193C  E001     BZ 0x1940
193E  0E01     MOVLW 0x1
1940  0900     IORLW 0x0
1942  E166     BNZ 0x1A10
691:               /*
692:                * Completing stage is necessary while [ mCDCUSartTxIsBusy()==1 ].
693:                * By having this stage, user can always check cdc_trf_state,
694:                * and not having to call mCDCUsartTxIsBusy() directly.
695:                */
696:               if(cdc_trf_state == CDC_TX_COMPLETING)
1944  0E03     MOVLW 0x3
1946  5D90     SUBWF 0x90, W, BANKED
1948  E101     BNZ 0x194C
697:                   cdc_trf_state = CDC_TX_READY;
194A  6B90     CLRF 0x90, BANKED
698:               
699:               /*
700:                * If CDC_TX_READY state, nothing to do, just return.
701:                */
702:               if(cdc_trf_state == CDC_TX_READY) return;
194C  5190     MOVF 0x90, W, BANKED
194E  E060     BZ 0x1A10
703:               
704:               /*
705:                * If CDC_TX_BUSY_ZLP state, send zero length packet
706:                */
707:               if(cdc_trf_state == CDC_TX_BUSY_ZLP)
1950  0E02     MOVLW 0x2
1952  5D90     SUBWF 0x90, W, BANKED
1954  E10F     BNZ 0x1974
708:               {
709:                   CDCDataInHandle = USBTxOnePacket(CDC_DATA_EP,NULL,0);
1956  6AE6     CLRF POSTINC1, ACCESS
1958  0E00     MOVLW 0x0
195A  6EE6     MOVWF POSTINC1, ACCESS
195C  6AE6     CLRF POSTINC1, ACCESS
195E  0E01     MOVLW 0x1
1960  6EE6     MOVWF POSTINC1, ACCESS
1962  D868     RCALL __pa_2
1964  E202     BC 0x196A
1966  6AE1     CLRF FSR1L, ACCESS
1968  52E5     MOVF POSTDEC1, F, ACCESS
196A  D88C     RCALL __pa_7
1A84  6EE1     MOVWF FSR1L, ACCESS
1A86  5014     MOVF __tmp_0, W, ACCESS
1A88  CFF3     MOVFF PRODL, CDCDataInHandle
1A8A  FE9B     NOP
1A8C  CFF4     MOVFF PRODH, 0xE9C
1A8E  FE9C     NOP
1A90  0012     RETURN 0
710:                   //CDC_DATA_BD_IN.CNT = 0;
711:                   cdc_trf_state = CDC_TX_COMPLETING;
196C  010E     MOVLB 0xE
196E  0E03     MOVLW 0x3
1970  6F90     MOVWF 0x90, BANKED
712:               }
713:               else if(cdc_trf_state == CDC_TX_BUSY)
1972  D04E     BRA 0x1A10
1974  0590     DECF 0x90, W, BANKED
1976  E14C     BNZ 0x1A10
714:               {
715:                   /*
716:                    * First, have to figure out how many byte of data to send.
717:                    */
718:               	if(cdc_tx_len > sizeof(cdc_data_tx))
1978  0E40     MOVLW 0x40
197A  6E14     MOVWF __tmp_0, ACCESS
197C  6A15     CLRF 0x15, ACCESS
197E  5197     MOVF 0x97, W, BANKED
1980  5C14     SUBWF __tmp_0, W, ACCESS
1982  0E00     MOVLW 0x0
1984  5815     SUBWFB 0x15, W, ACCESS
1986  E203     BC 0x198E
719:               	    byte_to_send = sizeof(cdc_data_tx);
1988  0E40     MOVLW 0x40
198A  6EDF     MOVWF INDF2, ACCESS
720:               	else
198C  D002     BRA 0x1992
721:               	    byte_to_send = cdc_tx_len;
198E  CE97     MOVFF cdc_tx_len, INDF2
1990  FFDF     NOP
722:           
723:                   /*
724:                    * Subtract the number of bytes just about to be sent from the total.
725:                    */
726:               	cdc_tx_len = cdc_tx_len - byte_to_send;
1992  50DF     MOVF INDF2, W, ACCESS
1994  5D97     SUBWF 0x97, W, BANKED
1996  6F97     MOVWF 0x97, BANKED
727:               	  
728:                   pCDCDst.bRam = (BYTE*)&cdc_data_tx; // Set destination pointer
1998  0E48     MOVLW 0x48
199A  6F94     MOVWF 0x94, BANKED
199C  0E0E     MOVLW 0xE
199E  6F95     MOVWF 0x95, BANKED
729:                   
730:                   i = byte_to_send;
19A0  0E01     MOVLW 0x1
19A2  CFDF     MOVFF INDF2, PLUSW2
19A4  FFDB     NOP
731:                   if(cdc_mem_type == _ROM)            // Determine type of memory source
19A6  5198     MOVF 0x98, W, BANKED
19A8  E110     BNZ 0x19CA
732:                   {
733:                       while(i)
19AA  0E01     MOVLW 0x1
19AC  50DB     MOVF PLUSW2, W, ACCESS
19AE  E019     BZ 0x19E2
19C8  D7F0     BRA 0x19AA
734:                       {
735:                           *pCDCDst.bRam = *pCDCSrc.bRom;
19B0  CE91     MOVFF pCDCSrc, TBLPTRL
19B2  FFF6     NOP
19B4  CE92     MOVFF 0xE92, TBLPTRH
19B6  FFF7     NOP
19B8  CE93     MOVFF 0xE93, TBLPTRU
19BA  FFF8     NOP
19BC  0008     TBLRD*
19BE  50F5     MOVF TABLAT, W, ACCESS
19C0  D841     RCALL __pa_3
1A44  CE94     MOVFF pCDCDst, FSR0L
1A46  FFE9     NOP
1A48  CE95     MOVFF 0xE95, FSR0H
1A4A  FFEA     NOP
1A4C  6EEF     MOVWF INDF0, ACCESS
736:                           pCDCDst.bRam++;
1A4E  2B94     INCF 0x94, F, BANKED
1A50  0E00     MOVLW 0x0
1A52  2395     ADDWFC 0x95, F, BANKED
737:                           pCDCSrc.bRom++;
19C2  2393     ADDWFC 0x93, F, BANKED
1A54  2B91     INCF 0x91, F, BANKED
1A56  2392     ADDWFC 0x92, F, BANKED
1A58  0012     RETURN 0
738:                           i--;
19C4  0E01     MOVLW 0x1
19C6  06DB     DECF PLUSW2, F, ACCESS
739:                       }//end while(byte_to_send)
740:                   }
741:                   else // _RAM
742:                   {
743:                       while(i)
19CA  0E01     MOVLW 0x1
19CC  50DB     MOVF PLUSW2, W, ACCESS
19CE  E009     BZ 0x19E2
19E0  D7F4     BRA 0x19CA
744:                       {
745:                           *pCDCDst.bRam = *pCDCSrc.bRam;
19D0  CE91     MOVFF pCDCSrc, FSR0L
19D2  FFE9     NOP
19D4  CE92     MOVFF 0xE92, FSR0H
19D6  FFEA     NOP
19D8  50EF     MOVF INDF0, W, ACCESS
19DA  D834     RCALL __pa_3
746:                           pCDCDst.bRam++;
747:                           pCDCSrc.bRam++;
748:                           i--;
19DC  0E01     MOVLW 0x1
19DE  06DB     DECF PLUSW2, F, ACCESS
749:                       }//end while(byte_to_send._word)
750:                   }//end if(cdc_mem_type...)
751:                   
752:                   /*
753:                    * Lastly, determine if a zero length packet state is necessary.
754:                    * See explanation in USB Specification 2.0: Section 5.8.3
755:                    */
756:                   if(cdc_tx_len == 0)
19E2  010E     MOVLB 0xE
19E4  5197     MOVF 0x97, W, BANKED
19E6  E107     BNZ 0x19F6
757:                   {
758:                       if(byte_to_send == CDC_DATA_IN_EP_SIZE)
19E8  0E40     MOVLW 0x40
19EA  5CDF     SUBWF INDF2, W, ACCESS
19EC  E102     BNZ 0x19F2
759:                           cdc_trf_state = CDC_TX_BUSY_ZLP;
19EE  0E02     MOVLW 0x2
760:                       else
19F0  D001     BRA 0x19F4
761:                           cdc_trf_state = CDC_TX_COMPLETING;
19F2  0E03     MOVLW 0x3
19F4  6F90     MOVWF 0x90, BANKED
762:                   }//end if(cdc_tx_len...)
763:                   CDCDataInHandle = USBTxOnePacket(CDC_DATA_EP,(BYTE*)&cdc_data_tx,byte_to_send);
19F6  CFDF     MOVFF INDF2, POSTINC1
19F8  FFE6     NOP
19FA  0E48     MOVLW 0x48
19FC  6EE6     MOVWF POSTINC1, ACCESS
19FE  0E0E     MOVLW 0xE
1A00  6EE6     MOVWF POSTINC1, ACCESS
1A02  0E01     MOVLW 0x1
1A04  6EE6     MOVWF POSTINC1, ACCESS
1A06  D816     RCALL __pa_2
1A08  E202     BC 0x1A0E
1A0A  6AE1     CLRF FSR1L, ACCESS
1A0C  52E5     MOVF POSTDEC1, F, ACCESS
1A0E  D83A     RCALL __pa_7
1A34  0E03     MOVLW 0x3
1A36  6EE6     MOVWF POSTINC1, ACCESS
1A38  EC64     CALL 0x24C8, 0
1A3A  F012     NOP
1A3C  6E14     MOVWF __tmp_0, ACCESS
1A3E  0E05     MOVLW 0x5
1A40  5CE1     SUBWF FSR1L, W, ACCESS
1A42  0012     RETURN 0
764:           
765:               }//end if(cdc_tx_sate == CDC_TX_BUSY)
766:               
767:           }//end CDCTxService
1A10  52E5     MOVF POSTDEC1, F, ACCESS
1A12  52E5     MOVF POSTDEC1, F, ACCESS
1A14  D009     BRA __pa_1
1A28  52E5     MOVF POSTDEC1, F, ACCESS
1A2A  CFE5     MOVFF POSTDEC1, FSR2H
1A2C  FFDA     NOP
1A2E  CFE7     MOVFF INDF1, FSR2L
1A30  FFD9     NOP
1A32  0012     RETURN 0
768:           
769:           #endif //USB_USE_CDC
770:           
771:           /** EOF cdc.c ****************************************************************/
---  E:/projects/CK-USB-04A/001/Microchip/USB/usb_device.c  ---------------------------------------------
1:             /********************************************************************
2:               File Information:
3:                 FileName:     	usb_device.c
4:                 Dependencies:	See INCLUDES section
5:                 Processor:		PIC18 or PIC24 USB Microcontrollers
6:                 Hardware:		The code is natively intended to be used on the following
7:                 				hardware platforms: PICDEM? FS USB Demo Board, 
8:                 				PIC18F87J50 FS USB Plug-In Module, or
9:                 				Explorer 16 + PIC24 USB PIM.  The firmware may be
10:                				modified for use on other USB platforms by editing the
11:                				HardwareProfile.h file.
12:                Complier:  	Microchip C18 (for PIC18) or C30 (for PIC24)
13:                Company:		Microchip Technology, Inc.
14:                
15:                Software License Agreement:
16:                
17:                The software supplied herewith by Microchip Technology Incorporated
18:                (the ?Company?) for its PIC Microcontroller is intended and
19:                supplied to you, the Company?s customer, for use solely and
20:                exclusively on Microchip PIC Microcontroller products. The
21:                software is owned by the Company and/or its supplier, and is
22:                protected under applicable copyright laws. All rights are reserved.
23:                Any use in violation of the foregoing restrictions may subject the
24:                user to criminal sanctions under applicable laws, as well as to
25:                civil liability for the breach of the terms and conditions of this
26:                license.
27:                
28:                THIS SOFTWARE IS PROVIDED IN AN ?AS IS? CONDITION. NO WARRANTIES,
29:                WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
30:                TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
31:                PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
32:                IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
33:                CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
34:            
35:              Summary:
36:                This file contains functions, macros, definitions, variables,
37:                datatypes, etc. that are required for usage with the MCHPFSUSB device
38:                stack. This file should be included in projects that use the device stack. 
39:                
40:                This file is located in the "\<Install Directory\>\\Microchip\\USB"
41:                directory.
42:            
43:              Description:
44:                USB Device Stack File
45:                
46:                This file contains functions, macros, definitions, variables,
47:                datatypes, etc. that are required for usage with the MCHPFSUSB device
48:                stack. This file should be included in projects that use the device stack.
49:                
50:                This file is located in the "\<Install Directory\>\\Microchip\\USB"
51:                directory.
52:                
53:                When including this file in a new project, this file can either be
54:                referenced from the directory in which it was installed or copied
55:                directly into the user application folder. If the first method is
56:                chosen to keep the file located in the folder in which it is installed
57:                then include paths need to be added so that the library and the
58:                application both know where to reference each others files. If the
59:                application folder is located in the same folder as the Microchip
60:                folder (like the current demo folders), then the following include
61:                paths need to be added to the application's project:
62:                
63:                ..\\Include
64:                
65:                ..\\..\\Include
66:                
67:                ..\\..\\MicrochipInclude
68:                
69:                ..\\..\\\<Application Folder\>
70:                
71:                ..\\..\\..\\\<Application Folder\>
72:                
73:                If a different directory structure is used, modify the paths as
74:                required. An example using absolute paths instead of relative paths
75:                would be the following:
76:                
77:                C:\\Microchip Solutions\\Microchip\\Include
78:                
79:                C:\\Microchip Solutions\\My Demo Application 
80:            
81:            ********************************************************************/
82:            
83:            /** INCLUDES *******************************************************/
84:            #include "GenericTypeDefs.h"
85:            #include "Compiler.h"
86:            #include "./USB/usb_ch9.h"
87:            #include "./USB/USB.h"
88:            #include "./USB/usb_device.h"
89:            #include "HardwareProfile.h"
90:            #include "usb_config.h"
91:            #include "user.h"
92:            
93:            #if defined(USB_USE_MSD)
94:                #include "./USB/usb_function_msd.h"
95:            #endif
96:            
97:            
98:            #if defined(__C32__)
99:                #if (USB_PING_PONG_MODE != USB_PING_PONG__FULL_PING_PONG)
100:                   #error "PIC32 only supports full ping pong mode.  A different mode other than full ping pong is selected in the usb_config.h file."
101:               #endif
102:           #endif
103:           
104:           //#define DEBUG_MODE
105:           
106:           #ifdef DEBUG_MODE
107:               #include "uart2.h"
108:           #endif
109:           
110:           /** VARIABLES ******************************************************/
111:           #pragma udata
112:           
113:           USB_VOLATILE BYTE USBDeviceState;
114:           USB_VOLATILE BYTE USBActiveConfiguration;
115:           USB_VOLATILE BYTE USBAlternateInterface[USB_MAX_NUM_INT];
116:           volatile BDT_ENTRY *pBDTEntryEP0OutCurrent;
117:           volatile BDT_ENTRY *pBDTEntryEP0OutNext;
118:           volatile BDT_ENTRY *pBDTEntryOut[USB_MAX_EP_NUMBER+1];
119:           volatile BDT_ENTRY *pBDTEntryIn[USB_MAX_EP_NUMBER+1];
120:           USB_VOLATILE BYTE shortPacketStatus;
121:           USB_VOLATILE BYTE controlTransferState;
122:           USB_VOLATILE IN_PIPE inPipes[1];
123:           USB_VOLATILE OUT_PIPE outPipes[1];
124:           USB_VOLATILE BYTE *pDst;
125:           USB_VOLATILE BOOL RemoteWakeup;
126:           USB_VOLATILE BYTE USTATcopy;
127:           USB_VOLATILE WORD USBInMaxPacketSize[USB_MAX_EP_NUMBER]; 
128:           USB_VOLATILE BYTE *USBInData[USB_MAX_EP_NUMBER];
129:           
130:           /** USB FIXED LOCATION VARIABLES ***********************************/
131:           #if defined(__18CXX)
132:               #if defined(__18F14K50) || defined(__18F13K50) || defined(__18LF14K50) || defined(__18LF13K50)
133:                   #pragma udata USB_BDT=0x200     //See Linker Script,usb2:0x200-0x2FF(256-byte)
134:               #else
135:                   #pragma udata USB_BDT=0x400     //See Linker Script,usb4:0x400-0x4FF(256-byte)
136:               #endif
137:           #endif
138:           
139:           /********************************************************************
140:            * Section A: Buffer Descriptor Table
141:            * - 0x400 - 0x4FF(max)
142:            * - USB_MAX_EP_NUMBER is defined in usb_config.h
143:            *******************************************************************/
144:           #if (USB_PING_PONG_MODE == USB_PING_PONG__NO_PING_PONG)
145:               volatile BDT_ENTRY BDT[(USB_MAX_EP_NUMBER + 1) * 2] __attribute__ ((aligned (512)));
146:           #elif (USB_PING_PONG_MODE == USB_PING_PONG__EP0_OUT_ONLY)
147:               volatile BDT_ENTRY BDT[((USB_MAX_EP_NUMBER + 1) * 2)+1] __attribute__ ((aligned (512)));
148:           #elif (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG)
149:               volatile BDT_ENTRY BDT[(USB_MAX_EP_NUMBER + 1) * 4] __attribute__ ((aligned (512)));
150:           #elif (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0)
151:               volatile BDT_ENTRY BDT[((USB_MAX_EP_NUMBER + 1) * 4)-2] __attribute__ ((aligned (512)));
152:           #else
153:               #error "No ping pong mode defined."
154:           #endif
155:           
156:           //#if defined(__18CXX)
157:           //#pragma udata usbram5=0x400     //See Linker Script,usb5:0x500-0x5FF(256-byte)
158:           //#endif
159:           
160:           /********************************************************************
161:            * Section B: EP0 Buffer Space
162:            *******************************************************************/
163:           volatile CTRL_TRF_SETUP SetupPkt;           // 8-byte only
164:           volatile BYTE CtrlTrfData[USB_EP0_BUFF_SIZE];
165:           
166:           /********************************************************************
167:            * Section C: non-EP0 Buffer Space
168:            *******************************************************************/
169:           // Can provide compile time option to do software pingpong
170:           #if defined(USB_USE_HID)
171:               volatile unsigned char hid_report_out[HID_INT_OUT_EP_SIZE];
172:               volatile unsigned char hid_report_in[HID_INT_IN_EP_SIZE];
173:           #endif
174:           
175:           #if defined(USB_USE_MSD)
176:           	//volatile far USB_MSD_CBW_CSW msd_cbw_csw;
177:           	volatile USB_MSD_CBW msd_cbw;
178:           	volatile USB_MSD_CSW msd_csw;
179:           	//#pragma udata
180:           
181:           	#if defined(__18CXX)
182:           		#pragma udata myMSD=MSD_BUFFER_ADDRESS
183:           	#endif
184:           	volatile char msd_buffer[512];
185:           #endif
186:           
187:           #if defined(__18CXX)
188:           #pragma udata
189:           #endif
190:           
191:           /** DECLARATIONS ***************************************************/
192:           #pragma code
193:           
194:           //DOM-IGNORE-BEGIN
195:           /****************************************************************************
196:             Function:
197:               void USBDeviceInit(void)
198:           
199:             Description:
200:               This function initializes the device stack
201:               it in the default state
202:           
203:             Precondition:
204:               None
205:           
206:             Parameters:
207:               None
208:           
209:             Return Values:
210:               None
211:           
212:             Remarks:
213:               The USB module will be completely reset including
214:               all of the internal variables, registers, and
215:               interrupt flags.
216:             ***************************************************************************/
217:           //DOM-IGNORE-END
218:           void USBDeviceInit(void)
1C20  ECB0     CALL 0x2560, 0
1C22  F012     NOP
219:           {
220:               BYTE i;
221:           
222:               // Clear all USB error flags
223:               USBClearInterruptRegister(U1EIR);  
1C24  6A63     CLRF UEIR, ACCESS
224:                  
225:               // Clears all USB interrupts          
226:               USBClearInterruptRegister(U1IR); 
1C26  6A62     CLRF UIR, ACCESS
227:                                  
228:               U1EIE = 0x9F;                   // Unmask all USB error interrupts
1C28  010F     MOVLB 0xF
1C2A  0E9F     MOVLW 0x9F
1C2C  6F37     MOVWF 0x37, BANKED
229:               U1IE = 0xFB;                    // Enable all interrupts except ACTVIE
1C2E  0EFB     MOVLW 0xFB
1C30  6F36     MOVWF 0x36, BANKED
230:           
231:               //power up the module
232:               USBPowerModule();
233:           
234:               //set the address of the BDT (if applicable)
235:               USBSetBDTAddress(BDT);
236:           
237:               // Reset all of the Ping Pong buffers
238:               USBPingPongBufferReset = 1;                    
1C32  8C65     BSF UCON, 6, ACCESS
239:               USBPingPongBufferReset = 0;
1C34  9C65     BCF UCON, 6, ACCESS
240:           
241:               // Reset to default address
242:               U1ADDR = 0x00;                   
1C36  6B38     CLRF 0x38, BANKED
243:           
244:               //Clear all of the endpoint control registers
245:               memset((void*)&U1EP1,0x00,(USB_MAX_EP_NUMBER-1));
1C38  EC12     CALL 0x2624, 0
1C3A  F013     NOP
1C3C  E202     BC 0x1C42
1C3E  6AE1     CLRF FSR1L, ACCESS
1C40  52E5     MOVF POSTDEC1, F, ACCESS
1C42  6EE1     MOVWF FSR1L, ACCESS
1C44  5014     MOVF __tmp_0, W, ACCESS
2624  0E02     MOVLW 0x2
2626  6EE6     MOVWF POSTINC1, ACCESS
2628  6AE6     CLRF POSTINC1, ACCESS
262A  6AE6     CLRF POSTINC1, ACCESS
262C  0E27     MOVLW 0x27
262E  6EE6     MOVWF POSTINC1, ACCESS
2630  0E0F     MOVLW 0xF
2632  EF91     GOTO 0x2722
2634  F013     NOP
246:           
247:               //Clear all of the BDT entries
248:               for(i=0;i<(sizeof(BDT)/sizeof(BDT_ENTRY));i++)
1C46  6ADF     CLRF INDF2, ACCESS
1C48  EC34     CALL 0x2668, 0
1C4A  F013     NOP
1C4C  E210     BC 0x1C6E
1C6A  2ADF     INCF INDF2, F, ACCESS
1C6C  D7ED     BRA 0x1C48
2668  50DF     MOVF INDF2, W, ACCESS
266A  6E14     MOVWF __tmp_0, ACCESS
266C  6A15     CLRF 0x15, ACCESS
266E  0E08     MOVLW 0x8
2670  5C14     SUBWF __tmp_0, W, ACCESS
2672  0E00     MOVLW 0x0
2674  5815     SUBWFB 0x15, W, ACCESS
2676  0012     RETURN 0
249:               {
250:                   BDT[i].Val = 0x00;
1C4E  50DF     MOVF INDF2, W, ACCESS
1C50  0D04     MULLW 0x4
1C52  CFF3     MOVFF PRODL, FSR0L
1C54  FFE9     NOP
1C56  CFF4     MOVFF PRODH, FSR0H
1C58  FFEA     NOP
1C5A  0E00     MOVLW 0x0
1C5C  26E9     ADDWF FSR0L, F, ACCESS
1C5E  0E04     MOVLW 0x4
1C60  22EA     ADDWFC FSR0H, F, ACCESS
1C62  6AEE     CLRF POSTINC0, ACCESS
1C64  6AEE     CLRF POSTINC0, ACCESS
1C66  6AEE     CLRF POSTINC0, ACCESS
1C68  6AEE     CLRF POSTINC0, ACCESS
251:               }
252:           
253:               // Initialize EP0 as a Ctrl EP
254:               U1EP0 = EP_CTRL|USB_HANDSHAKE_ENABLED;        
1C6E  010F     MOVLB 0xF
1C70  0E16     MOVLW 0x16
1C72  6F26     MOVWF 0x26, BANKED
255:           
256:               // Flush any pending transactions
257:               while(USBTransactionCompleteIF == 1)      
1C74  A662     BTFSS UIR, 3, ACCESS
1C76  D004     BRA 0x1C80
1C7E  D7FA     BRA 0x1C74
258:               {
259:                   USBClearInterruptFlag(USBTransactionCompleteIFReg,USBTransactionCompleteIFBitNum);
1C78  0E03     MOVLW 0x3
1C7A  ECD4     CALL 0x25A8, 0
1C7C  F012     NOP
260:               }
261:           
262:               //clear all of the internal pipe information
263:               inPipes[0].info.Val = 0;
1C80  0104     MOVLB 0x4
1C82  6B4C     CLRF 0x4C, BANKED
264:               outPipes[0].info.Val = 0;
1C84  6B51     CLRF 0x51, BANKED
265:               outPipes[0].wCount.Val = 0;
1C86  6B52     CLRF 0x52, BANKED
1C88  6B53     CLRF 0x53, BANKED
266:           
267:               // Make sure packet processing is enabled
268:               USBPacketDisable = 0;           
1C8A  9865     BCF UCON, 4, ACCESS
269:           
270:               //Get ready for the first packet
271:               pBDTEntryIn[0] = (volatile BDT_ENTRY*)&BDT[EP0_IN_EVEN];
1C8C  0E04     MOVLW 0x4
1C8E  6F3F     MOVWF 0x3F, BANKED
1C90  0E04     MOVLW 0x4
1C92  6F40     MOVWF 0x40, BANKED
272:           
273:               // Clear active configuration
274:               USBActiveConfiguration = 0;     
1C94  6B31     CLRF 0x31, BANKED
275:           
276:               //Indicate that we are now in the detached state        
277:               USBDeviceState = DETACHED_STATE;
1C96  6B30     CLRF 0x30, BANKED
278:           }
1C98  EFD2     GOTO 0x25A4
1C9A  F012     NOP
279:           
280:           //DOM-IGNORE-BEGIN
281:           /****************************************************************************
282:             Function:
283:               void USBDeviceTasks(void)
284:           
285:             Description:
286:               This function is the main state machine of the 
287:               USB device side stack.  This function should be
288:               called periodically to receive and transmit
289:               packets through the stack.  This function should
290:               be called  preferably once every 100us 
291:               during the enumeration process.  After the
292:               enumeration process this function still needs to
293:               be called periodically to respond to various
294:               situations on the bus but is more relaxed in its
295:               time requirements.  This function should also
296:               be called at least as fast as the OUT data
297:               expected from the PC.
298:           
299:             Precondition:
300:               None
301:           
302:             Parameters:
303:               None
304:           
305:             Return Values:
306:               None
307:           
308:             Remarks:
309:               None
310:             ***************************************************************************/
311:           //DOM-IGNORE-END
312:           void USBDeviceTasks(void)
1C9C  ECB0     CALL 0x2560, 0
1C9E  F012     NOP
313:           {
314:               BYTE i;
315:           
316:           #ifdef USB_SUPPORT_OTG
317:               //SRP Time Out Check
318:               if (USBOTGSRPIsReady())
319:               {
320:                   if (USBT1MSECIF && USBT1MSECIE)
321:                   {
322:                       if (USBOTGGetSRPTimeOutFlag())
323:                       {
324:                           if (USBOTGIsSRPTimeOutExpired())
325:                           {
326:                               USB_OTGEventHandler(0,OTG_EVENT_SRP_FAILED,0,0);
327:                           }       
328:                       }
329:           
330:                       //Clear Interrupt Flag
331:                       USBClearInterruptFlag(USBT1MSECIFReg,USBT1MSECIFBitNum);
332:                   }
333:               }
334:           #endif
335:           
336:               if (USB_BUS_SENSE != 1)
337:               {
338:                    // Disable module & detach from bus
339:                    U1CON = 0;             
340:           
341:                    // Mask all USB interrupts              
342:                    U1IE = 0;          
343:           
344:                    //Move to the detached state                  
345:                    USBDeviceState = DETACHED_STATE;
346:           
347:                    #ifdef  USB_SUPPORT_OTG    
348:                        //Disable D+ Pullup
349:                        U1OTGCONbits.DPPULUP = 0;
350:           
351:                        //Disable HNP
352:                        USBOTGDisableHnp();
353:           
354:                        //Deactivate HNP
355:                        USBOTGDeactivateHnp();
356:                        
357:                        //If ID Pin Changed State
358:                        if (USBIDIF && USBIDIE)
359:                        {  
360:                            //Re-detect & Initialize
361:                             USBOTGInitialize();
362:           
363:                             //Clear ID Interrupt Flag
364:                             USBClearInterruptFlag(USBIDIFReg,USBIDIFBitNum);
365:                        }
366:                    #endif
367:           
368:                    #ifdef __C30__
369:                        //USBClearInterruptFlag(U1OTGIR, 3); 
370:                    #endif
371:                       //return so that we don't go through the rest of 
372:                       //the state machine
373:                     return;
374:               }
375:           
376:           #ifdef USB_SUPPORT_OTG
377:               //If Session Is Started Then
378:              else
379:              {
380:                   //If SRP Is Ready
381:                   if (USBOTGSRPIsReady())
382:                   {   
383:                       //Clear SRPReady
384:                       USBOTGClearSRPReady();
385:           
386:                       //Clear SRP Timeout Flag
387:                       USBOTGClearSRPTimeOutFlag();
388:           
389:                       //Indicate Session Started
390:                       UART2PrintString( "\r\n***** USB OTG B Event - Session Started  *****\r\n" );
391:                   }
392:               }
393:           #endif
394:           
395:               //if we are in the detached state
396:               if(USBDeviceState == DETACHED_STATE)
1CA0  0104     MOVLB 0x4
1CA2  5130     MOVF 0x30, W, BANKED
1CA4  E10D     BNZ 0x1CC0
397:               {
398:                   //#if defined(__18CXX)
399:                       U1CON = 0;                           // Disable module & detach from bus
1CA6  6A65     CLRF UCON, ACCESS
400:                   //#else
401:                   //#endif
402:           
403:                   // Mask all USB interrupts
404:                   U1IE = 0;                                
1CA8  010F     MOVLB 0xF
1CAA  6B36     CLRF 0x36, BANKED
405:           
406:                   // Enable module & attach to bus
407:                   while(!U1CONbits.USBEN){U1CONbits.USBEN = 1;}
1CAC  B665     BTFSC UCON, 3, ACCESS
1CAE  D002     BRA 0x1CB4
1CB0  8665     BSF UCON, 3, ACCESS
1CB2  D7FC     BRA 0x1CAC
408:           
409:                   //moved to the attached state
410:                   USBDeviceState = ATTACHED_STATE;
1CB4  0104     MOVLB 0x4
1CB6  0E01     MOVLW 0x1
1CB8  6F30     MOVWF 0x30, BANKED
411:           
412:                   //Enable/set things like: pull ups, full/low-speed mode, 
413:                   //set the ping pong mode, and set internal transceiver
414:                   SetConfigurationOptions();
1CBA  010F     MOVLB 0xF
1CBC  0E14     MOVLW 0x14
1CBE  6F39     MOVWF 0x39, BANKED
415:           
416:                   #ifdef  USB_SUPPORT_OTG
417:                       U1OTGCON = USB_OTG_DPLUS_ENABLE | USB_OTG_ENABLE;  
418:                   #endif
419:               }
420:           
421:               if(USBDeviceState == ATTACHED_STATE)
1CC0  0104     MOVLB 0x4
1CC2  0530     DECF 0x30, W, BANKED
1CC4  E10A     BNZ 0x1CDA
422:               {
423:                   /*
424:                    * After enabling the USB module, it takes some time for the
425:                    * voltage on the D+ or D- line to rise high enough to get out
426:                    * of the SE0 condition. The USB Reset interrupt should not be
427:                    * unmasked until the SE0 condition is cleared. This helps
428:                    * prevent the firmware from misinterpreting this unique event
429:                    * as a USB bus reset from the USB host.
430:                    */
431:           
432:                   if(!USBSE0Event)
1CC6  BA65     BTFSC UCON, 5, ACCESS
1CC8  D008     BRA 0x1CDA
433:                   {
434:                       USBClearInterruptRegister(U1IR);// Clear all USB interrupts
1CCA  6A62     CLRF UIR, ACCESS
435:                       U1IE=0;                        // Mask all USB interrupts
1CCC  010F     MOVLB 0xF
1CCE  6B36     CLRF 0x36, BANKED
436:                       USBResetIE = 1;             // Unmask RESET interrupt
1CD0  8136     BSF 0x36, 0, BANKED
437:                       USBIdleIE = 1;             // Unmask IDLE interrupt
1CD2  8936     BSF 0x36, 4, BANKED
438:                       USBDeviceState = POWERED_STATE;
1CD4  0104     MOVLB 0x4
1CD6  0E02     MOVLW 0x2
1CD8  6F30     MOVWF 0x30, BANKED
439:                   }
440:               }
441:           
442:               #ifdef  USB_SUPPORT_OTG
443:                   //If ID Pin Changed State
444:                   if (USBIDIF && USBIDIE)
445:                   {  
446:                       //Re-detect & Initialize
447:                       USBOTGInitialize();
448:           
449:                       USBClearInterruptFlag(USBIDIFReg,USBIDIFBitNum);
450:                   }
451:               #endif
452:           
453:               /*
454:                * Task A: Service USB Activity Interrupt
455:                */
456:               if(USBActivityIF && USBActivityIE)
1CDA  5062     MOVF UIR, W, ACCESS
1CDC  0B04     ANDLW 0x4
1CDE  E005     BZ 0x1CEA
1CE0  010F     MOVLB 0xF
1CE2  5136     MOVF 0x36, W, BANKED
1CE4  0B04     ANDLW 0x4
1CE6  E001     BZ 0x1CEA
457:               {
458:                   #if defined(USB_SUPPORT_OTG)
459:                   USBClearInterruptFlag(USBActivityIFReg,USBActivityIFBitNum);
460:                       U1OTGIR = 0x10;        
461:                   #else
462:                       USBWakeFromSuspend();
1CE8  D874     RCALL USBWakeFromSuspend
463:                   #endif
464:               }
465:           
466:               /*
467:                * Pointless to continue servicing if the device is in suspend mode.
468:                */
469:               if(USBSuspendControl==1)
1CEA  B265     BTFSC UCON, 1, ACCESS
1CEC  D053     BRA 0x1D94
470:               {
471:                   return;
472:               }
473:           
474:               /*
475:                * Task B: Service USB Bus Reset Interrupt.
476:                * When bus reset is received during suspend, ACTVIF will be set first,
477:                * once the UCONbits.SUSPND is clear, then the URSTIF bit will be asserted.
478:                * This is why URSTIF is checked after ACTVIF.
479:                *
480:                * The USB reset flag is masked when the USB state is in
481:                * DETACHED_STATE or ATTACHED_STATE, and therefore cannot
482:                * cause a USB reset event during these two states.
483:                */
484:               if(USBResetIF && USBResetIE)
1CEE  5062     MOVF UIR, W, ACCESS
1CF0  0B01     ANDLW 0x1
1CF2  E012     BZ 0x1D18
1CF4  010F     MOVLB 0xF
1CF6  5136     MOVF 0x36, W, BANKED
1CF8  0B01     ANDLW 0x1
1CFA  E00E     BZ 0x1D18
485:               {
486:                   USBDeviceInit();
1CFC  DF91     RCALL USBDeviceInit
487:                   USBDeviceState = DEFAULT_STATE;
1CFE  0104     MOVLB 0x4
1D00  0E04     MOVLW 0x4
1D02  6F30     MOVWF 0x30, BANKED
488:           
489:                   /********************************************************************
490:                   Bug Fix: Feb 26, 2007 v2.1 (#F1)
491:                   *********************************************************************
492:                   In the original firmware, if an OUT token is sent by the host
493:                   before a SETUP token is sent, the firmware would respond with an ACK.
494:                   This is not a correct response, the firmware should have sent a STALL.
495:                   This is a minor non-compliance since a compliant host should not
496:                   send an OUT before sending a SETUP token. The fix allows a SETUP
497:                   transaction to be accepted while stalling OUT transactions.
498:                   ********************************************************************/
499:                   BDT[EP0_OUT_EVEN].ADR = (BYTE*)ConvertToPhysicalAddress(&SetupPkt);
1D04  0104     MOVLB 0x4
1D06  0E20     MOVLW 0x20
1D08  6F02     MOVWF pUEP, BANKED
1D0A  0E04     MOVLW 0x4
1D0C  6F03     MOVWF temp, BANKED
500:                   BDT[EP0_OUT_EVEN].CNT = USB_EP0_BUFF_SIZE;
1D0E  0E08     MOVLW 0x8
1D10  6F01     MOVWF p, BANKED
501:                   BDT[EP0_OUT_EVEN].STAT.Val &= ~_STAT_MASK;
1D12  6B00     CLRF i, BANKED
502:                   BDT[EP0_OUT_EVEN].STAT.Val |= _USIE|_DAT0|_DTSEN|_BSTALL;
1D14  0E8C     MOVLW 0x8C
1D16  1300     IORWF i, F, BANKED
503:           
504:                   #ifdef USB_SUPPORT_OTG
505:                        //Disable HNP
506:                        USBOTGDisableHnp();
507:           
508:                        //Deactivate HNP
509:                        USBOTGDeactivateHnp();
510:                   #endif
511:               }
512:           
513:               /*
514:                * Task C: Service other USB interrupts
515:                */
516:               if(USBIdleIF && USBIdleIE)
1D18  5062     MOVF UIR, W, ACCESS
1D1A  0B10     ANDLW 0x10
1D1C  E008     BZ 0x1D2E
1D1E  010F     MOVLB 0xF
1D20  5136     MOVF 0x36, W, BANKED
1D22  0B10     ANDLW 0x10
1D24  E004     BZ 0x1D2E
517:               { 
518:                   #ifdef  USB_SUPPORT_OTG 
519:                       //If Suspended, Try to switch to Host
520:                       USBOTGSelectRole(ROLE_HOST);
521:                   #else
522:                       USBSuspend();
1D26  D84D     RCALL USBSuspend
523:                   #endif
524:                   
525:                   USBClearInterruptFlag(USBIdleIFReg,USBIdleIFBitNum);
1D28  0E04     MOVLW 0x4
1D2A  ECD4     CALL 0x25A8, 0
1D2C  F012     NOP
526:               }
527:           
528:               if(USBSOFIF && USBSOFIE)
1D2E  5062     MOVF UIR, W, ACCESS
1D30  0B40     ANDLW 0x40
1D32  E009     BZ 0x1D46
1D34  010F     MOVLB 0xF
1D36  5136     MOVF 0x36, W, BANKED
1D38  0B40     ANDLW 0x40
1D3A  E005     BZ 0x1D46
529:               {
530:                   USBCB_SOF_Handler();    // Required callback, see usbcallbacks.c
1D3C  ECC1     CALL 0x1B82, 0
1D3E  F00D     NOP
531:                   USBClearInterruptFlag(USBSOFIFReg,USBSOFIFBitNum);
1D40  0E06     MOVLW 0x6
1D42  ECD4     CALL 0x25A8, 0
1D44  F012     NOP
532:               }
533:           
534:               if(USBStallIF && USBStallIE)
1D46  5062     MOVF UIR, W, ACCESS
1D48  0B20     ANDLW 0x20
1D4A  E005     BZ 0x1D56
1D4C  010F     MOVLB 0xF
1D4E  5136     MOVF 0x36, W, BANKED
1D50  0B20     ANDLW 0x20
1D52  E001     BZ 0x1D56
535:               {
536:                   USBStallHandler();
1D54  D821     RCALL USBStallHandler
537:               }
538:           
539:               if(USBErrorIF && USBErrorIE)
1D56  5062     MOVF UIR, W, ACCESS
1D58  0B02     ANDLW 0x2
1D5A  E007     BZ 0x1D6A
1D5C  010F     MOVLB 0xF
1D5E  5136     MOVF 0x36, W, BANKED
1D60  0B02     ANDLW 0x2
1D62  E003     BZ 0x1D6A
540:               {
541:                   USBCBErrorHandler();    // Required callback, see usbcallbacks.c
1D64  ECC2     CALL 0x1B84, 0
1D66  F00D     NOP
542:                   USBClearInterruptRegister(U1EIR);               // This clears UERRIF
1D68  6A63     CLRF UEIR, ACCESS
543:               }
544:           
545:               /*
546:                * Pointless to continue servicing if the host has not sent a bus reset.
547:                * Once bus reset is received, the device transitions into the DEFAULT
548:                * state and is ready for communication.
549:                */
550:               if(USBDeviceState < DEFAULT_STATE) return;
1D6A  0E04     MOVLW 0x4
1D6C  0104     MOVLB 0x4
1D6E  5D30     SUBWF 0x30, W, BANKED
1D70  E311     BNC 0x1D94
551:           
552:               /*
553:                * Task D: Servicing USB Transaction Complete Interrupt
554:                */
555:               if(USBTransactionCompleteIE)
1D72  010F     MOVLB 0xF
1D74  A736     BTFSS 0x36, 3, BANKED
1D76  D00E     BRA 0x1D94
556:               {
557:           	    for(i = 0; i < 4; i++)	//Drain or deplete the USAT FIFO entries.  If the USB FIFO ever gets full, USB bandwidth 
1D78  6ADF     CLRF INDF2, ACCESS
1D7A  0E04     MOVLW 0x4
1D7C  5CDF     SUBWF INDF2, W, ACCESS
1D7E  E20A     BC 0x1D94
1D90  2ADF     INCF INDF2, F, ACCESS
1D92  D7F3     BRA 0x1D7A
558:           		{						//utilization can be compromised, and the device won't be able to receive SETUP packets.
559:           		    if(USBTransactionCompleteIF)
1D80  A662     BTFSS UIR, 3, ACCESS
1D82  D008     BRA 0x1D94
560:           		    {
561:           		        USTATcopy = U1STAT;
1D84  CF64     MOVFF USTAT, USTATcopy
1D86  F45A     NOP
562:           
563:           		        USBClearInterruptFlag(USBTransactionCompleteIFReg,USBTransactionCompleteIFBitNum);
1D88  0E03     MOVLW 0x3
1D8A  ECD4     CALL 0x25A8, 0
1D8C  F012     NOP
564:           		
565:           		        /*
566:           		         * USBCtrlEPService only services transactions over EP0.
567:           		         * It ignores all other EP transactions.
568:           		         */
569:           		        USBCtrlEPService();
1D8E  D82C     RCALL USBCtrlEPService
570:           		    }//end if(USBTransactionCompleteIF)
571:           		    else
572:           		    	break;	//USTAT FIFO must be empty.
573:           		}//end for()
574:           	}//end if(USBTransactionCompleteIE)
575:           
576:           }//end of USBDeviceTasks()
1D94  EFD2     GOTO 0x25A4
1D96  F012     NOP
577:           
578:           /********************************************************************
579:            * Function:        void USBStallHandler(void)
580:            *
581:            * PreCondition:    None
582:            *
583:            * Input:           None
584:            *
585:            * Output:          None
586:            *
587:            * Side Effects:    
588:            *
589:            * Overview:        This function handles the event of a STALL 
590:            *                  occuring on the bus
591:            *
592:            * Note:            None
593:            *******************************************************************/
594:           void USBStallHandler(void)
595:           {
596:               /*
597:                * Does not really have to do anything here,
598:                * even for the control endpoint.
599:                * All BDs of Endpoint 0 are owned by SIE right now,
600:                * but once a Setup Transaction is received, the ownership
601:                * for EP0_OUT will be returned to CPU.
602:                * When the Setup Transaction is serviced, the ownership
603:                * for EP0_IN will then be forced back to CPU by firmware.
604:                */
605:           
606:               /* v2b fix */
607:               if(U1EP0bits.EPSTALL == 1)
1D98  010F     MOVLB 0xF
1D9A  A126     BTFSS 0x26, 0, BANKED
1D9C  D00F     BRA 0x1DBC
608:               {
609:                   // UOWN - if 0, owned by CPU, if 1, owned by SIE
610:                   if((pBDTEntryEP0OutCurrent->STAT.Val == _USIE) && (pBDTEntryIn[0]->STAT.Val == (_USIE|_BSTALL)))
1D9E  ECF5     CALL 0x25EA, 0
1DA0  F012     NOP
1DA2  50EF     MOVF INDF0, W, ACCESS
1DA4  0880     SUBLW 0x80
1DA6  E109     BNZ 0x1DBA
1DA8  ECDE     CALL 0x25BC, 0
1DAA  F012     NOP
1DAC  50EF     MOVF INDF0, W, ACCESS
1DAE  0884     SUBLW 0x84
1DB0  E104     BNZ 0x1DBA
611:                   {
612:                       // Set ep0Bo to stall also
613:                       pBDTEntryEP0OutCurrent->STAT.Val = _USIE|_DAT0|_DTSEN|_BSTALL;
1DB2  ECF5     CALL 0x25EA, 0
1DB4  F012     NOP
1DB6  0E8C     MOVLW 0x8C
1DB8  6EEF     MOVWF INDF0, ACCESS
614:                   }//end if
615:                   U1EP0bits.EPSTALL = 0;               // Clear stall status
1DBA  9126     BCF 0x26, 0, BANKED
616:               }//end if
617:           
618:               USBClearInterruptFlag(USBStallIFReg,USBStallIFBitNum);
1DBC  0E05     MOVLW 0x5
1DBE  EFD4     GOTO 0x25A8
1DC0  F012     NOP
619:           }
620:           
621:           /********************************************************************
622:            * Function:        void USBSuspend(void)
623:            *
624:            * PreCondition:    None
625:            *
626:            * Input:           None
627:            *
628:            * Output:          None
629:            *
630:            * Side Effects:    
631:            *
632:            * Overview:        This function handles if the host tries to 
633:            *                  suspend the device
634:            *
635:            * Note:            None
636:            *******************************************************************/
637:           void USBSuspend(void)
638:           {
639:               /*
640:                * NOTE: Do not clear UIRbits.ACTVIF here!
641:                * Reason:
642:                * ACTVIF is only generated once an IDLEIF has been generated.
643:                * This is a 1:1 ratio interrupt generation.
644:                * For every IDLEIF, there will be only one ACTVIF regardless of
645:                * the number of subsequent bus transitions.
646:                *
647:                * If the ACTIF is cleared here, a problem could occur when:
648:                * [       IDLE       ][bus activity ->
649:                * <--- 3 ms ----->     ^
650:                *                ^     ACTVIF=1
651:                *                IDLEIF=1
652:                *  #           #           #           #   (#=Program polling flags)
653:                *                          ^
654:                *                          This polling loop will see both
655:                *                          IDLEIF=1 and ACTVIF=1.
656:                *                          However, the program services IDLEIF first
657:                *                          because ACTIVIE=0.
658:                *                          If this routine clears the only ACTIVIF,
659:                *                          then it can never get out of the suspend
660:                *                          mode.
661:                */
662:               USBActivityIE = 1;                     // Enable bus activity interrupt
1DC2  010F     MOVLB 0xF
1DC4  8536     BSF 0x36, 2, BANKED
663:               USBClearInterruptFlag(USBIdleIFReg,USBIdleIFBitNum);
1DC6  0E04     MOVLW 0x4
1DC8  ECD4     CALL 0x25A8, 0
1DCA  F012     NOP
664:           
665:           #if defined(__18CXX)
666:               U1CONbits.SUSPND = 1;                   // Put USB module in power conserve
1DCC  8265     BSF UCON, 1, ACCESS
667:                                                       // mode, SIE clock inactive
668:           #endif
669:            
670:            
671:               /*
672:                * At this point the PIC can go into sleep,idle, or
673:                * switch to a slower clock, etc.  This should be done in the
674:                * USBCBSuspend() if necessary.
675:                */
676:               USBCBSuspend();             // Required callback, see usbcallbacks.c
1DCE  EFBF     GOTO 0x1B7E
1DD0  F00D     NOP
677:           }
678:           
679:           /********************************************************************
680:            * Function:        void USBWakeFromSuspend(void)
681:            *
682:            * PreCondition:    None
683:            *
684:            * Input:           None
685:            *
686:            * Output:          None
687:            *
688:            * Side Effects:    None
689:            *
690:            * Overview:
691:            *
692:            * Note:            None
693:            *******************************************************************/
694:           void USBWakeFromSuspend(void)
695:           {
696:               #if defined(__18CXX)
697:               U1CONbits.SUSPND = 0;                   // Bring USB module out of power conserve
1DD2  9265     BCF UCON, 1, ACCESS
698:                                                       // mode.
699:               #endif
700:           
701:               /*
702:                * If using clock switching, the place to restore the original
703:                * microcontroller core clock frequency is in the USBCBWakeFromSuspend() callback
704:                */
705:               USBCBWakeFromSuspend(); // Required callback, see usbcallbacks.c
1DD4  ECC0     CALL 0x1B80, 0
1DD6  F00D     NOP
706:           
707:               USBActivityIE = 0;
1DD8  010F     MOVLB 0xF
1DDA  9536     BCF 0x36, 2, BANKED
708:           
709:               /********************************************************************
710:               Bug Fix: Feb 26, 2007 v2.1
711:               *********************************************************************
712:               The ACTVIF bit cannot be cleared immediately after the USB module wakes
713:               up from Suspend or while the USB module is suspended. A few clock cycles
714:               are required to synchronize the internal hardware state machine before
715:               the ACTIVIF bit can be cleared by firmware. Clearing the ACTVIF bit
716:               before the internal hardware is synchronized may not have an effect on
717:               the value of ACTVIF. Additonally, if the USB module uses the clock from
718:               the 96 MHz PLL source, then after clearing the SUSPND bit, the USB
719:               module may not be immediately operational while waiting for the 96 MHz
720:               PLL to lock.
721:               ********************************************************************/
722:           
723:               // UIRbits.ACTVIF = 0;                      // Removed
724:               #if defined(__18CXX)
725:               while(USBActivityIF)
1DDC  A462     BTFSS UIR, 2, ACCESS
1DDE  D003     BRA 0x1DE6
1DE4  D7FB     BRA 0x1DDC
726:               #endif
727:               {
728:                   USBClearInterruptFlag(USBActivityIFReg,USBActivityIFBitNum);
1DE0  0E02     MOVLW 0x2
1DE2  DBE2     RCALL __pa_4
25A8  6EE6     MOVWF POSTINC1, ACCESS
25AA  0E62     MOVLW 0x62
25AC  6EE6     MOVWF POSTINC1, ACCESS
25AE  0E0F     MOVLW 0xF
25B0  6EE6     MOVWF POSTINC1, ACCESS
25B2  DFBA     RCALL USBClearInterruptFlag
25B4  52E5     MOVF POSTDEC1, F, ACCESS
25B6  52E5     MOVF POSTDEC1, F, ACCESS
25B8  52E5     MOVF POSTDEC1, F, ACCESS
25BA  0012     RETURN 0
729:               }  // Added
730:           
731:           }//end USBWakeFromSuspend
1DE6  0012     RETURN 0
732:           
733:           /********************************************************************
734:            * Function:        void USBCtrlEPService(void)
735:            *
736:            * PreCondition:    USTAT is loaded with a valid endpoint address.
737:            *
738:            * Input:           None
739:            *
740:            * Output:          None
741:            *
742:            * Side Effects:    None
743:            *
744:            * Overview:        USBCtrlEPService checks for three transaction
745:            *                  types that it knows how to service and services
746:            *                  them:
747:            *                  1. EP0 SETUP
748:            *                  2. EP0 OUT
749:            *                  3. EP0 IN
750:            *                  It ignores all other types (i.e. EP1, EP2, etc.)
751:            *
752:            * Note:            None
753:            *******************************************************************/
754:           void USBCtrlEPService(void)
755:           {
756:           	//If the last packet was a EP0 OUT packet
757:               if((USTATcopy & USTAT_EP0_PP_MASK) == USTAT_EP0_OUT_EVEN)
1DE8  0EFD     MOVLW 0xFD
1DEA  0104     MOVLB 0x4
1DEC  155A     ANDWF 0x5A, W, BANKED
1DEE  E118     BNZ 0x1E20
758:               {
759:           		//Point to the EP0 OUT buffer of the buffer that arrived
760:                   #if defined(__18CXX)
761:                       pBDTEntryEP0OutCurrent = (volatile BDT_ENTRY*)&BDT[(USTATcopy & USTAT_EP_MASK)>>1];
1DF0  0E7E     MOVLW 0x7E
1DF2  155A     ANDWF 0x5A, W, BANKED
1DF4  40E8     RRNCF WREG, W, ACCESS
1DF6  0B7F     ANDLW 0x7F
1DF8  0D04     MULLW 0x4
1DFA  CFF3     MOVFF PRODL, pBDTEntryEP0OutCurrent
1DFC  F433     NOP
1DFE  CFF4     MOVFF PRODH, 0x434
1E00  F434     NOP
1E02  0E00     MOVLW 0x0
1E04  2733     ADDWF 0x33, F, BANKED
1E06  0E04     MOVLW 0x4
1E08  2334     ADDWFC 0x34, F, BANKED
762:                   #elif defined(__C30__) || defined(__C32__)
763:                       pBDTEntryEP0OutCurrent = (volatile BDT_ENTRY*)&BDT[(USTATcopy & USTAT_EP_MASK)>>2];
764:                   #else
765:                       #error "unimplemented"
766:                   #endif
767:           
768:           		//Set the next out to the current out packet
769:                   pBDTEntryEP0OutNext = pBDTEntryEP0OutCurrent;
1E0A  C433     MOVFF pBDTEntryEP0OutCurrent, pBDTEntryEP0OutNext
1E0C  F435     NOP
1E0E  C434     MOVFF 0x434, 0x436
1E10  F436     NOP
770:           		//Toggle it to the next ping pong buffer (if applicable)
771:                   ((BYTE_VAL*)&pBDTEntryEP0OutNext)->Val ^= USB_NEXT_EP0_OUT_PING_PONG;
772:           
773:           		//If the current EP0 OUT buffer has a SETUP token
774:                   if(pBDTEntryEP0OutCurrent->STAT.PID == SETUP_TOKEN)
1E12  EC83     CALL 0x2706, 0
1E14  F013     NOP
1E16  E102     BNZ 0x1E1C
2706  DF71     RCALL __pa_9
2708  50EF     MOVF INDF0, W, ACCESS
270A  0B3C     ANDLW 0x3C
270C  42E8     RRNCF WREG, F, ACCESS
270E  42E8     RRNCF WREG, F, ACCESS
2710  080D     SUBLW 0xD
2712  0012     RETURN 0
775:                   {
776:           			//Handle the control transfer
777:                       USBCtrlTrfSetupHandler();
1E18  EF16     GOTO 0x1E2C
1E1A  F00F     NOP
778:                   }
779:                   else
780:                   {
781:           			//Handle the DATA transfer
782:                       USBCtrlTrfOutHandler();
1E1C  EF27     GOTO 0x1E4E
1E1E  F00F     NOP
783:                   }
784:               }
785:               else if((USTATcopy & USTAT_EP0_PP_MASK) == USTAT_EP0_IN)
1E20  0EFD     MOVLW 0xFD
1E22  155A     ANDWF 0x5A, W, BANKED
1E24  0804     SUBLW 0x4
1E26  E101     BNZ 0x1E2A
786:               {
787:           		//Otherwise the transmission was and EP0 IN
788:           		//  so take care of the IN transfer
789:                   USBCtrlTrfInHandler();
1E28  D81A     RCALL USBCtrlTrfInHandler
790:               }
791:           
792:           }//end USBCtrlEPService
1E2A  0012     RETURN 0
793:           
794:           /********************************************************************
795:            * Function:        void USBCtrlTrfSetupHandler(void)
796:            *
797:            * PreCondition:    SetupPkt buffer is loaded with valid USB Setup Data
798:            *
799:            * Input:           None
800:            *
801:            * Output:          None
802:            *
803:            * Side Effects:    None
804:            *
805:            * Overview:        This routine is a task dispatcher and has 3 stages.
806:            *                  1. It initializes the control transfer state machine.
807:            *                  2. It calls on each of the module that may know how to
808:            *                     service the Setup Request from the host.
809:            *                     Module Example: USBD, HID, CDC, MSD, ...
810:            *                     A callback function, USBCBCheckOtherReq(),
811:            *                     is required to call other module handlers.
812:            *                  3. Once each of the modules has had a chance to check if
813:            *                     it is responsible for servicing the request, stage 3
814:            *                     then checks direction of the transfer to determine how
815:            *                     to prepare EP0 for the control transfer.
816:            *                     Refer to USBCtrlEPServiceComplete() for more details.
817:            *
818:            * Note:            Microchip USB Firmware has three different states for
819:            *                  the control transfer state machine:
820:            *                  1. WAIT_SETUP
821:            *                  2. CTRL_TRF_TX
822:            *                  3. CTRL_TRF_RX
823:            *                  Refer to firmware manual to find out how one state
824:            *                  is transitioned to another.
825:            *
826:            *                  A Control Transfer is composed of many USB transactions.
827:            *                  When transferring data over multiple transactions,
828:            *                  it is important to keep track of data source, data
829:            *                  destination, and data count. These three parameters are
830:            *                  stored in pSrc,pDst, and wCount. A flag is used to
831:            *                  note if the data source is from ROM or RAM.
832:            *
833:            *******************************************************************/
834:           void USBCtrlTrfSetupHandler(void)
835:           {
836:           	//if the SIE currently owns the buffer
837:               if(pBDTEntryIn[0]->STAT.UOWN != 0)
1E2C  DBC7     RCALL __pa_5
1E2E  50EF     MOVF INDF0, W, ACCESS
1E30  0B80     ANDLW 0x80
1E32  E002     BZ 0x1E38
838:               {
839:           		//give control back to the CPU
840:           		//  Compensate for after a STALL
841:                   pBDTEntryIn[0]->STAT.Val = _UCPU;           
1E34  DBC3     RCALL __pa_5
1E36  6AEF     CLRF INDF0, ACCESS
842:               }
843:           
844:           	//Keep track of if a short packet has been sent yet or not
845:               shortPacketStatus = SHORT_PKT_NOT_USED;
1E38  0104     MOVLB 0x4
1E3A  6B47     CLRF 0x47, BANKED
846:           
847:               /* Stage 1 */
848:               controlTransferState = WAIT_SETUP;
1E3C  6B48     CLRF 0x48, BANKED
849:           
850:               inPipes[0].wCount.Val = 0;
1E3E  6B4D     CLRF 0x4D, BANKED
1E40  6B4E     CLRF 0x4E, BANKED
851:               inPipes[0].info.Val = 0;
1E42  6B4C     CLRF 0x4C, BANKED
852:           
853:               /* Stage 2 */
854:               USBCheckStdRequest();
1E44  D891     RCALL USBCheckStdRequest
855:               USBCBCheckOtherReq();   // Required callback, see usbcallbacks.c
1E46  ECC3     CALL 0x1B86, 0
1E48  F00D     NOP
856:           
857:               /* Stage 3 */
858:               USBCtrlEPServiceComplete();
1E4A  EFE4     GOTO 0x21C8
1E4C  F010     NOP
859:           
860:           }//end USBCtrlTrfSetupHandler
861:           /******************************************************************************
862:            * Function:        void USBCtrlTrfOutHandler(void)
863:            *
864:            * PreCondition:    None
865:            *
866:            * Input:           None
867:            *
868:            * Output:          None
869:            *
870:            * Side Effects:    None
871:            *
872:            * Overview:        This routine handles an OUT transaction according to
873:            *                  which control transfer state is currently active.
874:            *
875:            * Note:            Note that if the the control transfer was from
876:            *                  host to device, the session owner should be notified
877:            *                  at the end of each OUT transaction to service the
878:            *                  received data.
879:            *
880:            *****************************************************************************/
881:           void USBCtrlTrfOutHandler(void)
882:           {
883:               if(controlTransferState == CTRL_TRF_RX)
1E4E  0E02     MOVLW 0x2
1E50  0104     MOVLB 0x4
1E52  5D48     SUBWF 0x48, W, BANKED
1E54  E102     BNZ 0x1E5A
884:               {
885:                   USBCtrlTrfRxService();
1E56  EF6D     GOTO 0x22DA
1E58  F011     NOP
886:               }
887:               else    // CTRL_TRF_TX
888:               {
889:                   USBPrepareForNextSetupTrf();
1E5A  EF5D     GOTO 0x1EBA
1E5C  F00F     NOP
890:               }
891:           }
892:           
893:           /******************************************************************************
894:            * Function:        void USBCtrlTrfInHandler(void)
895:            *
896:            * PreCondition:    None
897:            *
898:            * Input:           None
899:            *
900:            * Output:          None
901:            *
902:            * Side Effects:    None
903:            *
904:            * Overview:        This routine handles an IN transaction according to
905:            *                  which control transfer state is currently active.
906:            *
907:            *
908:            * Note:            A Set Address Request must not change the acutal address
909:            *                  of the device until the completion of the control
910:            *                  transfer. The end of the control transfer for Set Address
911:            *                  Request is an IN transaction. Therefore it is necessary
912:            *                  to service this unique situation when the condition is
913:            *                  right. Macro mUSBCheckAdrPendingState is defined in
914:            *                  usb9.h and its function is to specifically service this
915:            *                  event.
916:            *****************************************************************************/
917:           void USBCtrlTrfInHandler(void)
1E5E  DB80     RCALL __pa_1
918:           {
919:               BYTE lastDTS;
920:           
921:               lastDTS = pBDTEntryIn[0]->STAT.DTS;
1E60  DBAD     RCALL __pa_5
1E62  50EF     MOVF INDF0, W, ACCESS
1E64  0B40     ANDLW 0x40
1E66  E001     BZ 0x1E6A
1E68  0E01     MOVLW 0x1
1E6A  6EDF     MOVWF INDF2, ACCESS
25BC  C43F     MOVFF pBDTEntryIn, FSR0L
25BE  FFE9     NOP
25C0  C440     MOVFF 0x440, FSR0H
25C2  FFEA     NOP
25C4  0012     RETURN 0
922:           
923:               //switch to the next ping pong buffer
924:               ((BYTE_VAL*)&pBDTEntryIn[0])->Val ^= USB_NEXT_EP0_IN_PING_PONG;
925:           
926:               //mUSBCheckAdrPendingState();       // Must check if in ADR_PENDING_STATE
927:               if(USBDeviceState == ADR_PENDING_STATE)
1E6C  0E08     MOVLW 0x8
1E6E  0104     MOVLB 0x4
1E70  5D30     SUBWF 0x30, W, BANKED
1E72  E10C     BNZ 0x1E8C
928:               {
929:                   U1ADDR = SetupPkt.bDevADR.Val;
1E74  C422     MOVFF 0x422, UADDR
1E76  FF38     NOP
930:                   if(U1ADDR > 0)
1E78  010F     MOVLB 0xF
1E7A  5138     MOVF 0x38, W, BANKED
1E7C  0800     SUBLW 0x0
1E7E  E203     BC 0x1E86
931:                   {
932:                       USBDeviceState=ADDRESS_STATE;
1E80  0104     MOVLB 0x4
1E82  0E10     MOVLW 0x10
933:                   }
934:                   else
1E84  D002     BRA 0x1E8A
935:                   {
936:                       USBDeviceState=DEFAULT_STATE;
1E86  0104     MOVLB 0x4
1E88  0E04     MOVLW 0x4
1E8A  6F30     MOVWF 0x30, BANKED
937:                   }
938:               }//end if
939:           
940:           
941:               if(controlTransferState == CTRL_TRF_TX)
1E8C  0548     DECF 0x48, W, BANKED
1E8E  E113     BNZ 0x1EB6
942:               {
943:                   pBDTEntryIn[0]->ADR = (BYTE *)ConvertToPhysicalAddress(CtrlTrfData);
1E90  EC6C     CALL 0x26D8, 0
1E92  F013     NOP
26D8  DF71     RCALL __pa_5
26DA  D838     RCALL __pa_34
26DC  EF29     GOTO 0x2652
26DE  F013     NOP
274C  0E02     MOVLW 0x2
274E  26E9     ADDWF FSR0L, F, ACCESS
2750  0E00     MOVLW 0x0
2752  22EA     ADDWFC FSR0H, F, ACCESS
2754  0012     RETURN 0
944:                   USBCtrlTrfTxService();
1E94  D9D1     RCALL USBCtrlTrfTxService
945:           
946:                   /* v2b fix */
947:                   if(shortPacketStatus == SHORT_PKT_SENT)
1E96  0E02     MOVLW 0x2
1E98  0104     MOVLB 0x4
1E9A  5D47     SUBWF 0x47, W, BANKED
1E9C  E103     BNZ 0x1EA4
948:                   {
949:                       // If a short packet has been sent, don't want to send any more,
950:                       // stall next time if host is still trying to read.
951:                       pBDTEntryIn[0]->STAT.Val = _USIE|_BSTALL;
1E9E  DB8E     RCALL __pa_5
1EA0  0E84     MOVLW 0x84
952:                   }
953:                   else
1EA2  D007     BRA 0x1EB2
954:                   {
955:                       if(lastDTS == 0)
1EA4  50DF     MOVF INDF2, W, ACCESS
1EA6  E103     BNZ 0x1EAE
956:                       {
957:                           pBDTEntryIn[0]->STAT.Val = _USIE|_DAT1|_DTSEN;
1EA8  DB89     RCALL __pa_5
1EAA  0EC8     MOVLW 0xC8
958:                       }
959:                       else
1EAC  D002     BRA 0x1EB2
960:                       {
961:                           pBDTEntryIn[0]->STAT.Val = _USIE|_DAT0|_DTSEN;
1EAE  DB86     RCALL __pa_5
1EB0  0E88     MOVLW 0x88
1EB2  6EEF     MOVWF INDF0, ACCESS
962:                       }
963:                   }//end if(...)else
964:               }
965:               else // CTRL_TRF_RX
1EB4  D001     BRA 0x1EB8
966:               {
967:                   USBPrepareForNextSetupTrf();
1EB6  D801     RCALL USBPrepareForNextSetupTrf
968:               }
969:           }
1EB8  D375     BRA __pa_3
970:           
971:           /********************************************************************
972:            * Function:        void USBPrepareForNextSetupTrf(void)
973:            *
974:            * PreCondition:    None
975:            *
976:            * Input:           None
977:            *
978:            * Output:          None
979:            *
980:            * Side Effects:    None
981:            *
982:            * Overview:        The routine forces EP0 OUT to be ready for a new
983:            *                  Setup transaction, and forces EP0 IN to be owned
984:            *                  by CPU.
985:            *
986:            * Note:            None
987:            *******************************************************************/
988:           void USBPrepareForNextSetupTrf(void)
1EBA  EC69     CALL 0x26D2, 0
1EBC  F013     NOP
1EBE  52E6     MOVF POSTINC1, F, ACCESS
989:           {
990:               /********************************************************************
991:               Bug Fix: Feb 26, 2007 v2.1
992:               *********************************************************************
993:               Facts:
994:               A Setup Packet should never be stalled. (USB 2.0 Section 8.5.3)
995:               If a Setup PID is detected by the SIE, the DTSEN setting is ignored.
996:               This causes a problem at the end of a control write transaction.
997:               In USBCtrlEPServiceComplete(), during a control write (Host to Device),
998:               the EP0_OUT is setup to write any data to the CtrlTrfData buffer.
999:               If <SETUP[0]><IN[1]> is completed and USBCtrlTrfInHandler() is not
1000:              called before the next <SETUP[0]> is received, then the latest Setup
1001:              data will be written to the CtrlTrfData buffer instead of the SetupPkt
1002:              buffer.
1003:          
1004:              If USBCtrlTrfInHandler() was called before the latest <SETUP[0]> is
1005:              received, then there would be no problem,
1006:              because USBPrepareForNextSetupTrf() would have been called and updated
1007:              ep0Bo.ADR to point to the SetupPkt buffer.
1008:          
1009:              Work around:
1010:              Check for the problem as described above and copy the Setup data from
1011:              CtrlTrfData to SetupPkt.
1012:              ********************************************************************/
1013:              if((controlTransferState == CTRL_TRF_RX) &&
1EC0  0E02     MOVLW 0x2
1EC2  0104     MOVLB 0x4
1EC4  5D48     SUBWF 0x48, W, BANKED
1014:                 (USBPacketDisable == 1) &&
1EC6  E126     BNZ 0x1F14
1EC8  5065     MOVF UCON, W, ACCESS
1ECA  0B10     ANDLW 0x10
1ECC  E023     BZ 0x1F14
1015:                 (pBDTEntryEP0OutCurrent->CNT == sizeof(CTRL_TRF_SETUP)) &&
1ECE  DB8D     RCALL __pa_9
1ED0  52EE     MOVF POSTINC0, F, ACCESS
1ED2  50EF     MOVF INDF0, W, ACCESS
1ED4  6E14     MOVWF __tmp_0, ACCESS
1ED6  6A15     CLRF 0x15, ACCESS
1ED8  0E08     MOVLW 0x8
1EDA  1814     XORWF __tmp_0, W, ACCESS
1EDC  E11B     BNZ 0x1F14
1EDE  5015     MOVF 0x15, W, ACCESS
1EE0  E119     BNZ 0x1F14
1016:                 (pBDTEntryEP0OutCurrent->STAT.PID == SETUP_TOKEN) &&
1EE2  EC83     CALL 0x2706, 0
1EE4  F013     NOP
1EE6  E116     BNZ 0x1F14
1017:                 (pBDTEntryEP0OutNext->STAT.UOWN == 0))
1EE8  DBDD     RCALL __pa_20
1EEA  50EF     MOVF INDF0, W, ACCESS
1EEC  0B80     ANDLW 0x80
1EEE  E112     BNZ 0x1F14
1018:              {
1019:                  unsigned char setup_cnt;
1020:          
1021:                  pBDTEntryEP0OutNext->ADR = (BYTE*)ConvertToPhysicalAddress(&SetupPkt);
1EF0  DBD9     RCALL __pa_20
1EF2  DBDD     RCALL __pa_21
1022:          
1023:                  // The Setup data was written to the CtrlTrfData buffer, must copy
1024:                  // it back to the SetupPkt buffer so that it can be processed correctly
1025:                  // by USBCtrlTrfSetupHandler().
1026:                  for(setup_cnt = 0; setup_cnt < sizeof(CTRL_TRF_SETUP); setup_cnt++)
1EF4  6ADF     CLRF INDF2, ACCESS
1EF6  DBB8     RCALL __pa_16
1EF8  E222     BC 0x1F3E
1F10  2ADF     INCF INDF2, F, ACCESS
1F12  D7F1     BRA 0x1EF6
1027:                  {
1028:                      *(((BYTE*)&SetupPkt)+setup_cnt) = *(((BYTE*)&CtrlTrfData)+setup_cnt);
1EFA  50DF     MOVF INDF2, W, ACCESS
1EFC  DBBD     RCALL __pa_17
1EFE  50DF     MOVF INDF2, W, ACCESS
1F00  6AEA     CLRF FSR0H, ACCESS
1F02  0F20     ADDLW 0x20
1F04  6EE9     MOVWF FSR0L, ACCESS
1F06  0E04     MOVLW 0x4
1F08  22EA     ADDWFC FSR0H, F, ACCESS
1F0A  52E5     MOVF POSTDEC1, F, ACCESS
1F0C  50E7     MOVF INDF1, W, ACCESS
1F0E  6EEF     MOVWF INDF0, ACCESS
2678  6AEA     CLRF FSR0H, ACCESS
267A  0F28     ADDLW 0x28
267C  6EE9     MOVWF FSR0L, ACCESS
267E  0E04     MOVLW 0x4
2680  22EA     ADDWFC FSR0H, F, ACCESS
2682  50EF     MOVF INDF0, W, ACCESS
2684  6EE6     MOVWF POSTINC1, ACCESS
2686  0012     RETURN 0
1029:                  }//end for
1030:              }
1031:              /* End v3b fix */
1032:              else
1033:              {
1034:                  controlTransferState = WAIT_SETUP;
1F14  6B48     CLRF 0x48, BANKED
1035:                  pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;      // Defined in usb_config.h
1F16  DBD1     RCALL __pa_22
1036:                  pBDTEntryEP0OutNext->ADR = (BYTE*)ConvertToPhysicalAddress(&SetupPkt);
1037:          
1038:                  /********************************************************************
1039:                  Bug Fix: Feb 26, 2007 v2.1 (#F1)
1040:                  *********************************************************************
1041:                  In the original firmware, if an OUT token is sent by the host
1042:                  before a SETUP token is sent, the firmware would respond with an ACK.
1043:                  This is not a correct response, the firmware should have sent a STALL.
1044:                  This is a minor non-compliance since a compliant host should not
1045:                  send an OUT before sending a SETUP token. The fix allows a SETUP
1046:                  transaction to be accepted while stalling OUT transactions.
1047:                  ********************************************************************/
1048:                  //ep0Bo.Stat.Val = _USIE|_DAT0|_DTSEN;        // Removed
1049:                  pBDTEntryEP0OutNext->STAT.Val = _USIE|_DAT0|_DTSEN|_BSTALL;  //Added #F1
1050:          
1051:                  /********************************************************************
1052:                  Bug Fix: Feb 26, 2007 v2.1 (#F3)
1053:                  *********************************************************************
1054:                  In the original firmware, if an IN token is sent by the host
1055:                  before a SETUP token is sent, the firmware would respond with an ACK.
1056:                  This is not a correct response, the firmware should have sent a STALL.
1057:                  This is a minor non-compliance since a compliant host should not
1058:                  send an IN before sending a SETUP token.
1059:          
1060:                  Comment why this fix (#F3) is interfering with fix (#AF1).
1061:                  ********************************************************************/
1062:                  pBDTEntryIn[0]->STAT.Val = _UCPU;             // Should be removed
1F18  6AEF     CLRF INDF0, ACCESS
1063:          
1064:                  {
1065:                      BDT_ENTRY* p;
1066:          
1067:                      p = (BDT_ENTRY*)(((unsigned int)pBDTEntryIn[0])^USB_NEXT_EP0_IN_PING_PONG);
1F1A  0E00     MOVLW 0x0
1F1C  193F     XORWF 0x3F, W, BANKED
1F1E  6E14     MOVWF __tmp_0, ACCESS
1F20  C440     MOVFF 0x440, 0x15
1F22  F015     NOP
1F24  0E01     MOVLW 0x1
1F26  C014     MOVFF __tmp_0, PLUSW2
1F28  FFDB     NOP
1F2A  0E02     MOVLW 0x2
1F2C  C440     MOVFF 0x440, PLUSW2
1F2E  FFDB     NOP
1068:                      p->STAT.Val = _UCPU;
1F30  0E01     MOVLW 0x1
1F32  CFDB     MOVFF PLUSW2, FSR0L
1F34  FFE9     NOP
1F36  0E02     MOVLW 0x2
1F38  CFDB     MOVFF PLUSW2, FSR0H
1F3A  FFEA     NOP
1F3C  6AEF     CLRF INDF0, ACCESS
1069:                  }
1070:          
1071:                  //ep0Bi.Stat.Val = _USIE|_BSTALL;   // Should be added #F3
1072:              }
1073:          
1074:              //if someone is still expecting data from the control transfer
1075:              //  then make sure to terminate that request and let them know that
1076:              //  they are done
1077:              if(outPipes[0].info.bits.busy == 1)
1F3E  0104     MOVLB 0x4
1F40  AF51     BTFSS 0x51, 7, BANKED
1F42  D00F     BRA 0x1F62
1078:              {
1079:                  if(outPipes[0].pFunc != NULL)
1F44  5154     MOVF 0x54, W, BANKED
1F46  1155     IORWF 0x55, W, BANKED
1F48  1156     IORWF 0x56, W, BANKED
1F4A  E009     BZ 0x1F5E
1080:                  {
1081:                      outPipes[0].pFunc();
1F4C  D007     BRA 0x1F5C
1F4E  C456     MOVFF 0x456, PCLATU
1F50  FFFB     NOP
1F52  C455     MOVFF 0x455, PCLATH
1F54  FFFA     NOP
1F56  0104     MOVLB 0x4
1F58  5154     MOVF 0x54, W, BANKED
1F5A  6EF9     MOVWF PCL, ACCESS
1F5C  DFF8     RCALL 0x1F4E
1082:                  }
1083:                  outPipes[0].info.bits.busy = 0;
1F5E  0104     MOVLB 0x4
1F60  9F51     BCF 0x51, 7, BANKED
1084:              }
1085:          
1086:          }//end USBPrepareForNextSetupTrf
1F62  52E5     MOVF POSTDEC1, F, ACCESS
1F64  52E5     MOVF POSTDEC1, F, ACCESS
1F66  D31E     BRA __pa_3
1087:          
1088:          /********************************************************************
1089:           * Function:        void USBCheckStdRequest(void)
1090:           *
1091:           * PreCondition:    None
1092:           *
1093:           * Input:           None
1094:           *
1095:           * Output:          None
1096:           *
1097:           * Side Effects:    None
1098:           *
1099:           * Overview:        This routine checks the setup data packet to see
1100:           *                  if it knows how to handle it
1101:           *
1102:           * Note:            None
1103:           *******************************************************************/
1104:          void USBCheckStdRequest(void)
1105:          {
1106:              if(SetupPkt.RequestType != STANDARD) return;
1F68  0104     MOVLB 0x4
1F6A  5120     MOVF 0x20, W, BANKED
1F6C  0B60     ANDLW 0x60
1F6E  42E8     RRNCF WREG, F, ACCESS
1F70  42E8     RRNCF WREG, F, ACCESS
1F72  42E8     RRNCF WREG, F, ACCESS
1F74  42E8     RRNCF WREG, F, ACCESS
1F76  42E8     RRNCF WREG, F, ACCESS
1F78  0900     IORLW 0x0
1F7A  E001     BZ 0x1F7E
1F7C  0012     RETURN 0
1107:          
1108:              switch(SetupPkt.bRequest)
1F7E  5121     MOVF 0x21, W, BANKED
1F80  0A0C     XORLW 0xC
1F82  E043     BZ 0x200A
1F84  0A0B     XORLW 0xB
1F86  E03F     BZ 0x2006
1F88  0A0C     XORLW 0xC
1F8A  E031     BZ 0x1FEE
1F8C  0A01     XORLW 0x1
1F8E  E022     BZ 0x1FD4
1F90  0A0B     XORLW 0xB
1F92  E01E     BZ 0x1FD0
1F94  0A02     XORLW 0x2
1F96  E01C     BZ 0x1FD0
1F98  0A03     XORLW 0x3
1F9A  E018     BZ 0x1FCC
1F9C  0A08     XORLW 0x8
1F9E  E010     BZ 0x1FC0
1FA0  0A01     XORLW 0x1
1FA2  E00C     BZ 0x1FBC
1FA4  0A0F     XORLW 0xF
1FA6  E008     BZ 0x1FB8
1FA8  0A03     XORLW 0x3
1FAA  E001     BZ 0x1FAE
1FAC  0012     RETURN 0
1109:              {
1110:                  case SET_ADR:
1111:                      inPipes[0].info.bits.busy = 1;            // This will generate a zero length packet
1FAE  0104     MOVLB 0x4
1FB0  8F4C     BSF 0x4C, 7, BANKED
1112:                      USBDeviceState = ADR_PENDING_STATE;       // Update state only
1FB2  0E08     MOVLW 0x8
1FB4  6F30     MOVWF 0x30, BANKED
1113:                      /* See USBCtrlTrfInHandler() for the next step */
1114:                      break;
1FB6  0012     RETURN 0
1115:                  case GET_DSC:
1116:                      USBStdGetDscHandler();
1FB8  EF60     GOTO 0x20C0
1FBA  F010     NOP
1117:                      break;
1118:                  case SET_CFG:
1119:                      USBStdSetCfgHandler();
1FBC  EFC5     GOTO 0x238A
1FBE  F011     NOP
1120:                      break;
1121:                  case GET_CFG:
1122:                      inPipes[0].pSrc.bRam = (BYTE*)&USBActiveConfiguration;         // Set Source
1FC0  0104     MOVLB 0x4
1FC2  0E31     MOVLW 0x31
1FC4  6F49     MOVWF 0x49, BANKED
1FC6  0E04     MOVLW 0x4
1FC8  6F4A     MOVWF 0x4A, BANKED
1123:                      inPipes[0].info.bits.ctrl_trf_mem = _RAM;               // Set memory type
1124:                      inPipes[0].wCount.v[0] = 1;                         // Set data count
1125:                      inPipes[0].info.bits.busy = 1;
1126:                      break;
1FCA  D00C     BRA 0x1FE4
1127:                  case GET_STATUS:
1128:                      USBStdGetStatusHandler();
1FCC  EFAA     GOTO 0x2154
1FCE  F010     NOP
1129:                      break;
1130:                  case CLR_FEATURE:
1131:                  case SET_FEATURE:
1132:                      USBStdFeatureReqHandler();
1FD0  EF06     GOTO 0x200C
1FD2  F010     NOP
1133:                      break;
1134:                  case GET_INTF:
1135:                      inPipes[0].pSrc.bRam = (BYTE*)&USBAlternateInterface+SetupPkt.bIntfID;  // Set source
1FD4  5124     MOVF 0x24, W, BANKED
1FD6  0104     MOVLB 0x4
1FD8  6F49     MOVWF 0x49, BANKED
1FDA  6B4A     CLRF 0x4A, BANKED
1FDC  0E32     MOVLW 0x32
1FDE  2749     ADDWF 0x49, F, BANKED
1FE0  0E04     MOVLW 0x4
1FE2  234A     ADDWFC 0x4A, F, BANKED
1136:                      inPipes[0].info.bits.ctrl_trf_mem = _RAM;               // Set memory type
1FE4  814C     BSF 0x4C, 0, BANKED
1137:                      inPipes[0].wCount.v[0] = 1;                         // Set data count
1FE6  0E01     MOVLW 0x1
1FE8  6F4D     MOVWF 0x4D, BANKED
1138:                      inPipes[0].info.bits.busy = 1;
1FEA  8F4C     BSF 0x4C, 7, BANKED
1139:                      break;
1FEC  0012     RETURN 0
1140:                  case SET_INTF:
1141:                      inPipes[0].info.bits.busy = 1;
1FEE  0104     MOVLB 0x4
1FF0  8F4C     BSF 0x4C, 7, BANKED
1142:                      USBAlternateInterface[SetupPkt.bIntfID] = SetupPkt.bAltID;
1FF2  0104     MOVLB 0x4
1FF4  5124     MOVF 0x24, W, BANKED
1FF6  6AEA     CLRF FSR0H, ACCESS
1FF8  0F32     ADDLW 0x32
1FFA  6EE9     MOVWF FSR0L, ACCESS
1FFC  0E04     MOVLW 0x4
1FFE  22EA     ADDWFC FSR0H, F, ACCESS
2000  C422     MOVFF 0x422, INDF0
2002  FFEF     NOP
1143:                      break;
2004  0012     RETURN 0
1144:                  case SET_DSC:
1145:                      USBCBStdSetDscHandler();
2006  EFC9     GOTO 0x1B92
2008  F00D     NOP
1146:                      break;
1147:                  case SYNCH_FRAME:
1148:                  default:
1149:                      break;
1150:              }//end switch
1151:          }//end USBCheckStdRequest
200A  0012     RETURN 0
1152:          
1153:          /********************************************************************
1154:           * Function:        void USBStdFeatureReqHandler(void)
1155:           *
1156:           * PreCondition:    None
1157:           *
1158:           * Input:           None
1159:           *
1160:           * Output:          None
1161:           *
1162:           * Side Effects:    None
1163:           *
1164:           * Overview:        This routine handles the standard SET & CLEAR
1165:           *                  FEATURES requests
1166:           *
1167:           * Note:            None
1168:           *******************************************************************/
1169:          void USBStdFeatureReqHandler(void)
200C  DB62     RCALL __pa_24
200E  52E6     MOVF POSTINC1, F, ACCESS
2010  52E6     MOVF POSTINC1, F, ACCESS
26D2  DF46     RCALL __pa_1
26D4  52E6     MOVF POSTINC1, F, ACCESS
26D6  0012     RETURN 0
1170:          {
1171:              BDT_ENTRY *p;
1172:              #if defined(__C32__)
1173:                  DWORD* pUEP;
1174:              #else
1175:                  unsigned int* pUEP;             
1176:              #endif
1177:          #ifdef	USB_SUPPORT_OTG
1178:              if ((SetupPkt.bFeature == OTG_FEATURE_B_HNP_ENABLE)&&
1179:                  (SetupPkt.Recipient == RCPT_DEV))
1180:              {  
1181:                  inPipes[0].info.bits.busy = 1;
1182:                  if(SetupPkt.bRequest == SET_FEATURE)
1183:                      USBOTGEnableHnp();
1184:                  else
1185:                      USBOTGDisableHnp();
1186:              }
1187:          
1188:              if ((SetupPkt.bFeature == OTG_FEATURE_A_HNP_SUPPORT)&&
1189:                  (SetupPkt.Recipient == RCPT_DEV))
1190:              {
1191:                  inPipes[0].info.bits.busy = 1;
1192:                  if(SetupPkt.bRequest == SET_FEATURE)
1193:                      USBOTGEnableSupportHnp();
1194:                  else
1195:                      USBOTGDisableSupportHnp();
1196:              }
1197:          
1198:          
1199:              if ((SetupPkt.bFeature == OTG_FEATURE_A_ALT_HNP_SUPPORT)&&
1200:                  (SetupPkt.Recipient == RCPT_DEV))
1201:              {
1202:                  inPipes[0].info.bits.busy = 1;
1203:                  if(SetupPkt.bRequest == SET_FEATURE)
1204:                      USBOTGEnableAltHnp();
1205:                  else
1206:                      USBOTGDisableAltHnp();
1207:              }
1208:          #endif    
1209:              if((SetupPkt.bFeature == DEVICE_REMOTE_WAKEUP)&&
2012  0104     MOVLB 0x4
2014  0522     DECF 0x22, W, BANKED
1210:                 (SetupPkt.Recipient == RCPT_DEV))
2016  E110     BNZ 0x2038
2018  5120     MOVF 0x20, W, BANKED
201A  0B1F     ANDLW 0x1F
201C  0900     IORLW 0x0
201E  E10C     BNZ 0x2038
1211:              {
1212:                  inPipes[0].info.bits.busy = 1;
2020  0104     MOVLB 0x4
2022  8F4C     BSF 0x4C, 7, BANKED
1213:                  if(SetupPkt.bRequest == SET_FEATURE)
2024  0E03     MOVLW 0x3
2026  0104     MOVLB 0x4
2028  5D21     SUBWF 0x21, W, BANKED
202A  E104     BNZ 0x2034
1214:                      RemoteWakeup = TRUE;
202C  0104     MOVLB 0x4
202E  0E01     MOVLW 0x1
2030  6F59     MOVWF 0x59, BANKED
1215:                  else
2032  D002     BRA 0x2038
1216:                      RemoteWakeup = FALSE;
2034  0104     MOVLB 0x4
2036  6B59     CLRF 0x59, BANKED
1217:              }//end if
1218:          
1219:              if((SetupPkt.bFeature == ENDPOINT_HALT)&&
2038  0104     MOVLB 0x4
203A  5122     MOVF 0x22, W, BANKED
1220:                 (SetupPkt.Recipient == RCPT_EP)&&
203C  E13A     BNZ 0x20B2
203E  5120     MOVF 0x20, W, BANKED
2040  0B1F     ANDLW 0x1F
2042  0802     SUBLW 0x2
2044  E136     BNZ 0x20B2
1221:                 (SetupPkt.EPNum != 0))
2046  5124     MOVF 0x24, W, BANKED
2048  0B0F     ANDLW 0xF
204A  0900     IORLW 0x0
204C  E032     BZ 0x20B2
1222:              {
1223:                  inPipes[0].info.bits.busy = 1;
204E  0104     MOVLB 0x4
2050  8F4C     BSF 0x4C, 7, BANKED
1224:                  /* Must do address calculation here */
1225:          
1226:                  if(SetupPkt.EPDir == 0)
2052  0104     MOVLB 0x4
2054  BF24     BTFSC 0x24, 7, BANKED
2056  D005     BRA 0x2062
1227:                  {
1228:                      p = (BDT_ENTRY*)pBDTEntryOut[SetupPkt.EPNum];
2058  DACD     RCALL __pa_10
205A  0E37     MOVLW 0x37
205C  26E9     ADDWF FSR0L, F, ACCESS
205E  0E04     MOVLW 0x4
1229:                  }
1230:                  else
2060  D004     BRA 0x206A
1231:                  {
1232:                      p = (BDT_ENTRY*)pBDTEntryIn[SetupPkt.EPNum];
2062  DAC8     RCALL __pa_10
2064  0E3F     MOVLW 0x3F
2066  26E9     ADDWF FSR0L, F, ACCESS
2068  0E04     MOVLW 0x4
206A  DAF8     RCALL __pa_15
1233:                  }
1234:          
1235:          		//if it was a SET_FEATURE request
1236:                  if(SetupPkt.bRequest == SET_FEATURE)
206C  0E03     MOVLW 0x3
206E  5D21     SUBWF 0x21, W, BANKED
2070  E103     BNZ 0x2078
1237:                  {
1238:          			//Then STALL the endpoint
1239:                      p->STAT.Val = _USIE|_BSTALL;
2072  DAA9     RCALL __pa_6
2074  0E84     MOVLW 0x84
1240:                  }
1241:                  else
2076  D01C     BRA 0x20B0
1242:                  {
1243:          			//If it was not a SET_FEATURE
1244:          			//point to the appropriate UEP register
1245:                      #if defined(__C32__)
1246:                          pUEP = (DWORD*)(&U1EP0);
1247:                          pUEP += (SetupPkt.EPNum*4);
1248:                      #else
1249:                          pUEP = (unsigned int*)(&U1EP0+SetupPkt.EPNum);
2078  5124     MOVF 0x24, W, BANKED
207A  0B0F     ANDLW 0xF
207C  6A15     CLRF 0x15, ACCESS
207E  0F26     ADDLW 0x26
2080  6E14     MOVWF __tmp_0, ACCESS
2082  0E0F     MOVLW 0xF
2084  2215     ADDWFC 0x15, F, ACCESS
2086  0E02     MOVLW 0x2
2088  C014     MOVFF __tmp_0, PLUSW2
208A  FFDB     NOP
208C  0E03     MOVLW 0x3
208E  C015     MOVFF 0x15, PLUSW2
2090  FFDB     NOP
1250:                      #endif
1251:          
1252:          			//Clear the STALL bit in the UEP register
1253:                      *pUEP &= ~UEP_STALL;
2092  0E02     MOVLW 0x2
2094  CFDB     MOVFF PLUSW2, FSR0L
2096  FFE9     NOP
2098  0E03     MOVLW 0x3
209A  CFDB     MOVFF PLUSW2, FSR0H
209C  FFEA     NOP
209E  90EE     BCF POSTINC0, 0, ACCESS
20A0  52ED     MOVF POSTDEC0, F, ACCESS
1254:          
1255:                      if(SetupPkt.EPDir == 1) // IN
20A2  AF24     BTFSS 0x24, 7, BANKED
20A4  D003     BRA 0x20AC
1256:                      {
1257:          				//If the endpoint is an IN endpoint then we
1258:          				//  need to return it to the CPU and reset the
1259:          				//  DTS bit so that the next transfer is correct
1260:                          #if (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0) || (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG)   
1261:                              p->STAT.Val = _UCPU|_DAT0;
1262:                              //toggle over the to the next buffer
1263:                              ((BYTE_VAL*)&p)->Val ^= USB_NEXT_PING_PONG;
1264:                              p->STAT.Val = _UCPU|_DAT1;
1265:                          #else
1266:                              p->STAT.Val = _UCPU|_DAT1;
20A6  DA8F     RCALL __pa_6
20A8  0E40     MOVLW 0x40
1267:                          #endif
1268:                      }
1269:                      else
20AA  D002     BRA 0x20B0
1270:                      {
1271:          				//If the endpoint was an OUT endpoint then we
1272:          				//  need to give control of the endpoint back to
1273:          				//  the SIE so that the function driver can 
1274:          				//  receive the data as they expected.  Also need
1275:          				//  to set the DTS bit so the next packet will be
1276:          				//  correct
1277:                          #if (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0) || (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG)   
1278:                              p->STAT.Val = _USIE|_DAT0|_DTSEN;
1279:                              //toggle over the to the next buffer
1280:                              ((BYTE_VAL*)&p)->Val ^= USB_NEXT_PING_PONG;
1281:                              p->STAT.Val = _USIE|_DAT1|_DTSEN;
1282:                          #else
1283:                              p->STAT.Val = _USIE|_DAT1|_DTSEN;
20AC  DA8C     RCALL __pa_6
20AE  0EC8     MOVLW 0xC8
20B0  6EEF     MOVWF INDF0, ACCESS
1284:                          #endif
1285:          
1286:                      }
1287:                  }//end if
1288:          
1289:              }//end if
1290:          }//end USBStdFeatureReqHandler
20B2  0E04     MOVLW 0x4
20B4  5CE1     SUBWF FSR1L, W, ACCESS
20B6  E202     BC 0x20BC
20B8  6AE1     CLRF FSR1L, ACCESS
20BA  52E5     MOVF POSTDEC1, F, ACCESS
20BC  6EE1     MOVWF FSR1L, ACCESS
20BE  D303     BRA __pa_23
1291:          
1292:          /********************************************************************
1293:           * Function:        void USBStdGetDscHandler(void)
1294:           *
1295:           * PreCondition:    None
1296:           *
1297:           * Input:           None
1298:           *
1299:           * Output:          None
1300:           *
1301:           * Side Effects:    None
1302:           *
1303:           * Overview:        This routine handles the standard GET_DESCRIPTOR
1304:           *                  request.
1305:           *
1306:           * Note:            None
1307:           *******************************************************************/
1308:          void USBStdGetDscHandler(void)
1309:          {
1310:              if(SetupPkt.bmRequestType == 0x80)
20C0  0E80     MOVLW 0x80
20C2  0104     MOVLB 0x4
20C4  5D20     SUBWF 0x20, W, BANKED
20C6  E145     BNZ 0x2152
1311:              {
1312:                  inPipes[0].info.Val = USB_INPIPES_ROM | USB_INPIPES_BUSY | USB_INPIPES_INCLUDE_ZERO;
20C8  0104     MOVLB 0x4
20CA  0EC0     MOVLW 0xC0
20CC  6F4C     MOVWF 0x4C, BANKED
1313:          
1314:                  switch(SetupPkt.bDescriptorType)
20CE  0104     MOVLB 0x4
20D0  5123     MOVF 0x23, W, BANKED
20D2  0A03     XORLW 0x3
20D4  E02F     BZ 0x2134
20D6  0A01     XORLW 0x1
20D8  E015     BZ 0x2104
20DA  0A03     XORLW 0x3
20DC  E138     BNZ 0x214E
1315:                  {
1316:                      case USB_DESCRIPTOR_DEVICE:
1317:                          #if !defined(USB_USER_DEVICE_DESCRIPTOR)
1318:          // my                
1319:                              if (flag.CDC_mode)          // prepinani Device Descriptor
20DE  0103     MOVLB 0x3
20E0  A59D     BTFSS 0x9D, 2, BANKED
20E2  D007     BRA 0x20F2
1320:                              {
1321:                                  inPipes[0].pSrc.bRom = (ROM BYTE*)&cdc_device_dsc;
20E4  0104     MOVLB 0x4
20E6  0EC0     MOVLW 0xC0
20E8  6F49     MOVWF 0x49, BANKED
20EA  0E29     MOVLW 0x29
20EC  6F4A     MOVWF 0x4A, BANKED
20EE  0E00     MOVLW 0x0
1322:                                  inPipes[0].wCount.Val = sizeof(cdc_device_dsc);
1323:                              }
1324:                              else
20F0  D006     BRA 0x20FE
1325:                              {
1326:                                  inPipes[0].pSrc.bRom = (ROM BYTE*)&device_dsc; 
20F2  0104     MOVLB 0x4
20F4  0EAE     MOVLW 0xAE
20F6  6F49     MOVWF 0x49, BANKED
20F8  0E29     MOVLW 0x29
20FA  6F4A     MOVWF 0x4A, BANKED
20FC  0E00     MOVLW 0x0
20FE  6F4B     MOVWF 0x4B, BANKED
1327:                                  inPipes[0].wCount.Val = sizeof(device_dsc);
2100  0E12     MOVLW 0x12
1328:                              }
1329:                          #else
1330:                              inPipes[0].pSrc.bRom = (ROM BYTE*)USB_USER_DEVICE_DESCRIPTOR;
1331:                          #endif
1332:                       // inPipes[0].wCount.Val = sizeof(device_dsc);
1333:          // end of my
1334:                          break;
2102  D022     BRA 0x2148
1335:                      case USB_DESCRIPTOR_CONFIGURATION:
1336:                          #if !defined(USB_USER_CONFIG_DESCRIPTOR)
1337:                              inPipes[0].pSrc.bRom = *(USB_CD_Ptr+SetupPkt.bDscIndex);
1338:                          #else
1339:          // my
1340:                              if (flag.CDC_mode)          // prepinani Config Descriptor
2104  0103     MOVLB 0x3
2106  A59D     BTFSS 0x9D, 2, BANKED
2108  D007     BRA 0x2118
1341:                              {
1342:                                  inPipes[0].pSrc.bRom = *(USB_USER_CONFIG_DESCRIPTOR + SetupPkt.bDscIndex + 1);  
210A  DB04     RCALL __pa_30
210C  0E03     MOVLW 0x3
210E  26F6     ADDWF TBLPTRL, F, ACCESS
2110  0E00     MOVLW 0x0
2112  22F7     ADDWFC TBLPTRH, F, ACCESS
2114  22F8     ADDWFC TBLPTRU, F, ACCESS
2714  0EB1     MOVLW 0xB1
2716  6E14     MOVWF __tmp_0, ACCESS
2718  0E2A     MOVLW 0x2A
271A  6E15     MOVWF 0x15, ACCESS
271C  0E00     MOVLW 0x0
271E  EFB3     GOTO 0x2566
2720  F012     NOP
1343:                              }
1344:                              else
2116  D001     BRA 0x211A
1345:                              {
1346:                                  inPipes[0].pSrc.bRom = *(USB_USER_CONFIG_DESCRIPTOR + SetupPkt.bDscIndex);
2118  DAFD     RCALL __pa_30
211A  DA74     RCALL __pa_11
2604  0009     TBLRD*+
2606  CFF5     MOVFF TABLAT, inPipes
2608  F449     NOP
260A  0009     TBLRD*+
260C  CFF5     MOVFF TABLAT, 0x44A
260E  F44A     NOP
2610  0008     TBLRD*
2612  CFF5     MOVFF TABLAT, 0x44B
2614  F44B     NOP
1347:                              }
1348:                          #endif
1349:          // end of my                
1350:                          inPipes[0].wCount.Val = *(inPipes[0].pSrc.wRom+1);                // Set data count
211C  0E02     MOVLW 0x2
211E  26F6     ADDWF TBLPTRL, F, ACCESS
2120  0E00     MOVLW 0x0
2122  22F7     ADDWFC TBLPTRH, F, ACCESS
2124  22F8     ADDWFC TBLPTRU, F, ACCESS
2126  0009     TBLRD*+
2128  CFF5     MOVFF TABLAT, 0x44D
212A  F44D     NOP
212C  000A     TBLRD*-
212E  CFF5     MOVFF TABLAT, 0x44E
2130  F44E     NOP
2616  C449     MOVFF inPipes, TBLPTRL
2618  FFF6     NOP
261A  C44A     MOVFF 0x44A, TBLPTRH
261C  FFF7     NOP
261E  C44B     MOVFF 0x44B, TBLPTRU
2620  FFF8     NOP
2622  0012     RETURN 0
1351:                          break;
2132  0012     RETURN 0
1352:                      case USB_DESCRIPTOR_STRING:
1353:                          #if defined(USB_NUM_STRING_DESCRIPTORS)
1354:                          if(SetupPkt.bDscIndex<USB_NUM_STRING_DESCRIPTORS)
1355:                          #else
1356:                          if(1)
1357:                          #endif
1358:                          {
1359:                              //Get a pointer to the String descriptor requested
1360:                              inPipes[0].pSrc.bRom = *(USB_SD_Ptr+SetupPkt.bDscIndex);
2134  0EB7     MOVLW 0xB7
2136  6E14     MOVWF __tmp_0, ACCESS
2138  0E2A     MOVLW 0x2A
213A  6E15     MOVWF 0x15, ACCESS
213C  0E00     MOVLW 0x0
213E  DA13     RCALL __pa_2
2140  DA61     RCALL __pa_11
2566  6E16     MOVWF 0x16, ACCESS
2568  C422     MOVFF 0x422, 0x17
256A  F017     NOP
256C  6A18     CLRF 0x18, ACCESS
256E  6A19     CLRF 0x19, ACCESS
2570  0E03     MOVLW 0x3
2572  6E0C     MOVWF 0xC, ACCESS
2574  6A0D     CLRF 0xD, ACCESS
2576  6A0E     CLRF 0xE, ACCESS
2578  C017     MOVFF 0x17, 0x7
257A  F007     NOP
257C  C018     MOVFF 0x18, 0x8
257E  F008     NOP
2580  C019     MOVFF 0x19, 0x9
2582  F009     NOP
2584  ECB1     CALL 0x2B62, 0
2586  F015     NOP
2588  5014     MOVF __tmp_0, W, ACCESS
258A  2404     ADDWF while_cnt, W, ACCESS
258C  6EF3     MOVWF PRODL, ACCESS
258E  5015     MOVF 0x15, W, ACCESS
2590  2005     ADDWFC 0x5, W, ACCESS
2592  6EF4     MOVWF PRODH, ACCESS
2594  5016     MOVF 0x16, W, ACCESS
2596  2006     ADDWFC 0x6, W, ACCESS
2598  6EF8     MOVWF TBLPTRU, ACCESS
259A  CFF4     MOVFF PRODH, TBLPTRH
259C  FFF7     NOP
259E  CFF3     MOVFF PRODL, TBLPTRL
25A0  FFF6     NOP
25A2  0012     RETURN 0
1361:                              // Set data count
1362:                              inPipes[0].wCount.Val = *inPipes[0].pSrc.bRom;                    
2142  0008     TBLRD*
2144  50F5     MOVF TABLAT, W, ACCESS
2146  0104     MOVLB 0x4
2148  6F4D     MOVWF 0x4D, BANKED
214A  6B4E     CLRF 0x4E, BANKED
1363:                          }
1364:                          else
214C  0012     RETURN 0
1365:                          {
1366:                              inPipes[0].info.Val = 0;
1367:                          }
1368:                          break;
1369:                      default:
1370:                          inPipes[0].info.Val = 0;
214E  0104     MOVLB 0x4
2150  6B4C     CLRF 0x4C, BANKED
1371:                          break;
1372:                  }//end switch
1373:              }//end if
1374:          }//end USBStdGetDscHandler
2152  0012     RETURN 0
1375:          
1376:          /********************************************************************
1377:           * Function:        void USBStdGetStatusHandler(void)
1378:           *
1379:           * PreCondition:    None
1380:           *
1381:           * Input:           None
1382:           *
1383:           * Output:          None
1384:           *
1385:           * Side Effects:    None
1386:           *
1387:           * Overview:        This routine handles the standard GET_STATUS request
1388:           *
1389:           * Note:            None
1390:           *******************************************************************/
1391:          void USBStdGetStatusHandler(void)
2154  DABE     RCALL __pa_24
1392:          {
1393:              CtrlTrfData[0] = 0;                 // Initialize content
2156  0104     MOVLB 0x4
2158  6B28     CLRF 0x28, BANKED
1394:              CtrlTrfData[1] = 0;
215A  6B29     CLRF 0x29, BANKED
1395:          
1396:              switch(SetupPkt.Recipient)
215C  5120     MOVF 0x20, W, BANKED
215E  0B1F     ANDLW 0x1F
2160  0A02     XORLW 0x2
2162  E011     BZ 0x2186
2164  0A03     XORLW 0x3
2166  E00C     BZ 0x2180
2168  0A01     XORLW 0x1
216A  E122     BNZ 0x21B0
1397:              {
1398:                  case RCPT_DEV:
1399:                      inPipes[0].info.bits.busy = 1;
216C  0104     MOVLB 0x4
216E  8F4C     BSF 0x4C, 7, BANKED
1400:                      /*
1401:                       * [0]: bit0: Self-Powered Status [0] Bus-Powered [1] Self-Powered
1402:                       *      bit1: RemoteWakeup        [0] Disabled    [1] Enabled
1403:                       */
1404:                      if(self_power == 1) // self_power is defined in HardwareProfile.h
1405:                      {
1406:                          CtrlTrfData[0]|=0x01;
2170  0104     MOVLB 0x4
2172  8128     BSF 0x28, 0, BANKED
1407:                      }
1408:          
1409:                      if(RemoteWakeup == TRUE)
2174  0104     MOVLB 0x4
2176  0559     DECF 0x59, W, BANKED
2178  E11B     BNZ 0x21B0
1410:                      {
1411:                          CtrlTrfData[0]|=0x02;
217A  0104     MOVLB 0x4
217C  8328     BSF 0x28, 1, BANKED
1412:                      }
1413:                      break;
217E  D018     BRA 0x21B0
1414:                  case RCPT_INTF:
1415:                      inPipes[0].info.bits.busy = 1;     // No data to update
2180  0104     MOVLB 0x4
2182  8F4C     BSF 0x4C, 7, BANKED
1416:                      break;
2184  D015     BRA 0x21B0
1417:                  case RCPT_EP:
1418:                      inPipes[0].info.bits.busy = 1;
2186  0104     MOVLB 0x4
2188  8F4C     BSF 0x4C, 7, BANKED
1419:                      /*
1420:                       * [0]: bit0: Halt Status [0] Not Halted [1] Halted
1421:                       */
1422:                      {
1423:                          BDT_ENTRY *p;
1424:          
1425:                          if(SetupPkt.EPDir == 0)
218A  0104     MOVLB 0x4
218C  BF24     BTFSC 0x24, 7, BANKED
218E  D005     BRA 0x219A
1426:                          {
1427:                              p = (BDT_ENTRY*)pBDTEntryOut[SetupPkt.EPNum];
2190  DA31     RCALL __pa_10
2192  0E37     MOVLW 0x37
2194  26E9     ADDWF FSR0L, F, ACCESS
2196  0E04     MOVLW 0x4
25F4  5124     MOVF 0x24, W, BANKED
25F6  0B0F     ANDLW 0xF
25F8  6EE9     MOVWF FSR0L, ACCESS
25FA  6AEA     CLRF FSR0H, ACCESS
25FC  90D8     BCF STATUS, 0, ACCESS
25FE  36E9     RLCF FSR0L, F, ACCESS
2600  36EA     RLCF FSR0H, F, ACCESS
2602  0012     RETURN 0
1428:                          }
1429:                          else
2198  D004     BRA 0x21A2
1430:                          {
1431:                              p = (BDT_ENTRY*)pBDTEntryIn[SetupPkt.EPNum];
219A  DA2C     RCALL __pa_10
219C  0E3F     MOVLW 0x3F
219E  26E9     ADDWF FSR0L, F, ACCESS
21A0  0E04     MOVLW 0x4
21A2  DA5C     RCALL __pa_15
1432:                          }
1433:          
1434:                          if(p->STAT.Val & _BSTALL)    // Use _BSTALL as a bit mask
21A4  DA10     RCALL __pa_6
21A6  50EF     MOVF INDF0, W, ACCESS
21A8  0B04     ANDLW 0x4
21AA  E002     BZ 0x21B0
1435:                              CtrlTrfData[0]=0x01;    // Set bit0
21AC  0E01     MOVLW 0x1
21AE  6F28     MOVWF 0x28, BANKED
1436:                          break;
1437:                      }
1438:              }//end switch
1439:          
1440:              if(inPipes[0].info.bits.busy == 1)
21B0  0104     MOVLB 0x4
21B2  AF4C     BTFSS 0x4C, 7, BANKED
21B4  D007     BRA 0x21C4
1441:              {
1442:                  inPipes[0].pSrc.bRam = (BYTE*)&CtrlTrfData;            // Set Source
21B6  0E28     MOVLW 0x28
21B8  6F49     MOVWF 0x49, BANKED
21BA  0E04     MOVLW 0x4
21BC  6F4A     MOVWF 0x4A, BANKED
1443:                  inPipes[0].info.bits.ctrl_trf_mem = _RAM;               // Set memory type
21BE  814C     BSF 0x4C, 0, BANKED
1444:                  inPipes[0].wCount.v[0] = 2;                         // Set data count
21C0  0E02     MOVLW 0x2
21C2  6F4D     MOVWF 0x4D, BANKED
1445:              }//end if(...)
1446:          }//end USBStdGetStatusHandler
21C4  52E5     MOVF POSTDEC1, F, ACCESS
21C6  D1EE     BRA __pa_3
1447:          
1448:          /******************************************************************************
1449:           * Function:        void USBCtrlEPServiceComplete(void)
1450:           *
1451:           * PreCondition:    None
1452:           *
1453:           * Input:           None
1454:           *
1455:           * Output:          None
1456:           *
1457:           * Side Effects:    None
1458:           *
1459:           * Overview:        This routine wrap up the ramaining tasks in servicing
1460:           *                  a Setup Request. Its main task is to set the endpoint
1461:           *                  controls appropriately for a given situation. See code
1462:           *                  below.
1463:           *                  There are three main scenarios:
1464:           *                  a) There was no handler for the Request, in this case
1465:           *                     a STALL should be sent out.
1466:           *                  b) The host has requested a read control transfer,
1467:           *                     endpoints are required to be setup in a specific way.
1468:           *                  c) The host has requested a write control transfer, or
1469:           *                     a control data stage is not required, endpoints are
1470:           *                     required to be setup in a specific way.
1471:           *
1472:           *                  Packet processing is resumed by clearing PKTDIS bit.
1473:           *
1474:           * Note:            None
1475:           *****************************************************************************/
1476:          void USBCtrlEPServiceComplete(void)
1477:          {
1478:              /*
1479:               * PKTDIS bit is set when a Setup Transaction is received.
1480:               * Clear to resume packet processing.
1481:               */
1482:              USBPacketDisable = 0;
21C8  9865     BCF UCON, 4, ACCESS
1483:          
1484:              if(inPipes[0].info.bits.busy == 0)
21CA  0104     MOVLB 0x4
21CC  BF4C     BTFSC 0x4C, 7, BANKED
21CE  D007     BRA 0x21DE
1485:              {
1486:                  if(outPipes[0].info.bits.busy == 1)
21D0  AF51     BTFSS 0x51, 7, BANKED
21D2  D002     BRA 0x21D8
1487:                  {
1488:                      controlTransferState = CTRL_TRF_RX;
21D4  DAB0     RCALL __pa_33
2736  0E02     MOVLW 0x2
2738  6F48     MOVWF 0x48, BANKED
1489:                      /*
1490:                       * Control Write:
1491:                       * <SETUP[0]><OUT[1]><OUT[0]>...<IN[1]> | <SETUP[0]>
1492:                       *
1493:                       * 1. Prepare IN EP to respond to early termination
1494:                       *
1495:                       *    This is the same as a Zero Length Packet Response
1496:                       *    for control transfer without a data stage
1497:                       */
1498:                      pBDTEntryIn[0]->CNT = 0;
273A  DF40     RCALL __pa_5
273C  52EE     MOVF POSTINC0, F, ACCESS
273E  6AEF     CLRF INDF0, ACCESS
1499:                      pBDTEntryIn[0]->STAT.Val = _USIE|_DAT1|_DTSEN;
2740  DF3D     RCALL __pa_5
2742  0EC8     MOVLW 0xC8
2744  6EEF     MOVWF INDF0, ACCESS
1500:          
1501:                      /*
1502:                       * 2. Prepare OUT EP to receive data.
1503:                       */
1504:                      pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
2746  DFF4     RCALL __pa_32
1505:                      pBDTEntryEP0OutNext->ADR = (BYTE*)ConvertToPhysicalAddress(&CtrlTrfData);
1506:                      pBDTEntryEP0OutNext->STAT.Val = _USIE|_DAT1|_DTSEN;
2748  EF52     GOTO 0x26A4
274A  F013     NOP
1507:                  }
1508:                  else
21D6  D028     BRA 0x2228
1509:                  {
1510:                      /*
1511:                       * If no one knows how to service this request then stall.
1512:                       * Must also prepare EP0 to receive the next SETUP transaction.
1513:                       */
1514:                      pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
21D8  DA70     RCALL __pa_22
1515:                      pBDTEntryEP0OutNext->ADR = (BYTE*)ConvertToPhysicalAddress(&SetupPkt);
1516:              
1517:                      /* v2b fix */
1518:                      pBDTEntryEP0OutNext->STAT.Val = _USIE|_DAT0|_DTSEN|_BSTALL;
1519:                      pBDTEntryIn[0]->STAT.Val = _USIE|_BSTALL; 
21DA  0E84     MOVLW 0x84
1520:                  }
1521:              }
1522:              else    // A module has claimed ownership of the control transfer session.
21DC  D026     BRA 0x222A
1523:              {
1524:                  if(outPipes[0].info.bits.busy == 0)
21DE  BF51     BTFSC 0x51, 7, BANKED
21E0  D02A     BRA 0x2236
1525:                  {
1526:          			if(SetupPkt.DataDir == DEV_TO_HOST)
21E2  0104     MOVLB 0x4
21E4  AF20     BTFSS 0x20, 7, BANKED
21E6  D023     BRA 0x222E
1527:          			{
1528:          				if(SetupPkt.wLength < inPipes[0].wCount.Val)
21E8  0104     MOVLB 0x4
21EA  514D     MOVF 0x4D, W, BANKED
21EC  0104     MOVLB 0x4
21EE  5D26     SUBWF 0x26, W, BANKED
21F0  0104     MOVLB 0x4
21F2  514E     MOVF 0x4E, W, BANKED
21F4  0104     MOVLB 0x4
21F6  5927     SUBWFB 0x27, W, BANKED
21F8  E204     BC 0x2202
1529:          				{
1530:          					inPipes[0].wCount.Val = SetupPkt.wLength;
21FA  C426     MOVFF 0x426, 0x44D
21FC  F44D     NOP
21FE  C427     MOVFF 0x427, 0x44E
2200  F44E     NOP
1531:          				}
1532:          				USBCtrlTrfTxService();
2202  D81A     RCALL USBCtrlTrfTxService
1533:          				controlTransferState = CTRL_TRF_TX;
2204  0104     MOVLB 0x4
2206  0E01     MOVLW 0x1
2208  6F48     MOVWF 0x48, BANKED
1534:          				/*
1535:          				 * Control Read:
1536:          				 * <SETUP[0]><IN[1]><IN[0]>...<OUT[1]> | <SETUP[0]>
1537:          				 * 1. Prepare OUT EP to respond to early termination
1538:          				 *
1539:          				 * NOTE:
1540:          				 * If something went wrong during the control transfer,
1541:          				 * the last status stage may not be sent by the host.
1542:          				 * When this happens, two different things could happen
1543:          				 * depending on the host.
1544:          				 * a) The host could send out a RESET.
1545:          				 * b) The host could send out a new SETUP transaction
1546:          				 *    without sending a RESET first.
1547:          				 * To properly handle case (b), the OUT EP must be setup
1548:          				 * to receive either a zero length OUT transaction, or a
1549:          				 * new SETUP transaction.
1550:          				 *
1551:          				 * Furthermore, the Cnt byte should be set to prepare for
1552:          				 * the SETUP data (8-byte or more), and the buffer address
1553:          				 * should be pointed to SetupPkt.
1554:          				 */
1555:          				pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
220A  D9A3     RCALL __pa_0
1556:          				pBDTEntryEP0OutNext->ADR = (BYTE*)ConvertToPhysicalAddress(&SetupPkt);
220C  D9E8     RCALL __pa_8
1557:          				pBDTEntryEP0OutNext->STAT.Val = _USIE;           // Note: DTSEN is 0!
220E  0E80     MOVLW 0x80
2210  6EEF     MOVWF INDF0, ACCESS
1558:          
1559:          				pBDTEntryEP0OutCurrent->CNT = USB_EP0_BUFF_SIZE;
2212  D9EB     RCALL __pa_9
2214  52EE     MOVF POSTINC0, F, ACCESS
2216  0E08     MOVLW 0x8
2218  6EEF     MOVWF INDF0, ACCESS
1560:          				pBDTEntryEP0OutCurrent->ADR = (BYTE*)&SetupPkt;
221A  D9E7     RCALL __pa_9
221C  DA48     RCALL __pa_21
1561:          				pBDTEntryEP0OutCurrent->STAT.Val = _USIE;           // Note: DTSEN is 0!
221E  D9E5     RCALL __pa_9
2220  0E80     MOVLW 0x80
2222  6EEF     MOVWF INDF0, ACCESS
1562:          
1563:          				/*
1564:          				 * 2. Prepare IN EP to transfer data, Cnt should have
1565:          				 *    been initialized by responsible request owner.
1566:          				 */
1567:          				pBDTEntryIn[0]->ADR = (BYTE*)ConvertToPhysicalAddress(&CtrlTrfData);
2224  DA59     RCALL __pa_25
1568:          				pBDTEntryIn[0]->STAT.Val = _USIE|_DAT1|_DTSEN;
2226  D9CA     RCALL __pa_5
2228  0EC8     MOVLW 0xC8
222A  6EEF     MOVWF INDF0, ACCESS
1569:          			}
1570:          			else   // (SetupPkt.DataDir == HOST_TO_DEVICE)
222C  0012     RETURN 0
1571:          			{
1572:          				controlTransferState = CTRL_TRF_RX;
222E  0104     MOVLB 0x4
2230  DA82     RCALL __pa_33
1573:          				/*
1574:          				 * Control Write:
1575:          				 * <SETUP[0]><OUT[1]><OUT[0]>...<IN[1]> | <SETUP[0]>
1576:          				 *
1577:          				 * 1. Prepare IN EP to respond to early termination
1578:          				 *
1579:          				 *    This is the same as a Zero Length Packet Response
1580:          				 *    for control transfer without a data stage
1581:          				 */
1582:          				pBDTEntryIn[0]->CNT = 0;
1583:          				pBDTEntryIn[0]->STAT.Val = _USIE|_DAT1|_DTSEN;
1584:          
1585:          				/*
1586:          				 * 2. Prepare OUT EP to receive data.
1587:          				 */
1588:          				pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
2730  DF10     RCALL __pa_0
1589:          				pBDTEntryEP0OutNext->ADR = (BYTE*)ConvertToPhysicalAddress(&CtrlTrfData);
2732  EF29     GOTO 0x2652
2734  F013     NOP
1590:          				pBDTEntryEP0OutNext->STAT.Val = _USIE|_DAT1|_DTSEN;
2232  0EC8     MOVLW 0xC8
2234  6EEF     MOVWF INDF0, ACCESS
1591:          			}
1592:                  }
1593:              }//end if(ctrl_trf_session_owner == MUID_NULL)
1594:          
1595:          }//end USBCtrlEPServiceComplete
2236  0012     RETURN 0
1596:          
1597:          
1598:          /******************************************************************************
1599:           * Function:        void USBCtrlTrfTxService(void)
1600:           *
1601:           * PreCondition:    pSrc, wCount, and usb_stat.ctrl_trf_mem are setup properly.
1602:           *
1603:           * Input:           None
1604:           *
1605:           * Output:          None
1606:           *
1607:           * Side Effects:    None
1608:           *
1609:           * Overview:        This routine should be called from only two places.
1610:           *                  One from USBCtrlEPServiceComplete() and one from
1611:           *                  USBCtrlTrfInHandler(). It takes care of managing a
1612:           *                  transfer over multiple USB transactions.
1613:           *
1614:           * Note:            This routine works with isochronous endpoint larger than
1615:           *                  256 bytes and is shown here as an example of how to deal
1616:           *                  with BC9 and BC8. In reality, a control endpoint can never
1617:           *                  be larger than 64 bytes.
1618:           *****************************************************************************/
1619:          void USBCtrlTrfTxService(void)
2238  DA4C     RCALL __pa_24
1620:          {
1621:              WORD_VAL byteToSend;
1622:          
1623:              /*
1624:               * First, have to figure out how many byte of data to send.
1625:               */
1626:              if(inPipes[0].wCount.Val < USB_EP0_BUFF_SIZE)
223A  0104     MOVLB 0x4
223C  0E08     MOVLW 0x8
223E  5D4D     SUBWF 0x4D, W, BANKED
2240  0E00     MOVLW 0x0
2242  594E     SUBWFB 0x4E, W, BANKED
2244  E20D     BC 0x2260
1627:              {
1628:                  byteToSend.Val = inPipes[0].wCount.Val;
2246  C44D     MOVFF 0x44D, POSTINC2
2248  FFDE     NOP
224A  C44E     MOVFF 0x44E, POSTDEC2
224C  FFDD     NOP
1629:          
1630:                  /* v2b fix */
1631:                  if(shortPacketStatus == SHORT_PKT_NOT_USED)
224E  5147     MOVF 0x47, W, BANKED
2250  E102     BNZ 0x2256
1632:                  {
1633:                      shortPacketStatus = SHORT_PKT_PENDING;
2252  0E01     MOVLW 0x1
1634:                  }
1635:                  else if(shortPacketStatus == SHORT_PKT_PENDING)
2254  D003     BRA 0x225C
2256  0547     DECF 0x47, W, BANKED
2258  E106     BNZ 0x2266
1636:                  {
1637:                      shortPacketStatus = SHORT_PKT_SENT;
225A  0E02     MOVLW 0x2
225C  6F47     MOVWF 0x47, BANKED
1638:                  }//end if
1639:                  /* end v2b fix for this section */
1640:              }
1641:              else
225E  D003     BRA 0x2266
1642:              {
1643:                  byteToSend.Val = USB_EP0_BUFF_SIZE;
2260  0E08     MOVLW 0x8
2262  6EDE     MOVWF POSTINC2, ACCESS
2264  6ADD     CLRF POSTDEC2, ACCESS
1644:              }
1645:          
1646:              /*
1647:               * Next, load the number of bytes to send to BC9..0 in buffer descriptor
1648:               */
1649:              #if defined(__18CXX)
1650:                  pBDTEntryIn[0]->STAT.BC9 = 0;
2266  D9AA     RCALL __pa_5
2268  92EF     BCF INDF0, 1, ACCESS
1651:                  pBDTEntryIn[0]->STAT.BC8 = 0;
226A  D9A8     RCALL __pa_5
226C  90EF     BCF INDF0, 0, ACCESS
1652:              #endif
1653:              
1654:              #if defined(__18CXX) || defined(__C30__)
1655:                  pBDTEntryIn[0]->STAT.Val |= byteToSend.byte.HB;
226E  D9A6     RCALL __pa_5
2270  0E01     MOVLW 0x1
2272  50DB     MOVF PLUSW2, W, ACCESS
2274  12EF     IORWF INDF0, F, ACCESS
1656:                  pBDTEntryIn[0]->CNT = byteToSend.byte.LB;
2276  D9A2     RCALL __pa_5
2278  52EE     MOVF POSTINC0, F, ACCESS
227A  CFDF     MOVFF INDF2, INDF0
227C  FFEF     NOP
1657:              #elif defined(__C32__)
1658:                  pBDTEntryIn[0]->CNT = byteToSend.Val;
1659:              #else
1660:                  #error "Not defined for this compiler"
1661:              #endif
1662:          
1663:              /*
1664:               * Subtract the number of bytes just about to be sent from the total.
1665:               */
1666:              inPipes[0].wCount.Val = inPipes[0].wCount.Val - byteToSend.Val;
227E  0E00     MOVLW 0x0
2280  50DB     MOVF PLUSW2, W, ACCESS
2282  5F4D     SUBWF 0x4D, F, BANKED
2284  0E01     MOVLW 0x1
2286  50DB     MOVF PLUSW2, W, ACCESS
2288  5B4E     SUBWFB 0x4E, F, BANKED
1667:          
1668:              pDst = (BYTE*)CtrlTrfData;        // Set destination pointer
228A  0E28     MOVLW 0x28
228C  6F57     MOVWF 0x57, BANKED
228E  0E04     MOVLW 0x4
2290  6F58     MOVWF 0x58, BANKED
1669:          
1670:              if(inPipes[0].info.bits.ctrl_trf_mem == USB_INPIPES_ROM)       // Determine type of memory source
2292  B14C     BTFSC 0x4C, 0, BANKED
2294  D012     BRA 0x22BA
1671:              {
1672:                  while(byteToSend.Val)
2296  D9FF     RCALL __pa_19
2298  E01E     BZ 0x22D6
22B8  D7EE     BRA 0x2296
2696  CFD9     MOVFF FSR2L, FSR0L
2698  FFE9     NOP
269A  CFDA     MOVFF FSR2H, FSR0H
269C  FFEA     NOP
269E  50EE     MOVF POSTINC0, W, ACCESS
26A0  10ED     IORWF POSTDEC0, W, ACCESS
26A2  0012     RETURN 0
1673:                  {
1674:                      *pDst++ = *inPipes[0].pSrc.bRom++;
229A  C449     MOVFF inPipes, TBLPTRL
229C  FFF6     NOP
229E  2B49     INCF 0x49, F, BANKED
22A0  C44A     MOVFF 0x44A, TBLPTRH
22A2  FFF7     NOP
22A4  0E00     MOVLW 0x0
22A6  234A     ADDWFC 0x4A, F, BANKED
22A8  C44B     MOVFF 0x44B, TBLPTRU
22AA  FFF8     NOP
22AC  234B     ADDWFC 0x4B, F, BANKED
22AE  0008     TBLRD*
22B0  50F5     MOVF TABLAT, W, ACCESS
22B2  D9C1     RCALL __pa_13
2636  6EE6     MOVWF POSTINC1, ACCESS
2638  C457     MOVFF pDst, FSR0L
263A  FFE9     NOP
263C  C458     MOVFF 0x458, FSR0H
263E  FFEA     NOP
2640  2B57     INCF 0x57, F, BANKED
2642  0E00     MOVLW 0x0
2644  2358     ADDWFC 0x58, F, BANKED
2646  52E5     MOVF POSTDEC1, F, ACCESS
2648  50E7     MOVF INDF1, W, ACCESS
264A  6EEF     MOVWF INDF0, ACCESS
1675:                      byteToSend.Val--;
22B4  E2F0     BC 0x2296
22B6  06DB     DECF PLUSW2, F, ACCESS
264C  06DF     DECF INDF2, F, ACCESS
264E  0E01     MOVLW 0x1
2650  0012     RETURN 0
1676:                  }//end while(byte_to_send.Val)
1677:              }
1678:              else  // RAM
1679:              {
1680:                  while(byteToSend.Val)
22BA  D9ED     RCALL __pa_19
22BC  E00C     BZ 0x22D6
22D4  D7F2     BRA 0x22BA
1681:                  {
1682:                      *pDst++ = *inPipes[0].pSrc.bRam++;
22BE  C449     MOVFF inPipes, FSR0L
22C0  FFE9     NOP
22C2  C44A     MOVFF 0x44A, FSR0H
22C4  FFEA     NOP
22C6  2B49     INCF 0x49, F, BANKED
22C8  0E00     MOVLW 0x0
22CA  234A     ADDWFC 0x4A, F, BANKED
22CC  50EF     MOVF INDF0, W, ACCESS
22CE  D9B3     RCALL __pa_13
1683:                      byteToSend.Val--;
22D0  E2F4     BC 0x22BA
22D2  06DB     DECF PLUSW2, F, ACCESS
1684:                  }//end while(byte_to_send.Val)
1685:              }//end if(usb_stat.ctrl_trf_mem == _ROM)
1686:          
1687:          }//end USBCtrlTrfTxService
22D6  52E5     MOVF POSTDEC1, F, ACCESS
22D8  D165     BRA __pa_3
1688:          
1689:          /******************************************************************************
1690:           * Function:        void USBCtrlTrfRxService(void)
1691:           *
1692:           * PreCondition:    pDst and wCount are setup properly.
1693:           *                  pSrc is always &CtrlTrfData
1694:           *                  usb_stat.ctrl_trf_mem is always _RAM.
1695:           *                  wCount should be set to 0 at the start of each control
1696:           *                  transfer.
1697:           *
1698:           * Input:           None
1699:           *
1700:           * Output:          None
1701:           *
1702:           * Side Effects:    None
1703:           *
1704:           * Overview:        *** This routine is only partially complete. Check for
1705:           *                  new version of the firmware.
1706:           *
1707:           * Note:            None
1708:           *****************************************************************************/
1709:          void USBCtrlTrfRxService(void)
22DA  D9FB     RCALL __pa_24
1710:          {
1711:              BYTE byteToRead;
1712:              BYTE i;
1713:          
1714:              byteToRead = pBDTEntryEP0OutCurrent->CNT;
22DC  D986     RCALL __pa_9
22DE  52EE     MOVF POSTINC0, F, ACCESS
22E0  CFEF     MOVFF INDF0, INDF2
22E2  FFDF     NOP
1715:          
1716:              /*
1717:               * Accumulate total number of bytes read
1718:               */
1719:              if(byteToRead > outPipes[0].wCount.Val)
22E4  CFDF     MOVFF INDF2, __tmp_0
22E6  F014     NOP
22E8  5014     MOVF __tmp_0, W, ACCESS
22EA  0104     MOVLB 0x4
22EC  5D52     SUBWF 0x52, W, BANKED
22EE  0E00     MOVLW 0x0
22F0  5953     SUBWFB 0x53, W, BANKED
22F2  E203     BC 0x22FA
1720:              {
1721:                  byteToRead = outPipes[0].wCount.Val;
22F4  C452     MOVFF 0x452, INDF2
22F6  FFDF     NOP
1722:              }
1723:              else
22F8  D009     BRA 0x230C
1724:              {
1725:                  outPipes[0].wCount.Val = outPipes[0].wCount.Val - byteToRead;
22FA  50DF     MOVF INDF2, W, ACCESS
22FC  6E14     MOVWF __tmp_0, ACCESS
22FE  6A15     CLRF 0x15, ACCESS
2300  50E8     MOVF WREG, W, ACCESS
2302  5D52     SUBWF 0x52, W, BANKED
2304  6F52     MOVWF 0x52, BANKED
2306  5015     MOVF 0x15, W, ACCESS
2308  5953     SUBWFB 0x53, W, BANKED
230A  6F53     MOVWF 0x53, BANKED
1726:              }
1727:          
1728:              for(i=0;i<byteToRead;i++)
230C  0E01     MOVLW 0x1
230E  6ADB     CLRF PLUSW2, ACCESS
2310  50DF     MOVF INDF2, W, ACCESS
2312  6EF3     MOVWF PRODL, ACCESS
2314  0E01     MOVLW 0x1
2316  CFDB     MOVFF PLUSW2, PRODH
2318  FFF4     NOP
231A  50F3     MOVF PRODL, W, ACCESS
231C  5CF4     SUBWF PRODH, W, ACCESS
231E  E210     BC 0x2340
233A  0E01     MOVLW 0x1
233C  2ADB     INCF PLUSW2, F, ACCESS
233E  D7E8     BRA 0x2310
1729:              {
1730:                  *outPipes[0].pDst.bRam++ = CtrlTrfData[i];
2320  0E01     MOVLW 0x1
2322  50DB     MOVF PLUSW2, W, ACCESS
2324  D9A9     RCALL __pa_17
2326  C44F     MOVFF outPipes, FSR0L
2328  FFE9     NOP
232A  C450     MOVFF 0x450, FSR0H
232C  FFEA     NOP
232E  2B4F     INCF 0x4F, F, BANKED
2330  0E00     MOVLW 0x0
2332  2350     ADDWFC 0x50, F, BANKED
2334  52E5     MOVF POSTDEC1, F, ACCESS
2336  50E7     MOVF INDF1, W, ACCESS
2338  6EEF     MOVWF INDF0, ACCESS
1731:              }//end while(byteToRead.Val)
1732:          
1733:              //If there is more data to read
1734:              if(outPipes[0].wCount.Val > 0)
2340  0E00     MOVLW 0x0
2342  80D8     BSF STATUS, 0, ACCESS
2344  5552     SUBFWB 0x52, W, BANKED
2346  0E00     MOVLW 0x0
2348  5553     SUBFWB 0x53, W, BANKED
234A  E20C     BC 0x2364
1735:              {
1736:                  /*
1737:                   * Don't have to worry about overwriting _KEEP bit
1738:                   * because if _KEEP was set, TRNIF would not have been
1739:                   * generated in the first place.
1740:                   */
1741:                  pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
234C  D9F1     RCALL __pa_32
1742:                  pBDTEntryEP0OutNext->ADR = (BYTE*)ConvertToPhysicalAddress(&CtrlTrfData);
2652  0E28     MOVLW 0x28
2654  6EEE     MOVWF POSTINC0, ACCESS
2656  0E04     MOVLW 0x4
2658  6EED     MOVWF POSTDEC0, ACCESS
265A  0012     RETURN 0
1743:                  if(pBDTEntryEP0OutCurrent->STAT.DTS == 0)
234E  D94D     RCALL __pa_9
2350  50EF     MOVF INDF0, W, ACCESS
2352  0B40     ANDLW 0x40
2354  E103     BNZ 0x235C
25EA  C433     MOVFF pBDTEntryEP0OutCurrent, FSR0L
25EC  FFE9     NOP
25EE  C434     MOVFF 0x434, FSR0H
25F0  FFEA     NOP
25F2  0012     RETURN 0
1744:                  {
1745:                      pBDTEntryEP0OutNext->STAT.Val = _USIE|_DAT1|_DTSEN;
2356  D9A6     RCALL __pa_20
2358  0EC8     MOVLW 0xC8
1746:                  }
1747:                  else
235A  D002     BRA 0x2360
1748:                  {
1749:                      pBDTEntryEP0OutNext->STAT.Val = _USIE|_DAT0|_DTSEN;
235C  D9A3     RCALL __pa_20
235E  0E88     MOVLW 0x88
2360  6EEF     MOVWF INDF0, ACCESS
1750:                  }
1751:              }
1752:              else
2362  D011     BRA 0x2386
1753:              {
1754:                  pBDTEntryEP0OutNext->ADR = (BYTE*)ConvertToPhysicalAddress(&SetupPkt);
2364  D99F     RCALL __pa_20
2366  D9A3     RCALL __pa_21
26AE  D84E     RCALL __pa_34
26B0  0E20     MOVLW 0x20
26B2  6EEE     MOVWF POSTINC0, ACCESS
26B4  0E04     MOVLW 0x4
26B6  6EED     MOVWF POSTDEC0, ACCESS
26B8  0012     RETURN 0
1755:                  if(outPipes[0].pFunc != NULL)
2368  5154     MOVF 0x54, W, BANKED
236A  1155     IORWF 0x55, W, BANKED
236C  1156     IORWF 0x56, W, BANKED
236E  E009     BZ 0x2382
1756:                  {
1757:                      outPipes[0].pFunc();
2370  D007     BRA 0x2380
2372  C456     MOVFF 0x456, PCLATU
2374  FFFB     NOP
2376  C455     MOVFF 0x455, PCLATH
2378  FFFA     NOP
237A  0104     MOVLB 0x4
237C  5154     MOVF 0x54, W, BANKED
237E  6EF9     MOVWF PCL, ACCESS
2380  DFF8     RCALL 0x2372
1758:                  }
1759:                  outPipes[0].info.bits.busy = 0;
2382  0104     MOVLB 0x4
2384  9F51     BCF 0x51, 7, BANKED
1760:              }
1761:          
1762:          
1763:              // reset ep0Bo.Cnt to USB_EP0_BUFF_SIZE
1764:          
1765:          }//end USBCtrlTrfRxService
2386  52E5     MOVF POSTDEC1, F, ACCESS
2388  D10D     BRA __pa_3
1766:          
1767:          /********************************************************************
1768:           * Function:        void USBStdSetCfgHandler(void)
1769:           *
1770:           * PreCondition:    None
1771:           *
1772:           * Input:           None
1773:           *
1774:           * Output:          None
1775:           *
1776:           * Side Effects:    None
1777:           *
1778:           * Overview:        This routine first disables all endpoints by
1779:           *                  clearing UEP registers. It then configures
1780:           *                  (initializes) endpoints by calling the callback
1781:           *                  function USBCBInitEP().
1782:           *
1783:           * Note:            None
1784:           *******************************************************************/
1785:          void USBStdSetCfgHandler(void)
1786:          {
1787:              // This will generate a zero length packet
1788:              inPipes[0].info.bits.busy = 1;            
238A  0104     MOVLB 0x4
238C  8F4C     BSF 0x4C, 7, BANKED
1789:          
1790:              //disable all endpoints except endpoint 0
1791:              memset((void*)&U1EP1,0x00,(USB_MAX_EP_NUMBER-1));
238E  D94A     RCALL __pa_12
2390  E202     BC 0x2396
2392  6AE1     CLRF FSR1L, ACCESS
2394  52E5     MOVF POSTDEC1, F, ACCESS
2396  6EE1     MOVWF FSR1L, ACCESS
2398  5014     MOVF __tmp_0, W, ACCESS
1792:          
1793:              //clear the alternate interface settings
1794:              memset((void*)&USBAlternateInterface,0x00,USB_MAX_NUM_INT);
239A  0E01     MOVLW 0x1
239C  6EE6     MOVWF POSTINC1, ACCESS
239E  6AE6     CLRF POSTINC1, ACCESS
23A0  6AE6     CLRF POSTINC1, ACCESS
23A2  0E32     MOVLW 0x32
23A4  6EE6     MOVWF POSTINC1, ACCESS
23A6  0E04     MOVLW 0x4
23A8  D9BC     RCALL __pa_31
23AA  E202     BC 0x23B0
23AC  6AE1     CLRF FSR1L, ACCESS
23AE  52E5     MOVF POSTDEC1, F, ACCESS
23B0  6EE1     MOVWF FSR1L, ACCESS
23B2  5014     MOVF __tmp_0, W, ACCESS
2722  6EE6     MOVWF POSTINC1, ACCESS
2724  EC25     CALL 0x2C4A, 0
2726  F016     NOP
2728  6E14     MOVWF __tmp_0, ACCESS
272A  0E05     MOVLW 0x5
272C  5CE1     SUBWF FSR1L, W, ACCESS
272E  0012     RETURN 0
1795:          
1796:              //set the current configuration
1797:              USBActiveConfiguration = SetupPkt.bConfigurationValue;
23B4  C422     MOVFF 0x422, USBActiveConfiguration
23B6  F431     NOP
1798:          
1799:              //if the configuration value == 0
1800:              if(SetupPkt.bConfigurationValue == 0)
23B8  0104     MOVLB 0x4
23BA  5122     MOVF 0x22, W, BANKED
23BC  E104     BNZ 0x23C6
1801:              {
1802:                  //Go back to the addressed state
1803:                  USBDeviceState = ADDRESS_STATE;
23BE  0104     MOVLB 0x4
23C0  0E10     MOVLW 0x10
23C2  6F30     MOVWF 0x30, BANKED
1804:              }
1805:              else
23C4  0012     RETURN 0
1806:              {
1807:                  //Otherwise go to the configured state
1808:                  USBDeviceState = CONFIGURED_STATE;
23C6  0104     MOVLB 0x4
23C8  0E20     MOVLW 0x20
23CA  6F30     MOVWF 0x30, BANKED
1809:                  //initialize the required endpoints
1810:                  USBInitEP((BYTE ROM*)(USB_CD_Ptr[USBActiveConfiguration-1]));
1811:                  USBCBInitEP();
23CC  EFCA     GOTO 0x1B94
23CE  F00D     NOP
1812:          
1813:              }//end if(SetupPkt.bConfigurationValue == 0)
1814:          }//end USBStdSetCfgHandler
1815:          
1816:          /********************************************************************
1817:           * Function:        void USBConfigureEndpoint(BYTE EPNum, BYTE direction)
1818:           *
1819:           * PreCondition:    None
1820:           *
1821:           * Input:           BYTE EPNum - the endpoint to be configured
1822:           *                  BYTE direction - the direction to be configured
1823:           *
1824:           * Output:          None
1825:           *
1826:           * Side Effects:    None
1827:           *
1828:           * Overview:        This function will configure the specified 
1829:           *                  endpoint
1830:           *
1831:           * Note:            None
1832:           *******************************************************************/
1833:          void USBConfigureEndpoint(BYTE EPNum, BYTE direction)
23D0  D980     RCALL __pa_24
1834:          {
1835:              volatile BDT_ENTRY* handle;
1836:          
1837:              handle = (volatile BDT_ENTRY*)&BDT[EP0_OUT_EVEN];
23D2  0E00     MOVLW 0x0
23D4  6EDE     MOVWF POSTINC2, ACCESS
23D6  0E04     MOVLW 0x4
23D8  6EDD     MOVWF POSTDEC2, ACCESS
1838:              handle += BD(EPNum,direction,0)/sizeof(BDT_ENTRY);
23DA  0EFC     MOVLW 0xFC
23DC  50DB     MOVF PLUSW2, W, ACCESS
23DE  0D04     MULLW 0x4
23E0  CFF3     MOVFF PRODL, 0x16
23E2  F016     NOP
23E4  0EFD     MOVLW 0xFD
23E6  50DB     MOVF PLUSW2, W, ACCESS
23E8  0D08     MULLW 0x8
23EA  50F3     MOVF PRODL, W, ACCESS
23EC  2416     ADDWF 0x16, W, ACCESS
23EE  6E14     MOVWF __tmp_0, ACCESS
23F0  6A15     CLRF 0x15, ACCESS
23F2  0E02     MOVLW 0x2
23F4  0B0F     ANDLW 0xF
23F6  E005     BZ 0x2402
23F8  90D8     BCF STATUS, 0, ACCESS
23FA  3215     RRCF 0x15, F, ACCESS
23FC  3214     RRCF __tmp_0, F, ACCESS
23FE  06E8     DECF WREG, F, ACCESS
2400  E1FB     BNZ 0x23F8
2402  90D8     BCF STATUS, 0, ACCESS
2404  3614     RLCF __tmp_0, F, ACCESS
2406  3615     RLCF 0x15, F, ACCESS
2408  90D8     BCF STATUS, 0, ACCESS
240A  3614     RLCF __tmp_0, F, ACCESS
240C  3615     RLCF 0x15, F, ACCESS
240E  CFD9     MOVFF FSR2L, FSR0L
2410  FFE9     NOP
2412  CFDA     MOVFF FSR2H, FSR0H
2414  FFEA     NOP
2416  5014     MOVF __tmp_0, W, ACCESS
2418  26EE     ADDWF POSTINC0, F, ACCESS
241A  5015     MOVF 0x15, W, ACCESS
241C  22ED     ADDWFC POSTDEC0, F, ACCESS
1839:          
1840:              handle->STAT.UOWN = 0;
241E  D8D3     RCALL __pa_6
2420  9EEF     BCF INDF0, 7, ACCESS
1841:          
1842:              if(direction == 0)
2422  0EFC     MOVLW 0xFC
2424  50DB     MOVF PLUSW2, W, ACCESS
2426  E102     BNZ 0x242C
1843:              {
1844:                  pBDTEntryOut[EPNum] = handle;
2428  D964     RCALL __pa_27
1845:              }
1846:              else
242A  D001     BRA 0x242E
1847:              {
1848:                  pBDTEntryIn[EPNum] = handle;
242C  D967     RCALL __pa_28
242E  22EA     ADDWFC FSR0H, F, ACCESS
2430  CFDE     MOVFF POSTINC2, POSTINC0
2432  FFEE     NOP
2434  CFDD     MOVFF POSTDEC2, POSTDEC0
2436  FFED     NOP
1849:              }
1850:          
1851:              #if (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG)
1852:                  handle->STAT.DTS = 0;
1853:                  (handle+1)->STAT.DTS = 1;
1854:              #elif (USB_PING_PONG_MODE == USB_PING_PONG__NO_PING_PONG)
1855:                  //Set DTS to one because the first thing we will do
1856:                  //when transmitting is toggle the bit
1857:                  handle->STAT.DTS = 1;
2438  D8C6     RCALL __pa_6
243A  8CEF     BSF INDF0, 6, ACCESS
1858:              #elif (USB_PING_PONG_MODE == USB_PING_PONG__EP0_OUT_ONLY)
1859:                  if(EPNum != 0)
1860:                  {
1861:                      handle->STAT.DTS = 1;
1862:                  }
1863:              #elif (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0)    
1864:                  if(EPNum != 0)
1865:                  {
1866:                      handle->STAT.DTS = 0;
1867:                      (handle+1)->STAT.DTS = 1;
1868:                  }
1869:              #endif
1870:          }
243C  52E5     MOVF POSTDEC1, F, ACCESS
243E  D0B2     BRA __pa_3
1871:          
1872:          /*****************************************************************************************************************
1873:            Function:
1874:                  void USBEnableEndpoint(BYTE ep, BYTE options)
1875:              
1876:            Summary:
1877:              This function will enable the specified endpoint with the specified
1878:              options
1879:            Description:
1880:              This function will enable the specified endpoint with the specified
1881:              options.
1882:              
1883:              Typical Usage:
1884:              <code>
1885:              void USBCBInitEP(void)
1886:              {
1887:                  USBEnableEndpoint(MSD_DATA_IN_EP,USB_IN_ENABLED|USB_OUT_ENABLED|USB_HANDSHAKE_ENABLED|USB_DISALLOW_SETUP);
1888:                  USBMSDInit();
1889:              }
1890:              </code>
1891:              
1892:              In the above example endpoint number MSD_DATA_IN_EP is being configured
1893:              for both IN and OUT traffic with handshaking enabled. Also since
1894:              MSD_DATA_IN_EP is not endpoint 0 (MSD does not allow this), then we can
1895:              explicitly disable SETUP packets on this endpoint.
1896:            Conditions:
1897:              None
1898:            Input:
1899:              BYTE ep -       the endpoint to be configured
1900:              BYTE options -  optional settings for the endpoint. The options should
1901:                              be ORed together to form a single options string. The
1902:                              available optional settings for the endpoint. The
1903:                              options should be ORed together to form a single options
1904:                              string. The available options are the following\:
1905:                              * USB_HANDSHAKE_ENABLED enables USB handshaking (ACK,
1906:                                NAK)
1907:                              * USB_HANDSHAKE_DISABLED disables USB handshaking (ACK,
1908:                                NAK)
1909:                              * USB_OUT_ENABLED enables the out direction
1910:                              * USB_OUT_DISABLED disables the out direction
1911:                              * USB_IN_ENABLED enables the in direction
1912:                              * USB_IN_DISABLED disables the in direction
1913:                              * USB_ALLOW_SETUP enables control transfers
1914:                              * USB_DISALLOW_SETUP disables control transfers
1915:                              * USB_STALL_ENDPOINT STALLs this endpoint
1916:            Return:
1917:              None
1918:            Remarks:
1919:              None                                                                                                          
1920:            *****************************************************************************************************************/
1921:          void USBEnableEndpoint(BYTE ep, BYTE options)
2440  D948     RCALL __pa_24
1922:          {
1923:              //Set the options to the appropriate endpoint control register
1924:              //*((unsigned char*)(&U1EP0+ep)) = options;
1925:              {
1926:                  unsigned int* p;
1927:          
1928:                  #if defined(__C32__)
1929:                      p = (unsigned int*)(&U1EP0+(4*ep));
1930:                  #else
1931:                      p = (unsigned int*)(&U1EP0+ep);
2442  0EFD     MOVLW 0xFD
2444  50DB     MOVF PLUSW2, W, ACCESS
2446  6A15     CLRF 0x15, ACCESS
2448  0F26     ADDLW 0x26
244A  6E14     MOVWF __tmp_0, ACCESS
244C  0E0F     MOVLW 0xF
244E  2215     ADDWFC 0x15, F, ACCESS
2450  C014     MOVFF __tmp_0, POSTINC2
2452  FFDE     NOP
2454  C015     MOVFF 0x15, POSTDEC2
2456  FFDD     NOP
1932:                  #endif
1933:                  *p = options;
2458  0EFC     MOVLW 0xFC
245A  50DB     MOVF PLUSW2, W, ACCESS
245C  6EE6     MOVWF POSTINC1, ACCESS
245E  D8B3     RCALL __pa_6
2460  52E5     MOVF POSTDEC1, F, ACCESS
2462  50E7     MOVF INDF1, W, ACCESS
2464  6EEE     MOVWF POSTINC0, ACCESS
2466  6AED     CLRF POSTDEC0, ACCESS
1934:              }
1935:          
1936:              if(options & USB_OUT_ENABLED)
2468  0EFC     MOVLW 0xFC
246A  A4DB     BTFSS PLUSW2, 2, ACCESS
246C  D002     BRA 0x2472
1937:              {
1938:                  USBConfigureEndpoint(ep,0);
246E  6AE6     CLRF POSTINC1, ACCESS
2470  D90B     RCALL __pa_18
2688  0EFD     MOVLW 0xFD
268A  CFDB     MOVFF PLUSW2, POSTINC1
268C  FFE6     NOP
268E  DEA0     RCALL USBConfigureEndpoint
2690  52E5     MOVF POSTDEC1, F, ACCESS
2692  52E5     MOVF POSTDEC1, F, ACCESS
2694  0012     RETURN 0
1939:              }
1940:              if(options & USB_IN_ENABLED)
2472  0EFC     MOVLW 0xFC
2474  A2DB     BTFSS PLUSW2, 1, ACCESS
2476  D003     BRA 0x247E
1941:              {
1942:                  USBConfigureEndpoint(ep,1);
2478  0E01     MOVLW 0x1
247A  6EE6     MOVWF POSTINC1, ACCESS
247C  D905     RCALL __pa_18
1943:              }
1944:          }
247E  52E5     MOVF POSTDEC1, F, ACCESS
2480  D091     BRA __pa_3
1945:          
1946:          /********************************************************************
1947:           * Function:        void USBStallEndpoint(BYTE ep, BYTE dir)
1948:           *
1949:           * PreCondition:    None
1950:           *
1951:           * Input:
1952:           *   BYTE ep - the endpoint the data will be transmitted on
1953:           *   BYTE dir - the direction of the transfer
1954:           *
1955:           * Output:          None
1956:           *
1957:           * Side Effects:    Endpoint is STALLed
1958:           *
1959:           * Overview:        STALLs the specified endpoint
1960:           *
1961:           * Note:            None
1962:           *******************************************************************/
1963:          void USBStallEndpoint(BYTE ep, BYTE dir)
2482  D927     RCALL __pa_24
1964:          {
1965:              BDT_ENTRY *p;
1966:          
1967:              if(ep == 0)
2484  0EFD     MOVLW 0xFD
2486  50DB     MOVF PLUSW2, W, ACCESS
2488  E104     BNZ 0x2492
1968:              {
1969:                  /*
1970:                   * If no one knows how to service this request then stall.
1971:                   * Must also prepare EP0 to receive the next SETUP transaction.
1972:                   */
1973:                  pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
248A  D917     RCALL __pa_22
2552  D8A8     RCALL __pa_20
2554  52EE     MOVF POSTINC0, F, ACCESS
2556  0E08     MOVLW 0x8
2558  6EEF     MOVWF INDF0, ACCESS
26BA  DF4B     RCALL __pa_0
1974:                  pBDTEntryEP0OutNext->ADR = (BYTE*)ConvertToPhysicalAddress(&SetupPkt);
255A  D8A4     RCALL __pa_20
255C  EFA6     GOTO 0x274C
255E  F013     NOP
25DE  0E20     MOVLW 0x20
25E0  6EEE     MOVWF POSTINC0, ACCESS
25E2  0E04     MOVLW 0x4
25E4  6EED     MOVWF POSTDEC0, ACCESS
26BC  DF90     RCALL __pa_8
1975:          
1976:                  /* v2b fix */
1977:                  pBDTEntryEP0OutNext->STAT.Val = _USIE|_DAT0|_DTSEN|_BSTALL;
25E6  EF52     GOTO 0x26A4
25E8  F013     NOP
26A4  C435     MOVFF pBDTEntryEP0OutNext, FSR0L
26A6  FFE9     NOP
26A8  C436     MOVFF 0x436, FSR0H
26AA  FFEA     NOP
26AC  0012     RETURN 0
26BE  0E8C     MOVLW 0x8C
26C0  6EEF     MOVWF INDF0, ACCESS
1978:                  pBDTEntryIn[0]->STAT.Val = _USIE|_BSTALL; 
248C  0E84     MOVLW 0x84
248E  6EEF     MOVWF INDF0, ACCESS
26C2  EFDE     GOTO 0x25BC
26C4  F012     NOP
1979:              }
1980:              else
2490  D019     BRA 0x24C4
1981:              {
1982:                  p = (BDT_ENTRY*)(&BDT[EP(ep,dir,0)]);
2492  0EFC     MOVLW 0xFC
2494  CFDB     MOVFF PLUSW2, POSTINC1
2496  FFE6     NOP
2498  0EFD     MOVLW 0xFD
249A  50DB     MOVF PLUSW2, W, ACCESS
249C  24E8     ADDWF WREG, W, ACCESS
249E  52E5     MOVF POSTDEC1, F, ACCESS
24A0  24E7     ADDWF INDF1, W, ACCESS
24A2  0D04     MULLW 0x4
24A4  CFF3     MOVFF PRODL, __tmp_0
24A6  F014     NOP
24A8  CFF4     MOVFF PRODH, 0x15
24AA  F015     NOP
24AC  0E00     MOVLW 0x0
24AE  2614     ADDWF __tmp_0, F, ACCESS
24B0  0E04     MOVLW 0x4
24B2  2215     ADDWFC 0x15, F, ACCESS
24B4  C014     MOVFF __tmp_0, POSTINC2
24B6  FFDE     NOP
24B8  C015     MOVFF 0x15, POSTDEC2
24BA  FFDD     NOP
1983:                  p->STAT.Val |= _BSTALL | _USIE;
24BC  0E84     MOVLW 0x84
24BE  D883     RCALL __pa_6
24C0  50E8     MOVF WREG, W, ACCESS
24C2  12EF     IORWF INDF0, F, ACCESS
1984:              
1985:                  //If the device is in FULL or ALL_BUT_EP0 ping pong modes
1986:                  //then stall that entry as well
1987:                  #if (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG) || \
1988:                      (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0)
1989:              
1990:                  p = (BDT_ENTRY*)(&BDT[EP(ep,dir,1)]);
1991:                  p->STAT.Val |= _BSTALL | _USIE;
1992:                  #endif
1993:              }
1994:          }
24C4  52E5     MOVF POSTDEC1, F, ACCESS
24C6  D06E     BRA __pa_3
1995:          
1996:          /********************************************************************
1997:           * Function:        USB_HANDLE USBTransferOnePacket(
1998:           *                      BYTE ep, 
1999:           *                      BYTE dir, 
2000:           *                      BYTE* data, 
2001:           *                      BYTE len)
2002:           *
2003:           * PreCondition:    None
2004:           *
2005:           * Input:
2006:           *   BYTE ep - the endpoint the data will be transmitted on
2007:           *   BYTE dir - the direction of the transfer
2008:                          This value is either OUT_FROM_HOST or IN_TO_HOST
2009:           *   BYTE* data - pointer to the data to be sent
2010:           *   BYTE len - length of the data needing to be sent
2011:           *
2012:           * Output:          None
2013:           *
2014:           * Side Effects:    None
2015:           *
2016:           * Overview:        Transfers one packet over the USB
2017:           *
2018:           * Note:            None
2019:           *******************************************************************/
2020:          USB_HANDLE USBTransferOnePacket(BYTE ep,BYTE dir,BYTE* data,BYTE len)
24C8  D904     RCALL __pa_24
2560  D8BF     RCALL __pa_26
2562  52E6     MOVF POSTINC1, F, ACCESS
2564  0012     RETURN 0
2021:          {
2022:              USB_HANDLE handle;
2023:          
2024:              //If the direction is IN
2025:              if(dir != 0)
24CA  0EFC     MOVLW 0xFC
24CC  50DB     MOVF PLUSW2, W, ACCESS
24CE  E002     BZ 0x24D4
2026:              {
2027:                  //point to the IN BDT of the specified endpoint
2028:                  handle = pBDTEntryIn[ep];
24D0  D915     RCALL __pa_28
2029:              }
2030:              else
24D2  D001     BRA 0x24D6
2031:              {
2032:                  //else point to the OUT BDT of the specified endpoint
2033:                  handle = pBDTEntryOut[ep];
24D4  D90E     RCALL __pa_27
24D6  D8C2     RCALL __pa_15
265C  22EA     ADDWFC FSR0H, F, ACCESS
265E  CFEE     MOVFF POSTINC0, POSTINC2
2660  FFDE     NOP
2662  CFED     MOVFF POSTDEC0, POSTDEC2
2664  FFDD     NOP
2666  0012     RETURN 0
2034:              }
2035:          
2036:              //Toggle the DTS bit if required
2037:              #if (USB_PING_PONG_MODE == USB_PING_PONG__NO_PING_PONG)
2038:                  handle->STAT.Val ^= _DTSMASK;
24D8  D876     RCALL __pa_6
24DA  7CEF     BTG INDF0, 6, ACCESS
2039:              #elif (USB_PING_PONG_MODE == USB_PING_PONG__EP0_OUT_ONLY)
2040:                  if(ep != 0)
2041:                  {
2042:                      handle->STAT.Val ^= _DTSMASK;
2043:                  }
2044:              #endif
2045:          
2046:              //Set the data pointer, data length, and enable the endpoint
2047:              handle->ADR = (BYTE*)ConvertToPhysicalAddress(data);
24DC  D874     RCALL __pa_6
24DE  D936     RCALL __pa_34
24E0  0EFA     MOVLW 0xFA
24E2  CFDB     MOVFF PLUSW2, POSTINC0
24E4  FFEE     NOP
24E6  0EFB     MOVLW 0xFB
24E8  CFDB     MOVFF PLUSW2, POSTDEC0
24EA  FFED     NOP
2048:              handle->CNT = len;
24EC  D86C     RCALL __pa_6
24EE  52EE     MOVF POSTINC0, F, ACCESS
24F0  0EF9     MOVLW 0xF9
24F2  CFDB     MOVFF PLUSW2, INDF0
24F4  FFEF     NOP
2049:              handle->STAT.Val &= _DTSMASK;
24F6  0E40     MOVLW 0x40
24F8  D866     RCALL __pa_6
24FA  50E8     MOVF WREG, W, ACCESS
24FC  16EF     ANDWF INDF0, F, ACCESS
2050:              handle->STAT.Val |= _USIE | _DTSEN;
24FE  0E88     MOVLW 0x88
2500  D862     RCALL __pa_6
2502  50E8     MOVF WREG, W, ACCESS
2504  12EF     IORWF INDF0, F, ACCESS
25C6  CFDE     MOVFF POSTINC2, FSR0L
25C8  FFE9     NOP
25CA  CFDD     MOVFF POSTDEC2, FSR0H
25CC  FFEA     NOP
25CE  0012     RETURN 0
2051:          
2052:              //Point to the next buffer for ping pong purposes.
2053:              if(dir != 0)
2506  0EFC     MOVLW 0xFC
2508  50DB     MOVF PLUSW2, W, ACCESS
250A  E002     BZ 0x2510
2054:              {
2055:                  //toggle over the to the next buffer for an IN endpoint
2056:                  ((BYTE_VAL*)&pBDTEntryIn[ep])->Val ^= USB_NEXT_PING_PONG;
250C  D8F7     RCALL __pa_28
26FC  DF69     RCALL __pa_7
26FE  0E3F     MOVLW 0x3F
2700  26E9     ADDWF FSR0L, F, ACCESS
2702  0E04     MOVLW 0x4
2704  0012     RETURN 0
2057:              }
2058:              else
250E  D001     BRA 0x2512
2059:              {
2060:                  //toggle over the to the next buffer for an OUT endpoint
2061:                  ((BYTE_VAL*)&pBDTEntryOut[ep])->Val ^= USB_NEXT_PING_PONG;
2510  D8F0     RCALL __pa_27
2512  22EA     ADDWFC FSR0H, F, ACCESS
25D0  0EFD     MOVLW 0xFD
25D2  6AEA     CLRF FSR0H, ACCESS
25D4  34DB     RLCF PLUSW2, W, ACCESS
25D6  0BFE     ANDLW 0xFE
25D8  36EA     RLCF FSR0H, F, ACCESS
25DA  6EE9     MOVWF FSR0L, ACCESS
25DC  0012     RETURN 0
26F2  DF6E     RCALL __pa_7
26F4  0E37     MOVLW 0x37
26F6  26E9     ADDWF FSR0L, F, ACCESS
26F8  0E04     MOVLW 0x4
26FA  0012     RETURN 0
2062:              }
2063:              return handle;
2514  CFDE     MOVFF POSTINC2, __tmp_0
2516  F014     NOP
2518  CFDD     MOVFF POSTDEC2, 0x15
251A  F015     NOP
251C  C014     MOVFF __tmp_0, PRODL
251E  FFF3     NOP
2520  C015     MOVFF 0x15, PRODH
2522  FFF4     NOP
2064:          }
2524  52E5     MOVF POSTDEC1, F, ACCESS
2526  D03E     BRA __pa_3
25A4  52E5     MOVF POSTDEC1, F, ACCESS
25A6  D08F     BRA __pa_23
26C6  52E5     MOVF POSTDEC1, F, ACCESS
26C8  CFE5     MOVFF POSTDEC1, FSR2H
26CA  FFDA     NOP
26CC  CFE7     MOVFF INDF1, FSR2L
26CE  FFD9     NOP
26D0  0012     RETURN 0
2065:          
2066:          /********************************************************************
2067:           * Function:        void USBClearInterruptFlag(BYTE* reg, BYTE flag)
2068:           *
2069:           * PreCondition:    None
2070:           *
2071:           * Input:           
2072:           *   BYTE* reg - the register address holding the interrupt flag
2073:           *   BYTE flag - the bit number needing to be cleared
2074:           *
2075:           * Output:          None
2076:           *
2077:           * Side Effects:    None
2078:           *
2079:           * Overview:        clears the specified interrupt flag.
2080:           *
2081:           * Note:            
2082:           *******************************************************************/
2083:          void USBClearInterruptFlag(BYTE* reg, BYTE flag)
2528  D8DB     RCALL __pa_26
26E0  CFD9     MOVFF FSR2L, POSTINC1
26E2  FFE6     NOP
26E4  CFDA     MOVFF FSR2H, POSTINC1
26E6  FFE6     NOP
26E8  CFE1     MOVFF FSR1L, FSR2L
26EA  FFD9     NOP
26EC  CFE2     MOVFF FSR1H, FSR2H
26EE  FFDA     NOP
26F0  0012     RETURN 0
2084:          {
2085:              #if defined(__18CXX)
2086:                  *reg &= ~(0x01<<flag);
252A  0E01     MOVLW 0x1
252C  6EF3     MOVWF PRODL, ACCESS
252E  0EFB     MOVLW 0xFB
2530  50DB     MOVF PLUSW2, W, ACCESS
2532  E004     BZ 0x253C
2534  90D8     BCF STATUS, 0, ACCESS
2536  36F3     RLCF PRODL, F, ACCESS
2538  06E8     DECF WREG, F, ACCESS
253A  E1FC     BNZ 0x2534
253C  1CF3     COMF PRODL, W, ACCESS
253E  6E14     MOVWF __tmp_0, ACCESS
2540  0EFC     MOVLW 0xFC
2542  CFDB     MOVFF PLUSW2, FSR0L
2544  FFE9     NOP
2546  0EFD     MOVLW 0xFD
2548  CFDB     MOVFF PLUSW2, FSR0H
254A  FFEA     NOP
254C  5014     MOVF __tmp_0, W, ACCESS
254E  16EF     ANDWF INDF0, F, ACCESS
2087:              #elif defined(__C30__) || defined(__C32__)
2088:                  *reg = (0x01<<flag); 
2089:              #else
2090:                  #error "Function not defined for this compiler       
2091:              #endif
2092:          }
2550  D0BA     BRA __pa_23
2093:          /** EOF USBDevice.c *****************************************************/
---  C:/MCC18/src/traditional/stdclib/memset.asm  -------------------------------------------------------
2C4A  0EFE     MOVLW 0xFE
2C4C  CFE3     MOVFF PLUSW1, FSR0L
2C4E  FFE9     NOP
2C50  0EFF     MOVLW 0xFF
2C52  CFE3     MOVFF PLUSW1, FSR0H
2C54  FFEA     NOP
2C56  CFE9     MOVFF FSR0L, PRODL
2C58  FFF3     NOP
2C5A  CFEA     MOVFF FSR0H, PRODH
2C5C  FFF4     NOP
2C5E  0EFB     MOVLW 0xFB
2C60  50E3     MOVF PLUSW1, W, ACCESS
2C62  E103     BNZ _2jContinue
2C64  0EFC     MOVLW 0xFC
2C66  50E3     MOVF PLUSW1, W, ACCESS
2C68  E009     BZ jEnd
2C6A  0EFB     MOVLW 0xFB
2C6C  06E3     DECF PLUSW1, F, ACCESS
2C6E  E202     BC _3jEnd
2C70  0EFC     MOVLW 0xFC
2C72  06E3     DECF PLUSW1, F, ACCESS
2C74  0EFD     MOVLW 0xFD
2C76  50E3     MOVF PLUSW1, W, ACCESS
2C78  6EEE     MOVWF POSTINC0, ACCESS
2C7A  D7F1     BRA jLoop
2C7C  0012     RETURN 0
---  C:/MCC18/src/traditional/stdclib/memcpy.asm  -------------------------------------------------------
2BF4  CFD9     MOVFF FSR2L, POSTINC1
2BF6  FFE6     NOP
2BF8  CFDA     MOVFF FSR2H, POSTINC1
2BFA  FFE6     NOP
2BFC  0EFA     MOVLW 0xFA
2BFE  CFE3     MOVFF PLUSW1, FSR2L
2C00  FFD9     NOP
2C02  0EFB     MOVLW 0xFB
2C04  CFE3     MOVFF PLUSW1, FSR2H
2C06  FFDA     NOP
2C08  0EFC     MOVLW 0xFC
2C0A  CFE3     MOVFF PLUSW1, FSR0L
2C0C  FFE9     NOP
2C0E  0EFD     MOVLW 0xFD
2C10  CFE3     MOVFF PLUSW1, FSR0H
2C12  FFEA     NOP
2C14  CFE9     MOVFF FSR0L, PRODL
2C16  FFF3     NOP
2C18  CFEA     MOVFF FSR0H, PRODH
2C1A  FFF4     NOP
2C1C  0EF8     MOVLW 0xF8
2C1E  50E3     MOVF PLUSW1, W, ACCESS
2C20  E103     BNZ _4jContinue
2C22  0EF9     MOVLW 0xF9
2C24  50E3     MOVF PLUSW1, W, ACCESS
2C26  E008     BZ jEnd
2C28  0EF8     MOVLW 0xF8
2C2A  06E3     DECF PLUSW1, F, ACCESS
2C2C  E202     BC _5jEnd
2C2E  0EF9     MOVLW 0xF9
2C30  06E3     DECF PLUSW1, F, ACCESS
2C32  CFDE     MOVFF POSTINC2, POSTINC0
2C34  FFEE     NOP
2C36  D7F2     BRA jLoop
2C38  0EFF     MOVLW 0xFF
2C3A  CFE3     MOVFF PLUSW1, FSR2H
2C3C  FFDA     NOP
2C3E  52E5     MOVF POSTDEC1, F, ACCESS
2C40  0EFF     MOVLW 0xFF
2C42  CFE3     MOVFF PLUSW1, FSR2L
2C44  FFD9     NOP
2C46  52E5     MOVF POSTDEC1, F, ACCESS
2C48  0012     RETURN 0
---  C:/MCC18/src/traditional/stdclib/__init.c  ---------------------------------------------------------
2C9A  0012     RETURN 0
---  C:/MCC18/src/traditional/startup/c018i.c  ----------------------------------------------------------
0000  EF9D     GOTO 0xFF3A
0002  F07F     NOP
0004  0012     RETURN 0
2C7E  EE1D     LFSR 1, 0xD00
2C80  F000     NOP
2C82  EE2D     LFSR 2, 0xD00
2C84  F000     NOP
2C86  6AF8     CLRF TBLPTRU, ACCESS
2C88  9C01     BCF p, 6, ACCESS
2C8A  EC62     CALL 0x2AC4, 0
2C8C  F015     NOP
2C8E  EC4D     CALL 0x2C9A, 0
2C90  F016     NOP
2C92  ECB5     CALL 0x1B6A, 0
2C94  F00D     NOP
2C96  D7FB     BRA 0x2C8E
2C98  0012     RETURN 0
2AC4  0E1A     MOVLW 0x1A
2AC6  6EF6     MOVWF TBLPTRL, ACCESS
2AC8  0E08     MOVLW 0x8
2ACA  6EF7     MOVWF TBLPTRH, ACCESS
2ACC  0E00     MOVLW 0x0
2ACE  6EF8     MOVWF TBLPTRU, ACCESS
2AD0  0100     MOVLB 0x0
2AD2  0009     TBLRD*+
2AD4  50F5     MOVF TABLAT, W, ACCESS
2AD6  6FF1     MOVWF curr_entry, BANKED
2AD8  0009     TBLRD*+
2ADA  50F5     MOVF TABLAT, W, ACCESS
2ADC  6FF2     MOVWF 0xF2, BANKED
2ADE  E103     BNZ 0x2AE6
2AE0  67F1     TSTFSZ curr_entry, BANKED
2AE2  D001     BRA 0x2AE6
2AE4  D03D     BRA 0x2B60
2AE6  0009     TBLRD*+
2AE8  50F5     MOVF TABLAT, W, ACCESS
2AEA  6FEC     MOVWF prom, BANKED
2AEC  0009     TBLRD*+
2AEE  50F5     MOVF TABLAT, W, ACCESS
2AF0  6FED     MOVWF 0xED, BANKED
2AF2  0009     TBLRD*+
2AF4  50F5     MOVF TABLAT, W, ACCESS
2AF6  6FEE     MOVWF 0xEE, BANKED
2AF8  0009     TBLRD*+
2AFA  0009     TBLRD*+
2AFC  50F5     MOVF TABLAT, W, ACCESS
2AFE  6EE9     MOVWF FSR0L, ACCESS
2B00  0009     TBLRD*+
2B02  50F5     MOVF TABLAT, W, ACCESS
2B04  6EEA     MOVWF FSR0H, ACCESS
2B06  0009     TBLRD*+
2B08  0009     TBLRD*+
2B0A  0009     TBLRD*+
2B0C  50F5     MOVF TABLAT, W, ACCESS
2B0E  6FEF     MOVWF curr_byte, BANKED
2B10  0009     TBLRD*+
2B12  50F5     MOVF TABLAT, W, ACCESS
2B14  6FF0     MOVWF 0xF0, BANKED
2B16  0009     TBLRD*+
2B18  0009     TBLRD*+
2B1A  CFF6     MOVFF TBLPTRL, data_ptr
2B1C  F0F3     NOP
2B1E  CFF7     MOVFF TBLPTRH, 0xF4
2B20  F0F4     NOP
2B22  CFF8     MOVFF TBLPTRU, 0xF5
2B24  F0F5     NOP
2B26  C0EC     MOVFF prom, TBLPTRL
2B28  FFF6     NOP
2B2A  C0ED     MOVFF 0xED, TBLPTRH
2B2C  FFF7     NOP
2B2E  C0EE     MOVFF 0xEE, TBLPTRU
2B30  FFF8     NOP
2B32  0100     MOVLB 0x0
2B34  53EF     MOVF curr_byte, F, BANKED
2B36  E102     BNZ 0x2B3C
2B38  53F0     MOVF 0xF0, F, BANKED
2B3A  E007     BZ 0x2B4A
2B3C  0009     TBLRD*+
2B3E  50F5     MOVF TABLAT, W, ACCESS
2B40  6EEE     MOVWF POSTINC0, ACCESS
2B42  07EF     DECF curr_byte, F, BANKED
2B44  E2F8     BC 0x2B36
2B46  07F0     DECF 0xF0, F, BANKED
2B48  D7F9     BRA 0x2B3C
2B4A  C0F3     MOVFF data_ptr, TBLPTRL
2B4C  FFF6     NOP
2B4E  C0F4     MOVFF 0xF4, TBLPTRH
2B50  FFF7     NOP
2B52  C0F5     MOVFF 0xF5, TBLPTRU
2B54  FFF8     NOP
2B56  0100     MOVLB 0x0
2B58  07F1     DECF curr_entry, F, BANKED
2B5A  0E00     MOVLW 0x0
2B5C  5BF2     SUBWFB 0xF2, F, BANKED
2B5E  D7BF     BRA 0x2ADE
2B60  0012     RETURN 0
---  C:/MCC18/src/traditional/proc/p18F26J50.asm  -------------------------------------------------------
1BFA  0EC0     MOVLW 0xC0
1BFC  6EF3     MOVWF PRODL, ACCESS
1BFE  EE00     LFSR 0, 0x0
1C00  F000     NOP
1C02  0E0E     MOVLW 0xE
1C04  D801     RCALL zero_block
1C06  0012     RETURN 0
1C08  60EA     CPFSLT FSR0H, ACCESS
1C0A  D002     BRA compare_l
1C0C  6AEE     CLRF POSTINC0, ACCESS
1C0E  D7FC     BRA zero_block
1C10  50F3     MOVF PRODL, W, ACCESS
1C12  60E9     CPFSLT FSR0L, ACCESS
1C14  0012     RETURN 0
1C16  6AEE     CLRF POSTINC0, ACCESS
1C18  D7FC     BRA loop_l
---  C:/MCC18/src/traditional/math/fxm2424u.asm  --------------------------------------------------------
2B62  C009     MOVFF 0x9, 0x13
2B64  F013     NOP
2B66  C008     MOVFF 0x8, 0x12
2B68  F012     NOP
2B6A  C007     MOVFF 0x7, 0x11
2B6C  F011     NOP
2B6E  5007     MOVF 0x7, W, ACCESS
2B70  020C     MULWF 0xC, ACCESS
2B72  CFF4     MOVFF PRODH, 0x5
2B74  F005     NOP
2B76  CFF3     MOVFF PRODL, while_cnt
2B78  F004     NOP
2B7A  5008     MOVF 0x8, W, ACCESS
2B7C  020D     MULWF 0xD, ACCESS
2B7E  CFF4     MOVFF PRODH, 0x7
2B80  F007     NOP
2B82  CFF3     MOVFF PRODL, 0x6
2B84  F006     NOP
2B86  020C     MULWF 0xC, ACCESS
2B88  50F3     MOVF PRODL, W, ACCESS
2B8A  2605     ADDWF 0x5, F, ACCESS
2B8C  50F4     MOVF PRODH, W, ACCESS
2B8E  2206     ADDWFC 0x6, F, ACCESS
2B90  6AE8     CLRF WREG, ACCESS
2B92  2207     ADDWFC 0x7, F, ACCESS
2B94  5011     MOVF 0x11, W, ACCESS
2B96  020D     MULWF 0xD, ACCESS
2B98  50F3     MOVF PRODL, W, ACCESS
2B9A  2605     ADDWF 0x5, F, ACCESS
2B9C  50F4     MOVF PRODH, W, ACCESS
2B9E  2206     ADDWFC 0x6, F, ACCESS
2BA0  6AE8     CLRF WREG, ACCESS
2BA2  2207     ADDWFC 0x7, F, ACCESS
2BA4  5009     MOVF 0x9, W, ACCESS
2BA6  020C     MULWF 0xC, ACCESS
2BA8  50F3     MOVF PRODL, W, ACCESS
2BAA  2606     ADDWF 0x6, F, ACCESS
2BAC  50F4     MOVF PRODH, W, ACCESS
2BAE  2207     ADDWFC 0x7, F, ACCESS
2BB0  5009     MOVF 0x9, W, ACCESS
2BB2  020D     MULWF 0xD, ACCESS
2BB4  6A08     CLRF 0x8, ACCESS
2BB6  6AE8     CLRF WREG, ACCESS
2BB8  2208     ADDWFC 0x8, F, ACCESS
2BBA  50F3     MOVF PRODL, W, ACCESS
2BBC  2607     ADDWF 0x7, F, ACCESS
2BBE  50F4     MOVF PRODH, W, ACCESS
2BC0  2208     ADDWFC 0x8, F, ACCESS
2BC2  5011     MOVF 0x11, W, ACCESS
2BC4  020E     MULWF 0xE, ACCESS
2BC6  50F3     MOVF PRODL, W, ACCESS
2BC8  2606     ADDWF 0x6, F, ACCESS
2BCA  50F4     MOVF PRODH, W, ACCESS
2BCC  2207     ADDWFC 0x7, F, ACCESS
2BCE  6A09     CLRF 0x9, ACCESS
2BD0  6AE8     CLRF WREG, ACCESS
2BD2  2208     ADDWFC 0x8, F, ACCESS
2BD4  2209     ADDWFC 0x9, F, ACCESS
2BD6  5012     MOVF 0x12, W, ACCESS
2BD8  020E     MULWF 0xE, ACCESS
2BDA  50F3     MOVF PRODL, W, ACCESS
2BDC  2607     ADDWF 0x7, F, ACCESS
2BDE  50F4     MOVF PRODH, W, ACCESS
2BE0  2208     ADDWFC 0x8, F, ACCESS
2BE2  6AE8     CLRF WREG, ACCESS
2BE4  2209     ADDWFC 0x9, F, ACCESS
2BE6  5013     MOVF 0x13, W, ACCESS
2BE8  020E     MULWF 0xE, ACCESS
2BEA  50F3     MOVF PRODL, W, ACCESS
2BEC  2608     ADDWF 0x8, F, ACCESS
2BEE  50F4     MOVF PRODH, W, ACCESS
2BF0  2209     ADDWFC 0x9, F, ACCESS
2BF2  0C00     RETLW 0x0
